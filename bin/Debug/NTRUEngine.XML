<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NTRUEngine</name>
    </assembly>
    <members>
        <member name="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">
            <summary>
            Wraps exceptions thrown within a PRNG Generators operational context.
            <para>This exception is used throughout the Prng and Seed classes.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">
            <summary>
            Pseudo Random Number Generator Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Next(System.Int32)">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Next(System.Int32,System.Int32)">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial">
            <summary>
            A <c>TernaryPolynomial</c> with a "low" number of nonzero coefficients.
            <para>Coefficients are represented as two arrays, one containing the indices of one-values
            and the other containing indices of negative ones.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial">
            <summary>
            A polynomial whose coefficients are all equal to -1, 0, or 1
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial">
            <summary>
            Polynomial interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial.Clear">
            <summary>
            Clear the state data
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial by a <c>BigIntPolynomial</c>, taking the indices mod N. Does not
            change this polynomial but returns the result as a new polynomial.
            <para>Both polynomials must have the same number of coefficients.</para>
            </summary>
            
            <param name="Factor">The polynomial to multiply by</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the coefficient values mod <c>modulus</c> and the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            <param name="Modulus">The modulus to apply</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial.ToIntegerPolynomial">
            <summary>
            Returns a polynomial that is equal to this polynomial (in the sense that mult(IntegerPolynomial, int) 
            returns equal <c>IntegerPolynomial</c>s). The new polynomial is guaranteed to be independent of the original.
            </summary>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>, taking the indices mod N
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial.GetOnes">
            <summary>
            Get the number of ones
            </summary>
            
            <returns>Ones count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial.GetNegOnes">
            <summary>
            Get the number of negative ones
            </summary>
            
            <returns>negative ones count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial.Size">
            <summary>
            Returns the maximum number of coefficients the polynomial can have
            </summary>
            
            <returns>Coefficients size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial.Clear">
            <summary>
            Clear the coefficients
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.#ctor(System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Constructs a new polynomial
            </summary>
            
            <param name="N">Total number of coefficients including zeros</param>
            <param name="Ones">Indices of coefficients equal to 1 in ascending order</param>
            <param name="NegOnes">Indices of coefficients equal to -1 in ascending order</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Constructs a <c>DenseTernaryPolynomial</c> from a <c>IntegerPolynomial</c>.
            <para>The two polynomials are independent of each other.</para>
            </summary>
            
            <param name="IntPoly">The original polynomial></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.#ctor(System.Int32[])">
            <summary>
            Constructs a new <c>SparseTernaryPolynomial</c> with a given set of coefficients.
            </summary>
            
            <param name="Coeffs">The coefficients</param>
            
            <exception cref="!:NTRUException">Throws if the coefficients are not ternary</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.Clear">
            <summary>
            Clear the coefficients
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.FromBinary(System.IO.MemoryStream,System.Int32)">
            <summary>
            Decodes a polynomial encoded with ToBinary()
            </summary>
            
            <param name="InputStream">An input stream containing an encoded polynomial</param>
            <param name="N">Number of coefficients in the polynomial</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.GenerateBlindingPoly(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator,System.Int32,System.Int32)">
            <summary>
            Generates a blinding polynomial using an IndexGenerator
            </summary>
            
            <param name="Ig">An Index Generator</param>
            <param name="N">The number of coefficients</param>
            <param name="Dr">The number of ones / negative ones</param>
            
            <returns>A blinding polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.GenerateRandom(System.Int32,System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Generates a random polynomial with <c>numOnes</c> coefficients equal to 1,
            <c>numNegOnes</c> coefficients equal to -1, and the rest equal to 0.
            </summary>
            
            <param name="N">Number of coefficients</param>
            <param name="NumOnes">Number of 1's</param>
            <param name="NumNegOnes">Number of -1's</param>
            <param name="Rng">Random number generator</param>
            
            <returns>The new SparseTernaryPolynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.GetNegOnes">
            <summary>
            Get the number of negative ones
            </summary>
            
            <returns>negative ones count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.GetOnes">
            <summary>
            Get the number of ones
            </summary>
            
            <returns>Ones count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the coefficient values mod <c>modulus</c> and the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            <param name="Modulus">The modulus to apply</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial by a <c>BigIntPolynomial</c>, taking the indices mod N. Does not
            change this polynomial but returns the result as a new polynomial.
            <para>Both polynomials must have the same number of coefficients.</para>
            </summary>
            
            <param name="Factor">The polynomial to multiply by</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.ToBinary">
            <summary>
            Encodes the polynomial to a byte array writing <c>BITS_PER_INDEX</c> bits for each coefficient
            </summary>
            
            <returns>The encoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.ToIntegerPolynomial">
            <summary>
            Returns a polynomial that is equal to this polynomial (in the sense that Multiply(IntegerPolynomial, int) 
            returns equal <c>IntegerPolynomial</c>s). The new polynomial is guaranteed to be independent of the original.
            </summary>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.Size">
            <summary>
            Returns the maximum number of coefficients the polynomial can have
            </summary>
            
            <returns>Coefficients size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.Equals(System.Object)">
            <summary>
            Compare this polynomial to another for equality
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.GetHashCode">
            <summary>
            Get the hash code
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial5">
            <summary>
            A polynomial class that combines five coefficients into one <c>long</c> value for
            faster multiplication by a ternary polynomial.
            <para>Coefficients can be between 0 and 2047 and are stored in bits 0..11, 12..23, ..., 48..59 of a <c>long</c> number.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial5.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Constructs a <c>LongPolynomial5</c> from a <c>IntegerPolynomial</c>. The two polynomials are independent of each other.
            </summary>
            
            <param name="P">The original polynomial. Coefficients must be between 0 and 2047.</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial5.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial)">
            <summary>
            Multiplies the polynomial with a <c>TernaryPolynomial</c>, taking the indices mod N and the values mod 2048.
            </summary>
            
            <param name="Factor">The polynomial factor</param>
            
            <returns>The multiplication product</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial5.ToIntegerPolynomial">
            <summary>
            Returns a polynomial that is equal to this polynomial (in the sense that mult(IntegerPolynomial, int) 
            returns equal <c>IntegerPolynomial</c>s). The new polynomial is guaranteed to be independent of the original.
            </summary>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5">
            <summary>
            <h3>PKCS5 V2: An implementation of an Hash based Key Derivation Function.</h3>
            <para>PKCS5 Version 2, as outlined in RFC 2898<cite>RFC 2898</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new PKCS5(new SHA512(), 10000))
            {
                // initialize
                rnd.Initialize(Salt, Ikm, [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/28/15" version="1.3.1.1">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac HMAC</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with a <see cref="!:Digests">Digest</see> or a <see cref="!:Macs">Mac</see>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Int32,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Salt size should be multiple of Digest block size.</description></item>
            <item><description>Ikm size should be Digest hash return size.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2898: <see href="http://tools.ietf.org/html/rfc2898">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator">
            <summary>
            Random Generator Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Salt does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Salt does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.#ctor(System.Int32)">
            <summary>
            Creates a PKCS5 Bytes Generator using the default SHA512 HMAC engine
            </summary>
            
            <param name="Iterations">The number of cycles used to produce output</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if an invalid Iterations count is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Int32,System.Boolean)">
            <summary>
            Creates a PKCS5 Bytes Generator based on the given hash function
            </summary>
            
            <param name="Digest">The digest used</param>
            <param name="Iterations">The number of cycles used to produce output</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Digest or Iterations count is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.#ctor(VTDev.Libraries.CEXEngine.Crypto.Mac.IMac,System.Int32,System.Boolean)">
            <summary>
            Creates a PKCS5 Bytes Generator based on the given HMAC function
            </summary>
            
            <param name="Hmac">The HMAC digest used</param>
            <param name="Iterations">The number of cycles used to produce output</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Hmac or invalid Iterations count is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg">
            <summary>
            <h3>DGTDRBG: An implementation of a Digest Counter based Deterministic Random Byte Generator.</h3>
            <para>A Digest Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90A</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new DGTDRBG(new SHA512()))
            {
                // initialize
                rnd.Initialize(Salt, [Ikm], [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with any <see cref="!:Digests">digest</see>.</description></item>
            <item><description>Combination of [Salt, Ikm, Nonce] must be at least: digest block size + counter (8 bytes) size in length.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            <item><description>Output buffer is 4 * the digest return size.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-90A: <see href="http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf">Appendix E1.</see></description></item>
            <item><description>NIST SP800-90B: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">Recommendation for the Entropy Sources Used for Random Bit Generation</see>.</description></item>
            <item><description>NIST Fips 140-2: <see href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Security Requirments For Cryptographic Modules</see>.</description></item>
            <item><description>NIST SP800-22 1a: <see href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</see>.</description></item>
            <item><description>Security Bounds for the NIST Codebook-based: <see href="http://eprint.iacr.org/2006/379.pdf">Deterministic Random Bit Generator</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Digest">Hash function</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if an invalid or null salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if an invalid or null salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Info value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if an invalid or null salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Update(System.Byte[])">
            <summary>
            <para>Update the Seed material. Three state Seed paramater: 
            If Seed size is equal to digest blocksize plus counter size, both are updated. 
            If Seed size is equal to digest block size, internal state seed is updated.
            If Seed size is equal to counter size (8 bytes) counter is updated.</para>
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null or invalid Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams">
            <summary>
            A Cipher Key and Vector Container class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams.#ctor(System.Byte[])">
            <summary>
            Initialize the class with a Cipher Key
            </summary>
            
            <param name="Key">Cipher Key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Initialize the class with a Cipher Key and IV.
            </summary>
            
            <param name="Key">Cipher Key</param>
            <param name="IV">Cipher IV</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams.#ctor(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the class with a Cipher Key, IV, and IKM.
            </summary>
            
            <param name="Key">Cipher Key</param>
            <param name="IV">Cipher IV</param>
            <param name="IKM">IKM value</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams.DeSerialize(System.IO.Stream)">
            <summary>
            Deserialize a KeyParams class
            </summary>
            
            <param name="KeyStream">Stream containing the KeyParams data</param>
            
            <returns>A populated KeyParams class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams.Serialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Serialize a KeyParams class
            </summary>
            
            <param name="KeyObj">A KeyParams class</param>
            
            <returns>A stream containing the KeyParams data</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams.IKM">
            <summary>
            Input Key Material
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams.Key">
            <summary>
            Cipher Key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams.IV">
            <summary>
            Cipher Initialization Vector
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng">
            <summary>
            <h3>SP20Prng: An implementation of a Encryption Counter based Deterministic Random Number Generator.</h3>
            <para>Uses the Salsa20 Key stream as a source of random input.</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IRandom</c> interface:</description>
            <code>
            int num;
            using (IRandom rnd = new SP20Prng([SeedGenerators], [BufferSize], [SeedSize], [RoundsCount]))
            {
                // get random int
                num = rnd.Next([Minimum], [Maximum]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/14" version="1.4.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 256 (16 and 32 bytes).</description></item>
            <item><description>Block size is 64 bytes wide.</description></item>
            <item><description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description></item>
            <item><description>Parallel block size is 64,000 bytes by default; but is configurable.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Salsa20 <see href="http://www.ecrypt.eu.org/stream/salsa20pf.html">Specification</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/design.pdf">Design</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/security.pdf">Security</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.#ctor(VTDev.Libraries.CEXEngine.Crypto.Enumeration.SeedGenerators,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="SeedEngine">The Seed engine used to create keyng material (default is CSPRsg)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            <param name="SeedSize">The size of the seed to generate in bytes; can be 32 for a 128 bit key or 48 for a 256 bit key</param>
            <param name="Rounds">The number of diffusion rounds to use when generating the key stream</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if the seed is null or invalid, or rounds count is out of range</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initialize the class with a Seed; note: the same seed will produce the same random output
            </summary>
            
            <param name="Seed">The Seed bytes used to initialize the digest counter; (min. length is key size + iv of 16 bytes)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            <param name="Rounds">The number of diffusion rounds to use when generating the key stream</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if the seed is null or invalid, or rounds count is out of range</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator">
            <summary>
            This class implements the key pair generation of the NTRU Public Key Crypto System
            </summary>
            
            <example>
            <description>Example of generating a key pair:</description>
            <code>
            // use a predefined parameters set
            NtruParameters ps = DefinedParameters.EES1087EP3;
            
            using (NTRUKeyGenerator gen = new NTRUKeyGenerator(ps))
            {
                // generate a keypair
                NtruKeyPair kp = gen.GenerateKeyPair();
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.0.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUKeyPair Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUParameters Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricCipher Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
            
            <remarks>
            <description><h5>Key Generation:</h5></description>
            <list type="table">
            <item><description>Randomly generate polynomials f and g in Df, Dg respectively.</description></item>
            <item><description>Invert f in Rq to obtain fq, invert f in Rp to obtain fp, and check that g is invertible in Rq.</description></item>
            <item><description>The public key h = p ∗ g ∗ fq (mod q). The private key is the pair (f, fp).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NTRU: A Ring Based Public Key Crypto System<cite>NTRU Crypto</cite>.</description></item>
            <item><description>Optimizations for NTRU<cite>NTRU Optimizations</cite>.</description></item>
            <item><description>Adaptive Key Recovery Attacks on NTRU-based Somewhat Homomorphic Encryption Schemes<cite>NTRU Adaptive</cite>.</description></item>
            <item><description>Efficient Embedded Security Standards (EESS)<cite>NTRU EESS</cite>.</description></item>
            <item><description>Practical lattice-based cryptography: NTRUEncrypt and NTRUSign<cite>NTRU Practical</cite>.</description></item>
            <item><description>NTRU Cryptosystems Technical Report<cite>NTRU Technical</cite>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent java project NTRU Encrypt by Tim Buktu: <see href="https://github.com/tbuktu/ntru/description">Release 1.2</see>, and
            the NTRUOpenSourceProject/ntru-crypto project provided by Security Innovation, Inc: <see href="https://github.com/NTRUOpenSourceProject/ntru-crypto">Release 1.2</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricGenerator">
            <summary>
            The Asymmertic Generator interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricGenerator.GenerateKeyPair">
            <summary>
            Generate an asymmetric Key pair
            </summary>
            
            <returns>An asymmetric containing public and private keys</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricGenerator.Name">
            <summary>
            Get: The generators name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters,System.Boolean)">
            <summary>
            Constructs a new instance with a set of encryption parameters
            </summary>
            
            <param name="CipherParams">Encryption parameters</param>
            <param name="Parallel">Use parallel processing when generating a key; set to false if using a passphrase type generator (default is true)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if a Prng that requires pre-initialization is specified; (wrong constructor)</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom,System.Boolean)">
            <summary>
            Use an initialized prng to generate the key; use this constructor with an Rng that requires pre-initialization, i.e. PBPrng
            </summary>
            
            <param name="CipherParams">The NTRUParameters instance containing the cipher settings</param>
            <param name="RngEngine">An initialized Prng instance</param>
            <param name="Parallel">Use parallel processing when generating a key; set to false if using a passphrase type generator (default is true)</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GenerateKeyPair">
            <summary>
            Generates a new encryption key pair
            </summary>
            
            <returns>A key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GenerateKeyPair(System.Byte[],System.Byte[])">
            <summary>
            Generates an encryption key pair using a passphrase based prng.
            <para>Invoking this method with the same passphrase and salt will always return the same key pair.</para>
            </summary>
            
            <param name="Passphrase">The passphrase</param>
            <param name="Salt">Salt for the passphrase; can be <c>null</c> but this is strongly discouraged</param>
            
            <returns>A populated IAsymmetricKeyPair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GenerateSalt(System.Int32)">
            <summary>
            A convenience method that generates a random salt vector for key pair generation.
            </summary>
            
            <param name="Size">Byte length of the new salt</param>
            
            <returns>A new salt vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GenerateKeyPair(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Generates a new encryption key pair
            </summary>
            
            <param name="RngEngine">The random number generator to use for generating the secret polynomials f and g</param>
            
            <returns>A key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GenerateKeyPair(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Generates a new encryption key pair
            </summary>
            
            <param name="RngF">The random number generator to use for generating the secret polynomial f</param>
            <param name="RngG">The random number generator to use for generating the secret polynomial g</param>
            
            <returns>A key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GenerateG(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <remarks>
            Generates the ephemeral secret polynomial 'g'.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Digest">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the Prng
            </summary>
            
            <param name="Prng">Prng type</param>
            
            <returns>Instance of Prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.Name">
            <summary>
            Get: Generator name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines">
            <summary>
            Asymmetric Encryption Ciphers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines.McEliece">
            <summary>
            An McEliece CCA2 cipher implementation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines.NTRU">
            <summary>
            An NTRU cipher implementation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines.RingLWE">
            <summary>
            An Ring-LWE cipher implementation
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX">
            <summary>
            <h3>TFX: An extended implementation of the Twofish encryption cipher.</h3>
            <para>TFX is an implementation of the Twofish<cite>Twofish</cite> block cipher, extended to use a 512 bit key.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new TFX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/14" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 192, 256 and 512 bits (16, 24, 32 and 64 bytes).</description></item>
            <item><description>Block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 18, 20, 22, 24, 26, 28, 30 and 32, default is 16.</description></item>
            </list>
            
            <para>TFX extends the original design allowing it to accept the longer key length (512 bits).</para>
            
            <para>The number of diffusion rounds processed in the ciphers transformation method has also been extended, and is user configurable; 
            from the original 16 rounds, to a full 32 rounds of transformation. 
            This increase in key size eliminates brute force attacks, and the increase in the number of diffusion rounds makes cryptanalysis far more difficult.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">A 128-Bit Block Cipher</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher">
            <summary>
            Block Cipher Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. The LegalKeySizes property contains valid sizes</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalRounds"/> property contains available sizes. Default is 16 rounds.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX">
            <summary>
            <h3>RDX: An extended implementation of the Rijndael encryption cipher.</h3>
            <para>RDX is an implementation of the Rijndael<cite>Rijndael</cite> encryption algorithm, extended to use a 512 bit key</para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RDX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/10" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 192, 256, and 512 bit.</description></item>
            <item><description>Valid block sizes are 16 and 32 bytes wide.</description></item>
            </list>
            
            <para>RDX is an implementation of the Rijndael<cite>Rijndael</cite> encryption algorithm, the same one used in the AES<cite>Fips 197</cite> standard. 
            What has been done is to extend Rijndael so that it now accepts the longer key length (512 bits). 
            The extended key length provides more security against attacks that attempt to brute force the key, and also adds eight more rounds of diffusion.</para>
            
            <para>The increased number of rounds brings the total from 14 rounds with a 256 bit key, to 22 rounds with the 512 bit key size. 
            These added passes through the rounds function further disperse the input through row and column transpositions, and XOR’s with a longer expanded key array.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>AES Proposal: <see href="http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf">Rijndael</see>.</description></item>
            <item><description>Fips 197: Announcing the <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">Advanced Encryption Standard (AES)</see></description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.#ctor(System.Int32)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="BlockSize">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalBlockSizes"/> property contains available sizes. Default is 16 bytes.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid block size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and set state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher">
            <summary>
            The Asymmetric cipher interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the Key for Encrypt (Public) or Decrypt (Private)
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the Public (encrypt) or Private (decryption) key</param>
            
            <exception cref="!:CryptoAsymmetricSignException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.Decrypt(System.Byte[])">
            <summary>
            Decrypt a cipher text
            </summary>
            
            <param name="Input">The cipher text</param>
            
            <returns>The plain text</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.Encrypt(System.Byte[])">
            <summary>
            Encrypt a plain text message
            </summary>
            
            <param name="Input">The plain text</param>
            
            <returns>The cipher text</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can encrypt
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.Name">
            <summary>
            Get: The ciphers name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Tools.Compare">
            <summary>
            Compare arrays for equality
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.False(System.Boolean)">
            <summary>
            Returns true if condition is false
            </summary>
            
            <param name="B">Test variable</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.True(System.Boolean)">
            <summary>
            Returns true if condition is true
            </summary>
            
            <param name="B">Test variable</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(VTDev.Libraries.CEXEngine.Numeric.BigDecimal[],VTDev.Libraries.CEXEngine.Numeric.BigDecimal[])">
            <summary>
            Compare BigDecimal Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(VTDev.Libraries.CEXEngine.Numeric.BigInteger[],VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Compare BigInteger Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Compare Byte Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Char[],System.Char[])">
            <summary>
            Compare Char Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Int16[],System.Int16[])">
            <summary>
            Compare short integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Int32[],System.Int32[])">
            <summary>
            Compare Integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Int64[],System.Int64[])">
            <summary>
            Compare Integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Single[],System.Single[])">
            <summary>
            Compare float Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Double[],System.Double[])">
            <summary>
            Compare double Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual``1(``0[][],``0[][])">
            <summary>
            Compare Integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.MathContext">
            <summary>
            Immutable objects describing settings such as rounding mode and digit precision for the numerical operations 
            provided by class <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.MathContext.Decimal128">
            <summary>
            A MathContext which corresponds to the IEEE 754r quadruple decimal precision format: 34 digit precision and RoundingMode.HalfEven rounding
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.MathContext.Decimal32">
            <summary>
            A MathContext which corresponds to the IEEE 754r single decimal precision format: 7 digit precision and RoundingMode.HalfEven rounding
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.MathContext.Decimal64">
            <summary>
            A MathContext which corresponds to the IEEE 754r double decimal precision format: 16 digit precision and RoundingMode.HalfEven rounding
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.MathContext.Unlimited">
            <summary>
            A MathContext for unlimited precision with RoundingMode.HalfUp rounding
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.#ctor(System.Int32)">
            <summary>
            Constructs a new MathContext with the specified precision and with the rounding mode RoundingMode.HalfUp.
            <para>If the precision passed is zero, then this implies that the computations have to be performed exact, the rounding mode in this case is irrelevant.</para>
            </summary>
            
            <param name="Precision">The precision for the new MathContext</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Constructs a new MathContext with the specified precision and with the specified rounding mode.
            <para>If the precision passed is zero, then this implies that the computations have to be performed exact, the rounding mode in this case is irrelevant.</para>
            </summary>
            
            <param name="Precision">The precision for the new MathContext</param>
            <param name="RoundingMode">The rounding mode for the new MathContext</param>
            
            <exception cref="T:System.ArgumentException">Thrown if the Precision is less than zero</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.#ctor(System.String)">
            <summary>
            Constructs a new MathContext from a string.
            <para>The string has to specify the precision and the rounding mode to be used and has to follow the following syntax:
            "Precision=&lt;Precision&gt; RoundingMode=&lt;RoundingMode&gt;"
            This is the same form as the one returned by the ToString method.</para>
            </summary>
            
            <param name="Value">A string describing the precision and rounding mode for the new MathContext</param>
            
            <exception cref="T:System.ArgumentException">Thrown if the string is not in the correct format or if the Precision specified is &lt; 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.Equals(System.Object)">
            <summary>
            Returns true if Obj is a MathContext with the same precision setting and the same rounding mode as this MathContext instance.
            </summary>
            
            <param name="Obj">bject to be compared</param>
            
            <returns>Returns true if this MathContext instance is equal to the Obj argument, false otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.GetHashCode">
            <summary>
            Returns the hash code for this MathContext instance
            </summary>
            
            <returns>Returns the hash code for this MathContext</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.ToString">
            <summary>
            Returns the string representation for this MathContext instance
            <para>The string has the form "Precision=&lt;Precision&gt; RoundingMode=&lt;RoundingMode&gt;" 
            where &lt;Precision&gt; is an integer describing the number of digits used for operations and
            &lt;RoundingMode&gt; is the string representation of the rounding mode.</para>
            </summary>
            
            <returns>Returns a string representation for this MathContext instance</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.MathContext.Precision">
            <summary>
            Returns the precision.
            <para>The precision is the number of digits used for an operation.</para>
            </summary>
            
            <remarks>
            <para>Results are rounded to this precision.
            The precision is guaranteed to be non negative.
            If the precision is zero, then the computations have to be performed exact,
            results are not rounded in this case.</para></remarks>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.MathContext.RoundingMode">
            <summary>
            Returns the rounding mode.
            <para>The rounding mode is the strategy to be used to round results.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Elementary">
            <summary>
            Static library that provides the basic arithmetic mutable operations for BigInteger.
            
            <description>The operations provided are:</description>
            <list type="bullet">
            <item><description>Addition</description></item>
            <item><description>Subtraction</description></item>
            <item><description>Comparison</description>/></item>
            </list>
            
            <para>In addition to this, some Inplace (mutable) methods are provided.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.Add(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            See BigInteger#add(BigInteger)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.CompareArrays(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Compares two arrays. All elements are treated as unsigned integers. 
            <para>The magnitude is the bit chain of elements in big-endian order.</para>
            </summary>
            
            <param name="A">The first array</param>
            <param name="B">The second array</param>
            <param name="Size">Size the size of arrays</param>
            
            <returns>Returns 1 if A > B, -1 if A &lt; B, 0 if A == B</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.CompleteInPlaceAdd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Same as InplaceAdd(BigInteger, BigInteger), but without the restriction of non-positive values
            </summary>
            
            <param name="A">The operand</param>
            <param name="B">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.CompleteInPlaceSubtract(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Same as InplaceSubtract(BigInteger, BigInteger), but without the restriction of non-positive values
            <para>Op1 should have enough space to save the result</para>
            </summary>
            
            <param name="A">The input minuend, and the output result</param>
            <param name="B">The subtrahend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.InplaceAdd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs Op1 += Op2.
            <para>Op1 must have enough place to store the result (i.e. Op1.BitLength() >= Op2.BitLength()). 
            Both should be positive (i.e. Op1 >= Op2).</para>
            </summary>
            
            <param name="A">The input minuend, and the output result</param>
            <param name="B">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.InplaceAdd(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Adds an integer value to the array of integers remembering carry
            </summary>
            
            <param name="A">The input minuend</param>
            <param name="ASize">The minuend size</param>
            <param name="Addend">The addend</param>
            
            <returns>A possible generated carry (0 or 1)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.InplaceAdd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Performs: Op1 += Addend. 
            <para>The number must have a place to hold a possible carry.</para>
            </summary>
            
            <param name="A">The operand</param>
            <param name="Addend">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.InplaceSubtract(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs Op1 -= Op2. 
            <para>Op1 must have enough place to store the result (i.e. Op1.BitLength() >= Op2.BitLength()).
            Both should be positive (what implies that Op1 >= Op2).</para>
            </summary>
            
            <param name="A">The input minuend, and the output result</param>
            <param name="B">The subtrahend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.Subtract(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            See BigInteger#subtract(BigInteger)
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator">
            <summary>
            An implementation of the Index Generation Function IGF-2 in IEEE P1363.1 section 8.4.2.1.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.#ctor(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters)">
            <summary>
            Constructs a new index generator
            </summary>
            
            <param name="Seed">A seed of arbitrary length to initialize the index generator</param>
            <param name="EncParam">NtruEncrypt parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.NextIndex">
            <summary>
            Returns a number
            </summary>
            
            <returns>The next pseudo-random index</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Engine">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString">
            <summary>
            Represents a string of bits and supports appending, reading the head, and reading the tail
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.AppendBits(System.Byte[])">
            <summary>
            Append bits to an array
            </summary>
            
            <param name="Data">Array to write to</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.AppendBits(System.Byte)">
            <summary>
            Appends all bits in a byte to the end of the bit string
            </summary>
            
            <param name="Value">The byte to append</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.GetTrailing(System.Int32)">
            <summary>
            Returns the last <c>NumBits</c> bits from the end of the bit string
            </summary>
            
            <param name="NumBits">Number of bits to return</param>
            
            <returns>A new <c>BitString</c> of length <c>numBits</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.Pop(System.Int32)">
            <summary>
            Returns up to 32 bits from the beginning of the bit string, and removes those bits from the bit string.
            </summary>
            
            <param name="NumBits">Number of bits to return</param>
            
            <returns>An <c>int</c> whose lower <c>NumBits</c> bits are the beginning of the bit string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.GetLeadingAsInt(System.Int32)">
            <summary>
            Returns up to 32 bits from the beginning of the bit string
            </summary>
            
            <param name="NumBits">The number of bits</param>
            
            <returns>An <c>int</c> whose lower <c>NumBits</c> bits are the beginning of the bit string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.Truncate(System.Int32)">
            <summary>
            Removes a given number of bits from the end of the bit string
            </summary>
            
            <param name="NumBits">The number of bits to remove</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.Bytes">
            <summary>
            Bit string state array
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng">
            <summary>
            <h3>DGCPrng: An implementation of a Digest Counter based Random Number Generator.</h3>
            <para>Uses a Digest Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90A</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IRandom</c> interface:</description>
            <code>
            int num;
            using (IRandom rnd = new DGCPrng([Digests])
                num = rnd.Next([Minimum], [Maximum]);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/09" version="1.4.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with any <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">digest</see>.</description></item>
            <item><description>Can use either a random seed generator for initialization, or a user supplied Seed array.</description></item>
            <item><description>Numbers generated with the same seed will produce the same random output.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-90A: <see href="http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf">Appendix E1.</see></description></item>
            <item><description>NIST SP800-90B: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">Recommendation for the Entropy Sources Used for Random Bit Generation</see>.</description></item>
            <item><description>NIST Fips 140-2: <see href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Security Requirments For Cryptographic Modules</see>.</description></item>
            <item><description>NIST SP800-22 1a: <see href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</see>.</description></item>
            <item><description>Security Bounds for the NIST Codebook-based: <see href="http://eprint.iacr.org/2006/379.pdf">Deterministic Random Bit Generator</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.#ctor(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,VTDev.Libraries.CEXEngine.Crypto.Enumeration.SeedGenerators,System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="DigestEngine">The digest that powers the rng (default is Keccak512)</param>
            <param name="SeedEngine">The Seed engine used to create the salt (default is CSPRsg)</param>
            <param name="BufferSize">The size of the internal state buffer in bytes; must be at least 128 bytes size (default is 1024)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if the buffer size is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.#ctor(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,System.Int32)">
            <summary>
            Initialize the class with a Seed; note: the same seed will produce the same random output
            </summary>
            
            <param name="Seed">The Seed bytes used to initialize the digest counter; (min. length is digest blocksize + 8)</param>
            <param name="DigestEngine">The digest that powers the rng (default is Keccak512)</param>
            <param name="BufferSize">The size of the internal state buffer in bytes; must be at least 128 bytes size (default is 1024)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if the seed is null or buffer size is too small; (min. seed = digest blocksize + 8)</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.NextLong">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB">
            <summary>
            <h3>Implements a Cipher FeedBack Mode: CFB.</h3>
            <para>CFB as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CFB(new RDX(), [BlockSizeBits], [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Parallel processing is enabled on decryption by passing a block size of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelBlockSize"/> to the transform.</description></item>
            <item><description><see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelBlockSize"/> must be divisible by <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelMinimumSize"/>.</description></item>
            <item><description>Parallel block calculation ex. <c>int blocklen = (data.Length / cipher.ParallelMinimumSize) * 10</c></description></item>
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">
            <summary>
            Cipher Mode Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key and Vector</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes within an array
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.IV">
            <summary>
            Get: The current state of the initialization Vector
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.Name">
            <summary>
            Cipher name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Int32,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="BlockSizeBits">Block size in bits; minimum is 8, or 1 byte. Maximum is Cipher block size in bits</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null Cipher or valid block size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Cipher is used. for encryption, false to decrypt</param>
            <param name="KeyParam">KeyParams containing key and vector</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null Key or IV is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Decrypt a single block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Decrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Encrypt a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Encrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.IV">
            <summary>
            Get: The current state of the initialization Vector
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, or  block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ProcessorCount">
            <remarks>
            Processor count
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">
            <summary>
            The Asymmetric key interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey.ToBytes">
            <summary>
            Converts the key pair to a byte array
            </summary>
            
            <returns>The encoded key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey.ToStream">
            <summary>
            Returns the current key pair set as a MemoryStream
            </summary>
            
            <returns>KeyPair as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey.WriteTo(System.Byte[])">
            <summary>
            Writes the key pair to an output byte array
            </summary>
            
            <param name="Output">KeyPair as a byte array; can be initialized as zero bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the key pair to an output byte array
            </summary>
            
            <param name="Output">KeyPair as a byte array; can be initialized as zero bytes</param>
            <param name="Offset">The starting position within the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the key pair to an output stream
            </summary>
            
            <param name="Output">Output Stream</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.DriveUtils">
            <summary>
            Drive methods wrapper class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DriveUtils.DriveGetSize(System.String)">
            <summary>
            Get Total Drive space
            </summary>
            
            <param name="DrivePath">Path to drive</param>
            
            <returns>Result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DriveUtils.DriveGetFreeSpace(System.String)">
            <summary>
            Get Drive Free space
            </summary>
            
            <param name="DrivePath">Path to drive</param>
            
            <returns>Result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DriveUtils.DriveGetFreeSpaceMB(System.String)">
            <summary>
            Get Drive Free space
            </summary>
            
            <param name="DrivePath">Path to drive</param>
            
            <returns>Result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DriveUtils.DriveGetPath(System.String)">
            <summary>
            Get the drive path from a directory or file path
            </summary>
            
            <param name="DirectoryPath">Path</param>
            
            <returns>Result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DriveUtils.IsDriveReady(System.String)">
            <summary>
            Drive is available
            </summary>
            
            <param name="DrivePath">Path to drive</param>
            
            <returns>Result</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators">
            <summary>
            Random Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators.CTRDrbg">
            <summary>
            An implementation of a Encryption Counter based DRBG
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators.DGCDrbg">
            <summary>
            An implementation of a Digest Counter based DRBG
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators.HKDF">
            <summary>
            A Hash based Key Derivation Function HKDF
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators.KDF2Drbg">
            <summary>
            An implementation of a Hash based Key Derivation Function PBKDF2
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators.PKCS5">
            <summary>
            An implementation of a Hash based Key Derivation PKCS#5 Version 2
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators.SP20Drbg">
            <summary>
            An implementation of a Salsa20 Counter based DRBG
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20">
            <summary>
            <h3>Salsa20+: A parallelized Salsa20 stream cipher implementation.</h3>
            <para>A Salsa20 cipher extended to use up to 30 rounds of diffusion.</para>
            </summary>
            
            <example>
            <description>Example using an <c>IStreamCipher</c> interface:</description>
            <code>
            using (IStreamCipher cipher = new Salsa20())
            {
                // initialize for encryption
                cipher.Initialize(new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/14" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            <revision date="2015/06/14" version="1.4.0.0">Added parallel processing</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 256 (16 and 32 bytes).</description></item>
            <item><description>Block size is 64 bytes wide.</description></item>
            <item><description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description></item>
            <item><description>Parallel block size is 64,000 bytes by default; but is configurable.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Salsa20 <see href="http://www.ecrypt.eu.org/stream/salsa20pf.html">Specification</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/design.pdf">Design</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/security.pdf">Security</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">
            <summary>
            Stream Cipher Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="KeyParam">Cipher key container. The LegalKeySizes property contains valid sizes</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key ot iv is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key or iv size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Transform(System.Byte[],System.Byte[])">
            <summary>
            Encrypt/Decrypt an array of bytes
            </summary>
            
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input and output arrays do not align or are too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Transform(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset and length parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Length">Length of data to process</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if input array is smaller then the ouput array</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalRounds"/> property contains available sizes. Default is 20 rounds.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="KeyParam">Cipher key container. 
            <para>Uses the Key and IV fields of KeyParam. 
            The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalKeySizes"/> property contains valid Key sizes. 
            IV must be 8 bytes in size.</para>
            </param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key or iv  is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key or iv size  is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Reset">
            <summary>
            Reset the primary internal counter
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Transform(System.Byte[],System.Byte[])">
            <summary>
            Encrypt/Decrypt an array of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Transform(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset and length parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Length">Number of bytes to process</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Counter">
            <summary>
            Get the current counter value
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, or  block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ProcessorCount">
            <remarks>
            Get: Processor count
            </remarks>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Rounds">
            <summary>
            Get: Number of rounds
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.VectorSize">
            <summary>
            Get: Initialization vector size
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX">
            <summary>
            <h3>THX: A Twofish Cipher extended with an HKDF powered Key Schedule.</h3>
            <para>THX is an implementation of the Twofish<cite>Twofish</cite> block cipher combined with an HKDF powered Key Schedule.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new THX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">VTDev.Libraries.CEXEngine.Crypto.HKDF Generator</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 18, 20, 22, 24, 26, 28, 30 and 32, default is 16.</description></item>
            </list>
            
            <para>The number of transformation rounds processed is also user definable; from the standard 16 rounds, to a full 32 rounds of transformation.</para>
            
            <para>The key schedule in THX powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even the Twofish key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            THX is capable of processing up to 32 rounds, that is twice the number of rounds used in a standard implementation of Twofish. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">Fips 198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalRounds"/> property contains available sizes. Default is 16 rounds.</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.RoundingModes">
            <summary>
            MathContext RoundingModes used by BigInteger and BigDecimal
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Up">
            <summary>
            Rounding mode where positive values are rounded towards positive infinity
            and negative values towards negative infinity.
            <para>Rule: <c>x.Round().Abs() >= x.Abs()</c></para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Down">
            <summary>
            Rounding mode where the values are rounded towards zero.
            <para>Rule: x.Round().Abs() &lt;= x.Abs()</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Ceiling">
            <summary>
            Rounding mode to round towards positive infinity.
            <para>For positive values this rounding mode behaves as Up, for negative values as Down.
            Rule: x.Round() >= x</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Floor">
            <summary>
            Rounding mode to round towards negative infinity.
            <para>For positive values this rounding mode behaves as Down, for negative values as Up.
            Rule: x.Round() &lt;= x</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.HalfUp">
            <summary>
            Rounding mode where values are rounded towards the nearest neighbor.
            <para>Ties are broken by rounding up.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.HalfDown">
            <summary>
            Rounding mode where values are rounded towards the nearest neighbor.
            <para>Ties are broken by rounding down.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.HalfEven">
            <summary>
            Rounding mode where values are rounded towards the nearest neighbor.
            <para>Ties are broken by rounding to the even neighbor.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Unnecessary">
            <summary>
            Rounding mode where the rounding operations throws an ArithmeticException for 
            the case that rounding is necessary, i.e. for the case that the value cannot be represented exactly.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BigEndian">
            <summary>
            This is a utility class containing data type conversions using big-endian byte order
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.IntToOctets(System.Int32)">
            <summary>
            Convert an integer to an octet string of length 4 according to IEEE 1363, Section 5.5.3
            </summary>
            <param name="Input">The integer to convert</param>
            
            <returns>The converted integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.IntToOctets(System.Int32,System.Int32)">
            <summary>
            Convert an integer to an octet string according to IEEE 1363, Section 5.5.3. Length checking is performed
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Length">The desired length of the octet string</param>
            
            <returns>Returns an octet string of length <c>OctLength</c> representing the integer <c>X</c>, or <c>null</c> if the integer is negative</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.IntToOctets(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Convert an integer to an octet string of length 4 according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array holding the output</param>
            <param name="OutOffset">The starting offset in the output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.LongToOctets(System.Int64)">
            <summary>
            Convert an integer to an octet string of length 8 according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">he integer to convert</param>
            
            <returns>The converted long integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.IntToOctets(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert an integer to an octet string of the specified length according to IEEE 1363, Section 5.5.3.
            <para>No length checking is performed (i.e., if the integer cannot be encoded into <c>length</c> octets, it is truncated).</para>
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array holding the output</param>
            <param name="OutOffset">The starting offset in the output array</param>
            <param name="Length">The length of the encoding</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.LongToOctets(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Convert an integer to an octet string of length 8 according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array holding the output</param>
            <param name="OutOffset">The starting offset in the output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.OctetsToInt(System.Byte[])">
            <summary>
            Convert an octet string to an integer according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">he byte array holding the octet string</param>
            
            <returns>Returns an integer representing the octet string <c>Input</c>, or <c>0</c> if the represented integer is negative or too large or the byte array is empty</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.OctetsToInt(System.Byte[],System.Int32)">
            <summary>
            Convert a byte array of length 4 beginning at <c>offset</c> into an integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="InOffset">The offset into the byte array</param>
            <returns>The resulting integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.OctetsToInt(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert an octet string to an integer according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">The byte array holding the octet string</param>
            <param name="InOffset">The offset in the input byte array where the octet string starts</param>
            <param name="Length">The length of the encoded integer</param>
            
            <returns>Returns an integer representing the octet string <c>bytes</c>, or <c>0</c> if the represented integer is negative or too large or the byte array is empty</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.OctetsToLong(System.Byte[],System.Int32)">
            <summary>
            Convert a byte array of length 8 beginning at <c>inOff</c> into a long integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="InOffset">The offset into the byte array</param>
            
            <returns>The resulting long integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.ToByteArray(System.Int32[])">
            <summary>
            Convert an int array into a byte array
            </summary>
            
            <param name="Input">The int array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.ToByteArray(System.Int32[],System.Int32)">
            <summary>
            Convert an int array into a byte array of the specified length.
            <para>No length checking is performed (i.e., if the last integer cannot be encoded into <c>length % 4</c> octets, it is truncated).</para>
            </summary>
            
            <param name="Input">The int array</param>
            <param name="Length">The length of the converted array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.ToIntArray(System.Byte[])">
            <summary>
            Convert a byte array into an int array
            </summary>
            
            <param name="Input">The byte array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2">
            <summary>
            A polynomial class that combines two coefficients into one <c>long</c> value for
            faster multiplication in 64 bit environments.
            <para>Coefficients can be between 0 and 2047 and are stored in pairs in the bits 0..10 and 24..34 of a <c>long</c> number.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.Coeffs">
            <summary>
            Each representing two coefficients in the original IntegerPolynomial
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Constructs a <c>LongPolynomial2</c> from a <c>IntegerPolynomial</c>. The two polynomials are independent of each other.
            </summary>
            <param name="P">The original polynomial. Coefficients must be between 0 and 2047.</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.Clear">
            <summary>
            Clear the Coefficients
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.Clone">
            <summary>
            Makes a copy of the polynomial that is independent of the original.
            </summary>
            <returns>The cloned polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2)">
            <summary>
            Multiplies the polynomial with another, taking the indices mod N and the values mod 2048.
            </summary>
            
            <param name="Factor">The polynomial factor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.Mult2And(System.Int32)">
            <summary>
            Multiplies this polynomial by 2 and applies an AND mask to the upper and 
            lower halves of each coefficients.
            </summary>
            
            <param name="Mask">A bit mask less than 2048 to apply to each 11-bit coefficient</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.SubAnd(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2,System.Int32)">
            <summary>
            Subtracts another polynomial which must have the same number of coefficients,
            and applies an AND mask to the upper and lower halves of each coefficients.
            </summary>
            
            <param name="B">Another polynomial</param>
            <param name="Mask">A bit mask less than 2048 to apply to each 11-bit coefficient</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.ToIntegerPolynomial">
            <summary>
            Returns a polynomial that is equal to this polynomial (in the sense that mult(IntegerPolynomial, int) 
            returns equal <c>IntegerPolynomial</c>s). The new polynomial is guaranteed to be independent of the original.
            </summary>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.Equals(System.Object)">
            <summary>
            Compare this big integer polynomial to another for equality
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg">
            <summary>
            <h3>An implementation of a Cryptographically Secure seed generator using the RNGCryptoServiceProvider class.</h3>
            <para>Implements a random byte generator using the RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class</para>
            </summary>
            
            <example>
            <code>
            byte seed;
            using (ISeed rnd = new CSPRng())
                seed = rnd.GetSeed(48);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/09" version="1.4.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4>:</description>
            <list type="number">
            <item><description>RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class documentation.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Seed.ISeed">
            <summary>
            The Seed Generator interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.ISeed.GetSeed(System.Int32)">
            <summary>
            Get a pseudo random seed byte array
            </summary>
            
            <param name="Size">The size of the seed returned; up to a maximum of 1024 bytes</param>
            
            <returns>A pseudo random seed</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Seed.ISeed.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.#ctor">
            <summary>
            Initialize the class
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if RNGCryptoServiceProvider initialization failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.GetSeed(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512">
            <summary>
            <h3>Keccak512: An implementation of the SHA-3 Keccak digest.</h3>
            <para>SHA-3 competition winner<cite>SHA-3 Standardization</cite>: The Keccak<cite>Keccak</cite> digest</para>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Keccak512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/01/23" version="1.3.5.0">Rewritten for improvements to security and speed</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Hash sizes are 48 and 64 bytes (384 and 512 bits).</description></item>
            <item><description>Block sizes are 104, and 72 bytes (832, 576 bits).</description></item>
            <item><description>Use the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.BlockSize"/> property to determine block sizes at runtime.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 <see href="http://keccak.noekeon.org/Keccak-submission-3.pdf">Keccak Submission</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent HashLib project implementation <see href="http://hashlib.codeplex.com/">Keccak.cs</see> class, 
            and the <see href="https://github.com/gvanas/KeccakCodePackage">Keccak Code Package</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">
            <summary>
            Hash Digest Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.#ctor(System.Int32)">
            <summary>
            Initialize the digest
            </summary>
            
            <param name="DigestSize">Digest return size in bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA3 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SeedGenerators">
            <summary>
            Seed Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SeedGenerators.CSPRsg">
            <summary>
            A Secure Seed Generator using RNGCryptoServiceProvider
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SeedGenerators.XSPRsg">
            <summary>
            A Secure Seed Generator using an Xor+ generator
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX">
            <summary>
            <h3>SHX: A Serpent cipher extended with an HKDF powered Key Schedule.</h3>
            <para>SHX is a Serpent<cite>Serpent</cite> implementation that uses an HKDF generator to expand the user supplied key into a working key integer array.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new SHX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">VTDev.Libraries.CEXEngine.Crypto.HKDF Generator</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 32, 40, 48, 56, 64, 80, 96 and 128, default is 64.</description></item>
            </list>
            
            <para>It also takes a user defined number of rounds between 32 (the standard number of rounds), all the way up to 128 rounds in 8 round sets. 
            A round count of 40 or 48 is more than sufficient, as theoretical attacks to date are only able to break up to 12 rounds; and would require an enormous amount of memory and processing power.
            The transform in SHX is identical to the Serpent implementation SPX, it process rounds by first moving the byte input array into 4 integers, then processing the rounds in a while loop. 
            Each round consists of an XOR of each state word (<math>Rn</math>) with a key, an S-Box transformation of those words, and then a linear transformation. 
            Each of the 8 S-Boxes are used in succession within a loop cycle. The final round XORs the last 4 keys with the state and shifts them back into the output byte array.</para>
            
            <para>The key schedule in SHX powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            SHX is capable of processing up to 128 rounds, that is four times the number of rounds used in a standard implementation of Serpent. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalRounds"/> property contains available sizes. Default is 32 rounds.</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container.<para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib0(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvSO - {13, 3,11, 0,10, 6, 5,12, 1,14, 4, 7,15, 9, 8, 2 } - 15 terms.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb1(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S1 - {15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 } - 14 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib1(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS1 - { 5, 8, 2,14,15, 6,12, 3,11, 4, 7, 9, 1,13,10, 0 } - 14 steps
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb2(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S2 - { 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib2(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS2 - {12, 9,15, 4,11,14, 1, 2, 0, 3, 6,13, 5, 8,10, 7 } - 16 steps
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb3(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S3 - { 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib3(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS3 - { 0, 9,10, 7,11,14, 6,13, 3, 5,12, 2, 4, 8,15, 1 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb4(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S4 - { 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib4(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS4 - { 5, 0, 8, 3,10, 9, 7,14, 2,12,11, 6, 4,15,13, 1 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb5(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S5 - {15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib5(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS5 - { 8,15, 2, 9, 4, 1,13,14,11, 6, 5, 3, 7,12,10, 0 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb6(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S6 - { 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib6(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS6 - {15,10, 1,13, 5, 3, 6, 0, 4, 9,14, 7, 2,12, 8,11 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb7(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S7 - { 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib7(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS7 - { 3, 0, 6,13, 9,14,15, 8, 5,12,11, 7,10, 1, 4, 2 } - 17 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LinearTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.InverseTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the inverse of the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.FileUtils">
            <summary>
            File methods wrapper class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtils.FileJoinPaths(System.String,System.String)">
            <summary>
            Safely create a full path
            </summary>
            
            <param name="DirectoryPath">Directory path</param>
            <param name="FileName">File name</param>
            
            <returns>Full path to file</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtils.FileHasPermission(System.String,System.Security.AccessControl.FileSystemRights)">
            <summary>
            Test a file for create file access permissions
            </summary>
            
            <param name="FilePath">Full path to file</param>
            <param name="AccessRight">File System right tested</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtils.FileGetSize(System.String)">
            <summary>
            Get the size of  file
            </summary>
            
            <param name="FilePath">Full path to file</param>
            
            <returns>File length</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtils.FileGetUniqueName(System.String)">
            <summary>
            Adds an extension to a file unique to the directory
            </summary>
            
            <param name="FullPath">Full file path</param>
            
            <returns>Unique filename in original path</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtils.FileIsReadable(System.String)">
            <summary>
            File is readable
            </summary>
            
            <param name="FilePath">Full path to file</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtils.FileIsReadOnly(System.String)">
            <summary>
            Test a file to see if it is readonly
            </summary>
            
            <param name="FilePath">Full path to file</param>
            
            <returns>Read only</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtils.IsValidFileName(System.String)">
            <summary>
            Test if file name is valid [has extension]
            </summary>
            
            <param name="FileName">File name</param>
            
            <returns>Valid</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtils.IsValidFilePath(System.String)">
            <summary>
            Test path to see if directory exists and file name has proper format
            </summary>
            
            <param name="FilePath">Full path to file</param>
            
            <returns>Valid</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtils.FormatBytes(System.Int64)">
            <summary>
            Format bytes into larger sizes
            </summary>
            
            <param name="bytes">Length in bytes</param>
            
            <returns>Size string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtils.GetLocalProfile">
            <summary>
            Get the local profile path
            </summary>
            
            <returns>Profile path</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.ByteUtils">
            <summary>
            This class is a utility class for manipulating byte arrays
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Clone(System.Byte[])">
            <summary>
            Return a clone of the given byte array (performs null check beforehand).
            </summary>
            
            <param name="A">The array to clone</param>
            
            <returns>Returns the clone of the given array, or <c>null</c> if the array is <c>null</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Concatenate(System.Byte[][])">
            <summary>
            Convert a 2-dimensional byte array into a 1-dimensional byte array by concatenating all entries
            </summary>
            
            <param name="A">A 2-dimensional byte array</param>
            
            <returns>Returns the concatenated input array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Concatenate(System.Byte[],System.Byte[])">
            <summary>
            Concatenate two byte arrays. No null checks are performed
            </summary>
            
            <param name="A">The first array</param>
            <param name="B">The second array</param>
            
            <returns>Returns (x2||x1) (little-endian order, i.e. x1 is at lower memory addresses)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.DeepHashCode(System.Byte[])">
            <summary>
            Computes a hashcode based on the contents of a one-dimensional byte array rather than its identity
            </summary>
            
            <param name="A">The array to compute the hashcode of</param>
            
            <returns>The hashcode</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.DeepHashCode(System.Byte[][])">
            <summary>
            Computes a hashcode based on the contents of a two-dimensional byte array rather than its identity
            </summary>
            
            <param name="A">The array to compute the hashcode of</param>
            
            <returns>The hashcode</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.DeepHashCode(System.Byte[][][])">
            <summary>
            Computes a hashcode based on the contents of a three-dimensional byte array rather than its identity
            </summary>
            
            <param name="A">The array to compute the hashcode of</param>
            
            <returns>The hashcode</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Equals(System.Byte[],System.Byte[])">
            <summary>
            Compare two byte arrays (perform null checks beforehand).
            </summary>
            
            <param name="A">The first byte array</param>
            <param name="B">The second byte array</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Equals(System.Byte[][],System.Byte[][])">
            <summary>
            Compare two two-dimensional byte arrays; No null checks are performed.
            </summary>
            
            <param name="A">The first byte array</param>
            <param name="B">The second byte array</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Equals(System.Byte[][][],System.Byte[][][])">
            <summary>
            Compare two three-dimensional byte arrays; No null checks are performed.
            </summary>
            
            <param name="A">The first byte array</param>
            <param name="B">The second byte array</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.FromHexString(System.String)">
            <summary>
            Convert a string containing hexadecimal characters to a byte-array
            </summary>
            
            <param name="S">A hex string</param>
            
            <returns>Returns a byte array with the corresponding value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Split(System.Byte[],System.Int32)">
            <summary>
            Split a byte array <c>Input</c> into two arrays at <c>Index</c>.
            <para>The first array will have the lower <c>Index</c> bytes, the second one the higher <c>Input.Length - index</c> bytes.</para>
            </summary>
            
            <param name="Input">The byte array to be split</param>
            <param name="Index">The index where the byte array is split</param>
            
            <returns>Returns the split input array as an array of two byte arrays</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.SubArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate a subarray of a given byte array
            </summary>
            
            <param name="Input">The input byte array</param>
            <param name="Start">The start index</param>
            <param name="End">The end index</param>
            
            <returns>Returns a subarray of <c>Input</c>, ranging from <c>Start</c> (inclusively) to <c>End</c> (exclusively)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.SubArray(System.Byte[],System.Int32)">
            <summary>
            Generate a subarray of a given byte array
            </summary>
            
            <param name="Input">The input byte array</param>
            <param name="Start">The start index</param>
            
            <returns>Returns a subarray of <c>Input</c>, ranging from <c>Start</c> to the end of the array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.ToBinaryString(System.Byte[])">
            <summary>
            Convert a byte array to the corresponding bit string
            </summary>
            
            <param name="Input">The byte array to be converted</param>
            
            <returns>The corresponding bit string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.ToCharArray(System.Byte[])">
            <summary>
            Rewrite a byte array as a char array
            </summary>
            
            <param name="Input">The byte array to convert</param>
            
            <returns>Returns the bytes represented as a char array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.ToHexString(System.Byte[])">
            <summary>
            Convert a byte array to the corresponding hexstring
            </summary>
            
            <param name="Input">The byte array to be converted</param>
            
            <returns>Returns the corresponding hexstring</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.ToHexString(System.Byte[],System.String,System.String)">
            <summary>
            Convert a byte array to the corresponding hex string
            </summary>
            
            <param name="Input">The byte array to be converted</param>
            <param name="Prefix">The prefix to put at the beginning of the hex string</param>
            <param name="Seperator">A separator string</param>
            
            <returns>The corresponding hex string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Xor(System.Byte[],System.Byte[])">
            <summary>
            Compute the bitwise XOR of two arrays of bytes.
            <para>The arrays have to be of same length. No length checking is performed.</para>
            </summary>
            
            <param name="A">The first array</param>
            <param name="B">The second array</param>
            
            <returns>Returns <c>A^B</c></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.ArrayEx">
            <summary>
            Array type extensions
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.AddAt``1(System.Int32[],System.Int32,``0)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">The source array to be expanded</param>
            <param name="Index">The insertion point within the source array</param>
            <param name="Value">The new value</param>
            
            <returns>Resized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.AddRange``1(``0[],``0[],System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">The source array to be expanded</param>
            <param name="Data">The new value members</param>
            <param name="Index">The insertion point within the source array</param>
            
            <returns>Resized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Deserialize``1(System.Byte[])">
            <summary>
            Convert a byte array to a class objct
            </summary>
            
            <typeparam name="T">Return object type</typeparam>
            <param name="Data">The byte array containing the class</param>
            
            <returns>The class object</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.CopyOf``1(``0[],System.Int32)">
            <summary>
            Create a copy of an array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">Array source</param>
            <param name="Length">Number of elements to copy</param>
            
            <returns>A copy of the source array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.CopyOfRange``1(``0[],System.Int32,System.Int32)">
            <summary>
            Create a ranged copy of a byte array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">Byte source array</param>
            <param name="From">First element to copy</param>
            <param name="To">Last element to copy</param>
            
            <returns>Byte array copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Fill``1(``0[],``0)">
            <summary>
            Fill an array with a value; defaults to zeroes
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">Array to fill</param>
            <param name="Value">Value used to fill array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Fill``1(``0[0:,0:],``0)">
            <summary>
            Fill an array with a value; defaults to zeroes
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">Array to fill</param>
            <param name="Value">Value used to fill array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.RemoveAt``1(``0[],System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <typeparam name="T">The type of array</typeparam>
            <param name="Source">The source array</param>
            <param name="Index">The index of the element to remove</param>
            
            <returns>Resized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.RemoveRange``1(``0[],System.Int32,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="From">First element to remove</param>
            <param name="To">Last element to remove</param>
            
            /// <returns>Resized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Serialize(System.Object)">
            <summary>
            Serialize an object to a byte array
            </summary>
            
            <param name="Obj">The object to serialize</param>
            
            <returns>The object as a serialized byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Shuffle``1(``0[])">
            <summary>
            Shuffle an array using the SecureRandom class
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">The list instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Shuffle``1(``0[],VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Shuffle an array with a specific Prng class
            </summary>
            
            <typeparam name="T">Type of list</typeparam>
            <param name="Source">The list instance</param>
            <param name="Rng">The pseudo random generator</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.SubArray``1(``0[],System.Int32,System.Int32)">
            <summary>
            Return a sub array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">The source array</param>
            <param name="Index">The starting position within the source array</param>
            <param name="Count">The number of bytes to copy</param>
            
            <returns>The sub array</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX">
            <summary>
            <h3>RHX: A Rijndael Cipher extended with an HKDF powered Key Schedule.</h3>
            <para>RHX is a Rijndael<cite>Rijndael</cite> implementation that uses an HKDF generator to expand the user supplied key into a working key integer array.</para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RHX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">VTDev.Libraries.CEXEngine.Crypto.HKDF Generator</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <para>The key schedule in RHX is the defining difference between this and a standard version of Rijndael<cite>Rijndael</cite>; 
            instead of using a simple inline function to expand the user supplied key into a larger working array, it uses a hash based pseudo-random generator to create the working key.</para>
            
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block sizes are 16 and 32 byte wide.</description></item>
            <item><description>Valid Rounds are 10 to 38, default is 22.</description></item>
            </list>
            
            <para>HKDF<cite>RFC 5869</cite> is a key derivation function that uses a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. 
            HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RHX is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in post-quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            RHX is capable of processing up to 38 rounds, that is twenty-four rounds more than the fourteen rounds used in an implementation of AES-256. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class, 
            and the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalRounds"/> property contains available sizes.  Default is 22 rounds.</param>
            <param name="BlockSize">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalBlockSizes"/> property contains available sizes. Default is 16 bytes.</param>
            <param name="KeyEngine"><para>The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> 
            implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/></para>.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid block size or invalid rounds count are used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and initialize state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">
            <summary>
            Asymmetric key pair interface
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair.Name">
            <summary>
            Get: The key pair name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair.PublicKey">
            <summary>
            The Public key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair.PrivateKey">
            <summary>
            The Private Key
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Multiplication">
            <summary>
            Static library that provides all multiplication of BigInteger methods
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.Multiplication.bigTenPows">
            <summary>
            An array with the first powers of ten in BigInteger version: 10^0,10^1,...,10^31)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.Multiplication.bigFivePows">
            <summary>
            An array with the first powers of five in {@code BigInteger} version: (5^0,5^1,...,5^31)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs a multiplication of two BigInteger and hides the algorithm used
            </summary>
            
            <param name="X">The number to be multiplied</param>
            <param name="Y">A positive exponent</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyArraysPAP(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32[])">
            <summary>
            Multiply a member of array X with array Y
            </summary>
            
            <param name="X">The number to be multiplied</param>
            <param name="XLength">Length of X array to process</param>
            <param name="Y">A positive exponent</param>
            <param name="YLength">Length of Y array to process</param>
            <param name="ResDigits">The result</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyByInt(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Multiplies an array of integers by an integer value
            </summary>
            
            <param name="X">The array of integers</param>
            <param name="Size">The number of elements of intArray to be multiplied</param>
            <param name="Factor">The multiplier</param>
            
            <returns>The top digit of production</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyByFivePow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Multiplies a number by a power of five.
            <para>This method is used in BigDecimal class.</para>
            </summary>
            
            <param name="X">The number to be multiplied</param>
            <param name="Exponent">A positive int exponent</param>
            
            <returns>X * 5 pow Exponent</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyByPositiveInt(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Multiplies a number by a positive integer.
            </summary>
            
            <param name="X">An arbitrary BigInteger</param>
            <param name="Factor">A positive int number</param>
            
            <returns>X * Factor</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyByTenPow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int64)">
            <summary>
            Multiplies a number by a power of ten.
            <para>This method is used in BigDecimal class.</para>
            </summary>
            
            <param name="X">The number to be multiplied</param>
            <param name="Exponent">A positive long exponent</param>
            
            <returns>X * 10 pow Exponent</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.Pow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this ^ Exponent</c>
            </summary>
            
            <param name="X">The BigInteger</param>
            <param name="Exponent">Exponent to which this is raised</param>
            
            <returns>Returns <c>this ^ Exponent</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.PowerOf10(System.Int64)">
            <summary>
            It calculates a power of ten, which exponent could be out of 32-bit range.
            <para>Note that internally this method will be used in the worst case with
            an exponent equals to: Integer.Max - Integer.Min.</para>
            </summary>
            
            <param name="Exponent">The exponent of power of ten, it must be positive</param>
            
            <returns>BigInteger with value 10<sup>exp</sup>.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.UnsignedMultAddAdd(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes the value unsigned ((uint)a*(uint)b + (uint)c + (uint)d).
            <para>This method could improve the readability and performance of the code.</para>
            </summary>
            
            <param name="A">Operand 1</param>
            <param name="B">Operand 2</param>
            <param name="C">Operand 3</param>
            <param name="D">Operand 4</param>
            <returns></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Conversion">
            <summary>
            Static library that provides BigInteger base conversion from/to any integer represented in an String Object
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Conversion.BigInteger2Double(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns this BigInteger as an double value.
            <para>If this is too big to be represented as an double, then Double.POSITIVE_INFINITY or 
            Double.NEGATIVE_INFINITY} is returned.</para>
            </summary>
            
            <param name="Value">The value to convert</param>
            
            <returns>Returns a BigInteger as a double value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Double.MAX_VALUE, Double.MAX_VALUE] can be represented as a double. 
            The double representation has a mantissa of length 53. For example, 2^53+1 = 9007199254740993 is returned as double 9007199254740992.0.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Conversion.BigInteger2String(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a string containing a string representation of this  BigInteger with base radix.
            <para>If Radix &lt; CharHelper.MIN_RADIX} or Radix > CharHelper.MAX_RADIX then a decimal representation is returned.
            The CharHelpers of the string representation are generated with method CharHelper.forDigit.</para>
            </summary>
            
            <param name="Value">The value to convert</param>
            <param name="Radix">Base to be used for the string representation</param>
            
            <returns>Returns a string representation of this with radix 10</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Conversion.ToDecimalScaledString(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a string representation of this BigInteger in decimal form
            </summary>
            
            <param name="Value">The value to convert</param>
            <param name="Scale">The scale</param>
            
            <returns>Returns a string representation of this in decimal form</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Conversion.ToDecimalScaledString(System.Int64,System.Int32)">
            <summary>
            Returns a string representation of this BigInteger in decimal form
            </summary>
            
            <param name="Value">The value to convert</param>
            <param name="Scale">The scale</param>
            
            <returns>Returns a string representation of this in decimal form</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.BigIntEuclidean">
            <summary>
            Extended Euclidean Algorithm in BigIntegers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.BigIntEuclidean.X">
            <summary>
            Coefficient X
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.BigIntEuclidean.Y">
            <summary>
            Coefficient Y
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.BigIntEuclidean.GCD">
            <summary>
            Greatest Common Divisor
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.BigIntEuclidean.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.BigIntEuclidean.Calculate(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Runs the EEA on two BigIntegers
            </summary>
            <param name="A">Quotient A</param>
            <param name="B">Quotient B</param>
            <returns>Return a BigIntEuclidean object that contains the result in the variables X, Y, and GCD</returns>
            
            <remarks>
            Implemented from pseudocode on <a href="http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm"/>Wikipedia
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG">
            <summary>
            <h3>An implementation of the Cubic Congruential Generator II random number generator: CCG</h3>
            <para>Implements CCG as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.4</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new CCG())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">CubicResiduePrng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be initialized.
            </summary>
            
            <param name="P">Random Prime with probability &lt; 2 ** -100</param>
            <param name="G">Random Generator State</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes">
            <summary>
            <para>Key Sizes in bits. Can be cast as Key byte size integers, 
            i.e. (int sz = KeySizes.K256) is equal to 32.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K128">
            <summary>
            128 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K192">
            <summary>
            192 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K256">
            <summary>
            256 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K384">
            <summary>
            384 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K448">
            <summary>
            448 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K512">
            <summary>
            512 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K768">
            <summary>
            768 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K1024">
            <summary>
            1024 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K1088">
            <summary>
            1088 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K1280">
            <summary>
            1280 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K1536">
            <summary>
            1536 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K1664">
            <summary>
            1664 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K1792">
            <summary>
            1792 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K2048">
            <summary>
            2048 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K2240">
            <summary>
            2240 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K2304">
            <summary>
            2304 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K2560">
            <summary>
            2560 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K2816">
            <summary>
            2816 bit Key 
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K3072">
            <summary>
            3072 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K3584">
            <summary>
            3584 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K4096">
            <summary>
            4096 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K4608">
            <summary>
            4608 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K5120">
            <summary>
            5120 bit Key
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes">
            <summary>
            <para>IV Sizes in bits. Can be cast as IV byte size integers, 
            i.e. (int sz = IVSizes.V128) is equal to 16.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes.V64">
            <summary>
            64 bit IV
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes.V128">
            <summary>
            128 bit IV
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes.V256">
            <summary>
            256 bit IV
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">
            <summary>
            Message Digests
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Blake256">
            <summary>
            The Blake digest with a 256 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Blake512">
            <summary>
            The Blake digest with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Keccak256">
            <summary>
            The SHA-3 digest based on Keccak with a 256 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Keccak512">
            <summary>
            The SHA-3 digest based on Keccak with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Keccak1024">
            <summary>
            The SHA-3 digest based on Keccak with a 1024 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.SHA256">
             <summary>
            The SHA-2 digest with a 256 bit return size
             </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.SHA512">
            <summary>
            The SHA-2 digest with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Skein256">
            <summary>
            The Skein digest with a 256 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Skein512">
            <summary>
            The Skein digest with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Skein1024">
            <summary>
            The Skein digest with a 1024 bit return size
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.SystemUtils">
            <summary>
            System utilities class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.SystemUtils.Is64Bit">
            <summary>
            Test for 64 bit architecture
            </summary>
            
            <returns>True if 64 bit architecture</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.SystemUtils.IsMultiProcessor">
            <summary>
            Test for multi processor system
            </summary>
            
            <returns>True if processor count i more than 1</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Primality">
            <summary>
            Provides primality probabilistic methods
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Primality.NextProbablePrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            It uses the sieve of Eratosthenes to discard several composite numbers in 
            some appropriate range (at the moment [this, this + 1024]).
            <para>After this process it applies the Miller-Rabin test to the numbers that were not discarded in the sieve.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Primality.ConsBigInteger(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            A random number is generated until a probable prime number is found
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Primality.IsProbablePrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Tests whether this BigInteger is probably prime.
            <para>If true is returned, then this is prime with a probability beyond <c>(1-1/2^certainty)</c>.
            If false is returned, then this is definitely composite.
            If the argument Certainty &lt;= 0, then this method returns true.</para>
            </summary>
            
            <param name="X">BigInteger to test</param>
            <param name="Certainty">Tolerated primality uncertainty</param>
            
            <returns>Returns true, if this is probably prime, false  otherwise</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger">
            <summary>
            <h3>This class represents immutable integer numbers of arbitrary length</h3>
            
            <description>Immutable arbitrary-precision integers.</description>
            <para>All operations behave as if BigIntegers were represented in two's-complement notation.  
            BigInteger provides operations for modular arithmetic, GCD calculation, primality testing, prime generation, bit manipulation, and a few other miscellaneous operations.</para>
            </summary>
            
            <example>
            <description>Creating a random prime example:</description>
            <code>
            BigInteger p = BigInteger.ProbablePrime(BitLength, new SecureRandom());
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.2.0">Updated and expanded the implementation</revision>
            </revisionHistory>
            
            <remarks>
            <para>Semantics of arithmetic operations exactly mimic those of Java's integer arithmetic operators, as defined in The Java Language Specification.
            For example, division by zero throws an ArithmeticException, and division of a negative by a positive yields a negative (or zero) remainder.
            All of the details in the Spec concerning overflow are ignored, as BigIntegers are made as large as necessary to accommodate the results of an operation.</para>
            
            <para>Semantics of shift operations allow for negative shift distances.  
            A right-shift with a negative shift distance results in a left shift, and vice-versa.</para>
            
            <para>The binary operators (<c>And</c>, <c>Or</c>, <c>Xor</c>) implicitly perform sign extension on the shorter of the two operands prior to performing the operation.</para>
            
            <para>Modular arithmetic operations are provided to compute residues, perform exponentiation, and compute multiplicative inverses.  
            These methods always return a non-negative result, between <c>0</c> and <c>(Modulus - 1)</c>, inclusive.</para>
            
            <para>Bit operations operate on a single bit of the two's-complement representation of their operand.  
            If necessary, the operand is sign-extended so that it contains the designated bit.  
            None of the single-bit operations can produce a BigInteger with a different sign from the BigInteger being operated on, as they affect only a single bit, 
            and the "infinite word size" abstraction provided by this class ensures that there are infinitely many "virtual sign bits" preceding each BigInteger.</para>
            <para>Large numbers are typically used in security applications and therefore BigIntegers offer dedicated functionality like the generation of large 
            prime numbers or the computation of modular inverse.</para>
            <para>Since the class was modeled to offer all the functionality as the Integer class does, it provides even methods that operate bitwise 
            on a two's complement representation of large integers. 
            Note however that the implementations favors an internal representation where magnitude and sign are treated separately. 
            Hence such operations are inefficient and should be discouraged. 
            In simple words: Do NOT implement any bit fields based on BigInteger.</para>
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Zero">
            <summary>
            The BigInteger constant 0
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigInteger.One">
            <summary>
            The BigInteger constant 1
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Ten">
            <summary>
            The BigInteger constant 10
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Byte[])">
            <summary>
            Constructs a new BigInteger from the given two's complement representation.
            <para>The most significant byte is the entry at index 0.
            The most significant bit of this entry determines the sign of the new BigInteger instance.
            The given array must not be empty.</para>
            </summary>
            
            <param name="Value">Two's complement representation of the new BigInteger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Byte[])">
            <summary>
            Constructs a new BigInteger instance with the given sign and the given magnitude.
            <para>The sign is given as an integer (-1 for negative, 0 for zero, 1 for positive).
            The magnitude is specified as a byte array. The most significant byte is the entry at index 0.</para>
            </summary>
            
            <param name="Signum">Sign of the new BigInteger (-1 for negative, 0 for zero, 1 for positive)</param>
            <param name="Magnitude">Magnitude of the new BigInteger with the most significant byte first</param>
            
            <exception cref="T:System.FormatException">Thrown if an invalid Signum or Magnitude is passed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            Constructs a random non-negative BigInteger instance in the range [0, 2^(numBits)-1]
            </summary>
            
            <param name="NumBits">Maximum length of the new BigInteger in bits</param>
            <param name="Rnd">An optional random generator to be used</param>
            
            <exception cref="T:System.ArgumentException">Thrown  if NumBits &gt; 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            Constructs a random BigInteger instance in the range [0, 2^(bitLength)-1] which is probably prime. 
            <para>The probability that the returned BigInteger is prime is beyond (1-1/2^certainty).</para>
            </summary>
            
            <param name="BitLength">Length of the new BigInteger in bits</param>
            <param name="Certainty">Tolerated primality uncertainty</param>
            <param name="Rnd">An optional random generator to be used</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.String)">
            <summary>
            Constructs a new BigInteger instance from the string representation. 
            <para>The string representation consists of an optional minus sign 
            followed by a non-empty sequence of decimal digits.</para>
            </summary>
            
            <param name="Value">String representation of the new BigInteger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a new BigInteger instance from the string representation.
            <para>The string representation consists of an optional minus sign 
            followed by a non-empty sequence of digits in the specified radix.
            For the conversion the method CharHelper.Digit(char, radix) is used.</para>
            </summary>
            
            <param name="Value">String representation of the new BigInteger</param>
            <param name="Radix">The base to be used for the conversion</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int32[])">
            <summary>
            Creates a new BigInteger with the given sign and magnitude.
            <para>This constructor does not create a copy, so any changes to the reference will affect the new number.</para>
            </summary>
            
            <param name="Signum">The sign of the number represented by digits</param>
            <param name="Digits">The magnitude of the number</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a number which array is of size 1
            </summary>
            
            <param name="Sign">The sign of the number</param>
            <param name="Value">The only one digit of array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int64)">
            <summary>
            Creates a new BigInteger whose value is equal to the specified long
            </summary>
            
            <param name="Sign">The sign of the number</param>
            <param name="Value">The value of the new BigInteger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Constructs a number without to create new space.
            <para>This construct should be used only if the three fields of representation are known.</para>
            </summary>
            
            <param name="Sign">The sign of the number</param>
            <param name="NumberLength">The length of the internal array</param>
            <param name="Digits">A reference of some array created before</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Abs">
            <summary>
            Returns a (new) BigInteger whose value is the absolute value of this
            </summary>
            
            <returns><c>Abs(this)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Add(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this + val</c>
            </summary>
            
            <param name="Augend">Value to be added to this</param>
            
            <returns><c>this + val</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.And(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the bit per bit operator between this number and the given one
            </summary>
            
            <param name="Value">The value to be and'ed with the current.</param>
            
            <returns>
            Returns a new BigInteger whose value is <c>this &amp; Value</c>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.AndNot(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this &amp; ~Value</c>.
            <para>Evaluating <c>x.AndNot(Value)</c> returns the same result as <c>x.And(Value.Not())</c>.</para>
            </summary>
            
            <param name="Value">Value to be not'ed and then and'ed with this</param>
            
            <returns><c>this &amp; ~Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ClearBit(System.Int32)">
            <summary>
            Returns a new BigInteger which has the same binary representation as this but with the bit at position N cleared.
            <para>The result is equivalent to this <c>&amp; ~(2^n)</c>.
            </para>
            </summary>
            
            <param name="N">Position where the bit in this has to be cleared</param>
            
            <returns><c>this &amp; ~(2^n)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.CompareTo(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Compares this BigInteger with Value.
            <para>Returns one of the three values 1, 0, or -1.</para>
            </summary>
            
            <param name="Value">Value to be compared with this</param>
            
            <returns>Returns 1 if this > Value, -1 if this &lt; Value, 0 if this == Value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Divide(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this / Divisor</c>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns><c>this / Divisor</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.DivideAndRemainder(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger array which contains <c>this / Divisor</c> at index 0 and <c>this % Divisor</c> at index 1
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns><c>[this / Divisor, this % Divisor]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.FlipBit(System.Int32)">
            <summary>
            Returns a new BigInteger which has the same binary representation as this but with the bit at position N flipped. 
            <para>The result is equivalent to this ^ 2^N.</para>
            </summary>
            
            <param name="N">Position where the bit in this has to be flipped</param>
            
            <returns>Returns <c>this ^ 2^N</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if a negative bit address is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Gcd(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is greatest common divisor of this and Value.
            <para>If this==0 and Value==0 then zero is returned, otherwise the result is positive.</para>
            </summary>
            
            <param name="Value">Value with which the greatest common divisor is computed.</param>
            <returns><c>Gcd(this, Value)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.IsProbablePrime(System.Int32)">
            <summary>
            Tests whether this BigInteger is probably prime.
            <para>If true is returned, then this is prime with a probability beyond <c>(1-1/2^certainty)</c>.
            If false is returned, then this is definitely composite.
            If the argument Certainty &lt;= 0, then this method returns true.</para>
            </summary>
            
            <param name="Certainty">Tolerated primality uncertainty</param>
            
            <returns>Returns true, if this is probably prime, false  otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Max(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns the maximum of this BigInteger and Value
            </summary>
            
            <param name="Value">Value to be used to compute the maximum with this</param>
            
            <returns>Max(this, Value)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Min(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns the minimum of this BigInteger and Value
            </summary>
            
            <param name="Value">Value to be used to compute the minimum with this</param>
            
            <returns><c>Min(this, Value)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Mod(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this Mod M</c>.
            <para>The modulus M must be positive.
            The result is guaranteed to be in the interval (0, M) (0 inclusive, m exclusive).
            The behavior of this function is not equivalent to the behavior of the % operator defined for the built-in int's.</para>
            </summary>
            
            <param name="M">The modulus</param>
            
            <returns>Returns <c>this Mod M</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if M == null or M &lt; 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ModPow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this^Exponent Mod M</c>.
            <para>The modulus M must be positive.
            The result is guaranteed to be in the interval (0, M) (0 inclusive, m exclusive).
            If the Exponent is negative, then <c>this.ModInverse(M)^(-Exponent) Mod M)</c> is computed.
            The inverse of this only exists if this is relatively prime to M, otherwise an exception is thrown.</para>
            </summary>
            
            <param name="Exponent">The exponent</param>
            <param name="M">The modulus</param>
            
            <returns><c>this^Exponent Mod M</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if M &lt; 0 or if Exponent&lt;0 and this is not relatively prime to M</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ModInverse(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>1/this Mod M</c>. 
            <para>The modulus M must be positive.
            The result is guaranteed to be in the interval (0, M) (0 inclusive, M exclusive).
            If this is not relatively prime to M, then an exception is thrown.</para>
            </summary>
            
            <param name="M">The modulus</param>
            
            <returns>Returns <c>1/this Mod M</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if M &lt; 0 or, if this is not relatively prime to code M</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this * Value</c>
            </summary>
            
            <param name="Multiplicand">Value to be multiplied with this</param>
            <returns>Returns <c>this * Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Negate">
            <summary>
            Returns a new BigInteger whose value is the <c>-this</c>
            </summary>
            
            <returns><c>-this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.NextProbablePrime">
            <summary>
            Returns the smallest integer x &gt; this which is probably prime as a BigInteger instance.
            <para>The probability that the returned BigInteger is prime is beyond (1-1/2^80).</para>
            </summary>
            
            <returns>Smallest integer &gt; this which is robably prime</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if this &lt; 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Not">
            <summary>
            Returns a new BigInteger whose value is <c>~this</c>.
            <para>The result of this operation is <c>-this-1</c>.</para>
            </summary>
            
            <returns>Returns <c>~this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Or(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this | Value</c>
            </summary>
            
            <param name="Value">Value to be Or'ed with this</param>
            
            <returns>Returns <c>this | Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Pow(System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this ^ Exponent</c>
            </summary>
            
            <param name="Exponent">Exponent to which this is raised</param>
            
            <returns>Returns <c>this ^ Exponent</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ProbablePrime(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            Returns a random positive BigInteger instance in the range <c>[0, 2^(bitLength)-1]</c> which is probably prime.
            <para>The probability that the returned BigInteger is prime is beyond (1-1/2^80).</para>
            </summary>
            
            <param name="BitLength">Length of the new BigInteger in bits</param>
            <param name="Rnd">Random generator used to generate the new BigInteger</param>
            
            <returns>Returns probably prime random BigInteger instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Remainder(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this % Divisor</c>.
            <para>Regarding signs this methods has the same behavior as the % operator on int's, 
            i.e. the sign of the remainder is the same as the sign of this.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>Returns <c>this % Divisor</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.SetBit(System.Int32)">
            <summary>
            Returns a new BigInteger which has the same binary representation as this but with the bit at position N set.
            <para>The result is equivalent to <c>this | 2^n</c>.</para>
            </summary>
            
            <param name="N">Position where the bit in this has to be set</param>
            
            <returns>Returns <c>this | 2^n</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ShiftLeft(System.Int32)">
            <summary>
            Returns a new BigInteger whose value is this &lt;&lt; N.
            <para>The result is equivalent to <c>this * 2^n</c> if n >= 0.
            The shift distance may be negative which means that this is shifted right.
            The result then corresponds to <c>Floor(this / 2^(-n))</c>.</para>
            </summary>
            
            <param name="N">The shift distance in bits</param>
            
            <returns>Returns <c>this &lt;&lt; N</c> if n >= 0, <c>this >> (-N)</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ShiftRight(System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this >> N</c>.
            <para>For negative arguments, the result is also negative. 
            The shift distance may be negative which means that this is shifted left.</para>
            </summary>
            
            <param name="N">The shift distance in bits</param>
            
            <returns>this >> N, if N >= 0; this &lt;&lt; (-n) otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Signum">
            <summary>
            Returns the sign of this BigInteger
            </summary>
            
            <returns>Returns -1 if this &lt; 0, 0 if this == 0, 1 if this > 0</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Subtract(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this - val</c>
            </summary>
            
            <param name="Subtrahend">Value to be subtracted from this</param>
            
            <returns><c>this - val</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.TestBit(System.Int32)">
            <summary>
            Tests whether the bit at position N in this is set.
            <para>The result is equivalent to <c>this &amp; (2^n) != 0</c>.</para>
            </summary>
            
            <param name="N">Position where the bit in this has to be inspected.</param>
            
            <returns>Returns this &amp; (2^n) != 0</returns>
            
            <remarks>
            Implementation Note: Usage of this method is not 
            recommended as the current implementation is not efficient.
            </remarks>
            
            <exception cref="T:System.ArithmeticException">Thrown if a negative bit address is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToByteArray">
            <summary>
            Returns the two's complement representation of this BigInteger in a byte array
            </summary>
            
            <returns>Two's complement representation of this</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToDouble">
            <summary>
            Returns this BigInteger as an double value.
            <para>If this is too big to be represented as an double, then Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY} is returned.</para>
            </summary>
            
            <returns>Returns this BigInteger as a double value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Double.MAX_VALUE, Double.MAX_VALUE] can be represented as a double. 
            <para>The double representation has a mantissa of length 53. For example, <c>2^53+1 = 9007199254740993</c> is returned as double <c>9007199254740992.0</c>.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToInt32">
            <summary>
            Returns this BigInteger as an int value. 
            <para>If this is too big to be represented as an int, then <c>this % 2^32</c> is returned.</para>
            </summary>
            
            <returns>Returns this BigInteger as an int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToInt64">
            <summary>
            Returns this BigInteger as an long value. 
            <para>If this is too big to be represented as an long, then <c>this % 2^64</c> is returned.</para>
            </summary>
            
            <returns>Returns this BigInteger as a long value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToSingle">
            <summary>
            Returns this BigInteger as an float value.
            <para>If this is too big to be represented as an float, then Float.POSITIVE_INFINITY 
            or Float.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <returns>Returns this BigInteger as a float value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Float.MAX_VALUE, Float.MAX_VALUE] can be represented as a float. 
            The float representation has a mantissa of length 24.
            For example, 2^24+1 = 16777217 is returned as float 16777216.0.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToString(System.Int32)">
            <summary>
            Returns a string containing a string representation of this  BigInteger with base radix.
            <para>If Radix &lt; CharHelper.MIN_RADIX} or Radix > CharHelper.MAX_RADIX then a decimal representation is returned.
            The CharHelpers of the string representation are generated with method CharHelper.forDigit.</para>
            </summary>
            
            <param name="Radix">Base to be used for the string representation</param>
            
            <returns>Returns a string representation of this with radix 10</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ValueOf(System.Int64)">
            <summary>
            Returns a new BigInteger instance whose value is equal to Value 
            </summary>
            
            <param name="Value">The value to be converted to a BigInteger</param>
            
            <returns>Returns a BigInteger instance with the value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Xor(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this ^ Value</c>
            </summary>
            
            <param name="Value">Value to be xor'ed with this</param>
            
            <returns>Returns <c>this ^ Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Create a BigInteger from a stream
            </summary
            >
            <param name="Info">The serialization info</param>
            <param name="Context">The streaming context</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Get streaming object info
            </summary>
            
            <param name="Info">The serialization info</param>
            <param name="Context">The streaming context</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Equals(System.Object)">
            <summary>
            Returns true if Obj is a BigInteger instance and if this instance is equal to this BigInteger
            </summary>
            
            <param name="Obj">Object to be compared with this</param>
            
            <returns>Returns true if Obj is a BigInteger and this == Obj,  false otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.GetHashCode">
            <summary>
            Returns a hash code for this BigInteger
            </summary> 
            
            <returns>Returns hash code for this</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToString">
            <summary>
            Returns a string representation of this BigInteger in decimal form
            </summary>
            
            <returns>Returns a string representation of this in decimal form</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Addition(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A + B</c>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A + B</c>.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Subtraction(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A - B</c>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A - B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Multiply(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A * B</c>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The multiplicand value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A * B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Division(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A / B</c>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The divisor value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A / B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Modulus(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A Mod B</c>.
            <para>The modulus M must be positive.
            The result is guaranteed to be in the interval (0, M) (0 inclusive, m exclusive).
            The behavior of this function is not equivalent to the behavior of the % operator 
            defined for the built-in int's.</para>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The modulus value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A Mod B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_BitwiseAnd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the bit per bit operator between this number and the given one
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value to be and'ed with "A"</param>
            
            <returns>Returns a new BigInteger whose value is <c>A &amp; B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_BitwiseOr(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A | B</c>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value to be Or'ed with "A"</param>
            
            <returns>Returns a new BigInteger whose value is <c>A | B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_ExclusiveOr(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A ^ B</c>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">Value to be xor'ed with "A"</param>
            
            <returns>Returns a new BigInteger whose value is <c>A ^ B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_OnesComplement(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is ~X.
            <para>The result of this operation is <c>-X-1</c>.</para>
            </summary>
            
            <param name="X">Value to be unary reversed</param>
            
            <returns>Returns a new BigInteger whose value is <c>-X-1</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_UnaryNegation(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is the <c>-X</c>
            </summary>
            
            <param name="X">The value to be negated</param>
            
            <returns>Returns a new BigInteger whose value is <c>-X</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_RightShift(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this >> N</c>
            <para>For negative arguments, the result is also negative. 
            The shift distance may be negative which means that this is shifted left.</para>
            </summary>
            
            <param name="X">The value to be shifted</param>
            <param name="N">The shift distance in bits</param>
            
            <returns>Returns <c>X >> N</c>, if <c>N >= 0</c>; <c>X &lt;&lt; (-N)</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_LeftShift(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is this &lt;&lt; N.
            <para>The result is equivalent to <c>this * 2^n</c> if n >= 0.
            The shift distance may be negative which means that this is shifted right.
            The result then corresponds to <c>Floor(this / 2^(-n))</c>.</para>
            </summary>
            
            <param name="X">The value to be shifted</param>
            <param name="N">The shift distance in bits</param>
            
            <returns>Returns <c>X &lt;&lt; N</c> if N >= 0, <c>X >> (-N)</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_GreaterThan(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is more than BigInteger value "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A > B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_LessThan(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is less than BigInteger value "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A &lt; B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Equality(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if "A" is a BigInteger instance and if this instance is equal to the BigInteger "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if "B" is a BigInteger and <c>A == B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Inequality(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is not equal to BigInteger "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A != B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_GreaterThanOrEqual(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is more than or equal to BigInteger value "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A >= B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_LessThanOrEqual(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is less than or equal to BigInteger value "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A &lt;= B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.Int32">
            <summary>
            Returns this BigInteger as an int value. 
            <para>If this is too big to be represented as an int, then <c>this % 2^32</c> is returned.</para>
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns this BigInteger as an int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.Int64">
            <summary>
            Returns this BigInteger as an long value. 
            <para>If this is too big to be represented as an long, then <c>this % 2^64</c> is returned.</para>
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns this BigInteger as a long value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.Single">
            <summary>
            Returns this BigInteger as an float value.
            <para>If this is too big to be represented as an float, then Float.POSITIVE_INFINITY 
            or Float.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns this BigInteger as a float value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Float.MAX_VALUE, Float.MAX_VALUE] can be represented as a float. 
            The float representation has a mantissa of length 24.
            For example, 2^24+1 = 16777217 is returned as float 16777216.0.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.Double">
            <summary>
            Returns this BigInteger as an double value.
            <para>If this is too big to be represented as an double, then Double.POSITIVE_INFINITY or 
            Double.NEGATIVE_INFINITY} is returned.</para>
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns this BigInteger as a double value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Double.MAX_VALUE, Double.MAX_VALUE] can be represented as a double. 
            <para>The double representation has a mantissa of length 53. For example, <c>2^53+1 = 9007199254740993</c> is returned as double <c>9007199254740992.0</c>.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.String">
            <summary>
            Returns a string representation of this BigInteger in decimal form
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns a string representation of this in decimal form</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(System.Int32)~VTDev.Libraries.CEXEngine.Numeric.BigInteger">
            <summary>
            Returns a new BigInteger instance whose value is equal to Value
            </summary>
            
            <param name="Value">The int value to be converted to a BigInteger</param>
            
            <returns>Returns a BigInteger instance with the value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(System.Int64)~VTDev.Libraries.CEXEngine.Numeric.BigInteger">
            <summary>
            Returns a new BigInteger instance whose value is equal to Value
            </summary>
            
            <param name="Value">The long value to be converted to a BigInteger</param>
            
            <returns>Returns a BigInteger instance with the value</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigInteger.BitCount">
            <summary>
            Returns the number of bits in the binary representation of this which differ from the sign bit. 
            <para>Use BitLength(0) if you want to know the length of the binary value in bits.
            If this is positive the result is equivalent to the number of bits set in the binary representation of this.
            If this is negative the result is equivalent to the number of bits set in the binary representation of -this - 1.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigInteger.BitLength">
            <summary>
            Returns the length of the value's two's complement representation without 
            leading zeros for positive numbers / without leading ones for negative values.
            <para>The two's complement representation of this will be at least BitLength() + 1 bits long.
            The value will fit into an int if <c>bitLength() &lt; 32</c> or into a long if <c>bitLength() &lt; 64</c>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigInteger.LowestSetBit">
            <summary>
            Returns the position of the lowest set bit in the two's complement representation of this BigInteger.
            <para>If all bits are zero (this=0) then -1 is returned as result.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.PolynomialGenerator">
            <summary>
            Generates a sparse or dense mode polynomial
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.PolynomialGenerator.GenerateRandomTernary(System.Int32,System.Int32,System.Int32,System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Generates a "sparse" or "dense" polynomial containing numOnes ints equal to 1,
            numNegOnes int equal to -1, and the rest equal to 0.
            </summary>
            
            <param name="N">Number of coeffeients</param>
            <param name="NumOnes">Number of ones</param>
            <param name="NumNegOnes">Number of negative ones</param>
            <param name="Sparse">Create a SparseTernaryPolynomial or DenseTernaryPolynomial</param>
            <param name="Rng">Random number generator</param>
            
            <returns>A ternary polynomial</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial">
            <summary>
            A polynomial with {@link BigInteger} coefficients.
            <para>Some methods (like <c>add</c>) change the polynomial, others (like <c>mult</c>) do not,
            but return the result as a new polynomial.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Coeffs">
            <summary>
            should be marked as internal
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.#ctor(System.Int32)">
            <summary>
            Constructs a new polynomial with <c>N</c> coefficients initialized to 0.
            </summary>
            
            <param name="N">The number of coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Constructs a new polynomial with a given set of coefficients.
            </summary>
            
            <param name="Coeffs">The coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Constructs a <c>BigIntPolynomial</c> from a <c>IntegerPolynomial</c>. The two polynomials are
            independent of each other.
            </summary>
            
            <param name="P">The original polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Adds another polynomial which can have a different number of coefficients.
            </summary>
            
            <param name="B">The polynomial to add</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Clear">
            <summary>
            Clear the Coefficients
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Clone">
            <summary>
            Makes a copy of the polynomial that is independent of the original.
            </summary>
            <returns>The cloned polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Divide(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Divides each coefficient by a <c>BigInteger</c> and rounds the result to the nearest whole number.
            <para>Does not return a new polynomial but modifies this polynomial.</para>
            </summary>
            
            <param name="Divisor">The divisor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32)">
            <summary>
            Divides each coefficient by a <c>BigDecimal</c> and rounds the result to <c>decimalPlaces</c> places.
            </summary>
            
            <param name="Divisor">The divisor</param>
            <param name="DecimalPlaces">The number of fractional digits to round the result to</param>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.GetMaxCoeffLength">
            <summary>
            Returns the base10 length of the largest coefficient.
            </summary>
            
            <returns>Length of the longest coefficient</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Mod(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Takes each coefficient modulo a number.
            </summary>
            
            <param name="Modulus">The modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Multiplies each coefficient by a <c>BigInteger</c>. Does not return a new polynomial but modifies this polynomial.
            </summary>
            
            <param name="Factor">The polynomial factor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.MultBig(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial by another, taking the indices mod N.
            <para>Does not change this polynomial but returns the result as a new polynomial.
            Both polynomials must have the same number of coefficients.
            This method is designed for large polynomials and uses Schönhage-Strassen multiplication
            in combination with <a href="http://en.wikipedia.org/wiki/Kronecker_substitution">Kronecker substitution</a>.
            See <a href="http://math.stackexchange.com/questions/58946/karatsuba-vs-schonhage-strassen-for-multiplication-of-polynomials#58955">here</a> for details.</para>
            </summary>
            
            <param name="Factor">The polynomial to multiply by</param>
            
            <returns>The product polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.MultSmall(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial by another, taking the indices mod N.
            <para>Does not change this polynomial but returns the result as a new polynomial.
            Both polynomials must have the same number of coefficients.
            This method is designed for smaller polynomials and uses 
            <a href="http://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba multiplication</a>.</para>
            </summary>
            
            <param name="Factor">he polynomial to multiply by</param>
            
            <returns>The product polynomial</returns>
            
            <exception cref="!:NTRUException">Throws if the two polynomials have a different number of coefficients</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Subtract(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Subtracts another polynomial which can have a different number of coefficients.
            </summary>
            
            <param name="B">The polynomial to subtract</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.GetHashCode">
            <summary>
            Get the hash code
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Equals(System.Object)">
            <summary>
            Compare this big integer polynomial to another for equality
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC">
            <summary>
            <h3>SHA256 Hash based Message Authentication Code Wrapper using SHA-2 256.</h3>
            <para>A SHA512 HMAC as outlined in the NIST document: Fips 198-1<cite>Fips 198-1</cite></para>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new SHA256HMAC(), [DisposeEngine])
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Key size should be equal to digest output size<cite>RFC 2104</cite>; 32 bytes, (256 bits).</description></item>
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.#ctor(System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.ComputeMac(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2104: <see href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</see>.</description></item>
            <item><description>NIST Fips 198-1: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">The Keyed-Hash Message Authentication Code (HMAC)</see>.</description></item>
            <item><description>NIST Fips 180-4: <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Secure Hash Standard (SHS)</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac">
            <summary>
            Message Authentication Code (MAC) Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.ComputeMac(System.Byte[])">
            <summary>
            Get the Mac hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Mac Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="Offset">The offset in the data</param>
            
            <returns>bytes processed</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the MAC
            </summary>
            
            <param name="KeyParam">MAC key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.#ctor(System.Boolean)">
            <summary>
            Initialize the class
            <para>When using this constructor, you must call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> before processing.</para>
            </summary>
            
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Initialize the class and working variables.
            <para>When this constructor is used, <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> is called automatically.</para>
            </summary>
            
            <param name="Key">HMAC Key; passed to HMAC Initialize() through constructor</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException">Thrown if a null Key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the hash buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Mac value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="OutOffset">The offset in the data</param>
            
            <returns>The number of bytes processed</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the HMAC
            </summary>
            
            <param name="KeyParam">KeyParams containing HMAC Key. 
            <para>Uses the Key field of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams"/> class. 
            Key should be equal in size to the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DigestSize"/></para>
            </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.BlockSize">
            <summary>
            Get: The Ciphers internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyGenerator">
            <summary>
            <h3>A helper class for generating cryptographically strong keying material.</h3>
            <para>Generates an array or a populated KeyParams class, using a definable Digest(Prng) dual stage generator.</para>
            
            </summary>
            
            <example>
            <description>Create an array of pseudo random keying material:</description>
            <code>
            byte[] rand;
            using (KeyGenerator gen = new KeyGenerator([Prng], [Digest]))
                // generate pseudo random bytes
                rand = gen.Generate(Size);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Assignable digests and Prng parameters added</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Prng">VTDev.Libraries.CEXEngine.Crypto.Prng Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>SHA-2 Generates key material using a two stage Hmac_k(Prng()) process.</description></item>
            <item><description>Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, and Skein<cite>Skein</cite> also use a two stage generation method; Hash(Prng()).</description></item>
            <item><description>Prng can be any of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs"/> generators.</description></item>
            <item><description>Hash can be any of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests"/> digests.</description></item>
            <item><description>Default Prng is CSPRng<cite>RNGCryptoServiceProvider</cite>, default digest is SHA512.</description></item>
            <item><description>Resources are disposed of automatically.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyGenerator.#ctor">
            <summary>
            <para>Initializes the class with default generators; SHA-2 512, and RNGCryptoServiceProvider</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize the class and generators
            </summary>
            <param name="SeedEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">Prng</see> that supplies the key and seed material to the hash function</param>
            <param name="HashEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> type used to create the pseudo random keying material</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyGenerator.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyGenerator.GetKeyParams(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a populated KeyParams class
            </summary>
            
            <param name="KeySize">Size of Key to generate in bytes</param>
            <param name="IVSize">Size of Optional IV in bytes</param>
            <param name="IKMSize">Size of Optional IKM in bytes</param>
            
            <returns>A populated <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams"/> class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyGenerator.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyGenerator.GetBytes(System.Int32)">
            <summary>
            Return an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyGenerator.Reset">
            <summary>
            Reset the seed <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">PRNG</see> and the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> engines
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyGenerator.GetBlock">
            <remarks>
            Create keying material using a two stage generator
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyGenerator.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs">
            <summary>
            Message Authentication Code Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs.CMAC">
            <summary>
            A Cipher based Message Authentication Code wrapper (CMAC)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs.HMAC">
            <summary>
            A Hash based Message Authentication Code wrapper (HMAC)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs.SHA256HMAC">
            <summary>
            SHA256 Hash based Message Authentication Code
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs.SHA512HMAC">
            <summary>
            SHA512 Hash based Message Authentication Code
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs.VMPCMAC">
            <summary>
            A Variably Modified Permutation Composition based Message Authentication Code (VMPC-MAC)
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KdfGenerators">
            <summary>
            Random Generator Digest KDFs
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KdfGenerators.DGCDRBG">
            <summary>
            An implementation of a Digest Counter based DRBG
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KdfGenerators.HKDF">
            <summary>
            A Hash based Key Derivation Function HKDF
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KdfGenerators.KDF2">
            <summary>
            An implementation of the Hash based KDF KDF2 DRBG
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KdfGenerators.PKCS5">
            <summary>
            An implementation of PKCS5 Version 2
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024">
            <summary>
            <h3>Skein1024: An implementation of the Skein digest with a 1024 bit digest return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Skein<cite>Skein</cite> digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Skein1024())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/03/10" version="1.3.0.0">Added Initialize call to Ctor</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 128 bytes, (1024 bits).</description></item>
            <item><description>Digest size is 128 bytes, (1024 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.DoFinal(System.Byte[],System.Int32)"/> method does NOT reset the internal state; call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset"/> to reinitialize.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>The Skein Hash Function Family: <see href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</see>.</description></item>
            <item><description>Skein <see href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</see> Support for the Skein Hash Family.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Adapted from the excellent project by Alberto Fajardo: <see href="http://code.google.com/p/skeinfish/">Skeinfish Release 0.50</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Initializes the Skein hash instance
            </summary>
            
            <param name="InitializationType">Digest initialization type <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType"/></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value.
            <para>Note: <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset"/> is called post hash calculation.</para> 
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.DoFinal(System.Byte[],System.Int32)">
            <summary>
            <para>Do final processing and get the hash value. 
            Note: Digest is not reset after calling DoFinal. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset"/> must be called before a new hash can be generated.</para>
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Initialize(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Used to re-initialize the digest state.
            <para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
            This does not start a new UBI block type, and must be done manually.</para>
            </summary>
            
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SkeinConfig">
            <remarks>
            Default configuration
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.GenerateConfiguration">
            <remarks>
            Default generation function
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.GenerateConfiguration(System.UInt64[])">
            <summary>
            Generate a configuration using a state key
            </summary>
            
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetSchema(System.Byte[])">
            <summary>
            Set the Schema. Schema must be 4 bytes.
            </summary>
            
            <param name="Schema">Schema Configuration string</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid schema is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetVersion(System.Int32)">
            <summary>
            Set the version string. Version must be between 0 and 3, inclusive.
            </summary>
            
            <param name="Version">Version string</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid version is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetTreeLeafSize(System.Byte)">
            <summary>
            Set the tree leaf size
            </summary>
            
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetTreeFanOutSize(System.Byte)">
            <summary>
            Set the tree fan out size
            </summary>
            
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetMaxTreeHeight(System.Byte)">
            <summary>
            Set the tree height. Tree height must be zero or greater than 1.
            </summary>
            
            <param name="Height">Tree height</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid tree height is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ConfigValue">
            <summary>
            The post-chain configuration value ToDo: change these and threefish cipher to int type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ConfigString">
            <summary>
            The pre-chain configuration string
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.InitializationType">
            <summary>
            The initialization type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.StateSize">
            <summary>
            State size in bits
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.UbiParameters">
            <summary>
            Ubi Tweak parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256">
            <summary>
            <h3>Keccak256: An implementation of the SHA-3 Keccak digest.</h3>
            <para>SHA-3 competition winner<cite>SHA-3 Standardization</cite>: The Keccak<cite>Keccak</cite> digest</para>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Keccak256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/01/23" version="1.3.5.0">Rewritten for improvements to security and speed</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Hash sizes are 28, 32, and 36 bytes (224, 256, and 288 bits).</description></item>
            <item><description>Block sizes are 144, 128, and 136 bytes (1152, 1024, 1088 bits).</description></item>
            <item><description>Use the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.BlockSize"/> property to determine block sizes at runtime.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 <see href="http://keccak.noekeon.org/Keccak-submission-3.pdf">Keccak Submission</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent HashLib project implementation <see href="http://hashlib.codeplex.com/">Keccak.cs</see> class, 
            and the <see href="https://github.com/gvanas/KeccakCodePackage">Keccak Code Package</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.#ctor(System.Int32)">
            <summary>
            Initialize the digest
            </summary>
            
            <param name="DigestSize">Digest return size in bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA3 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB">
            <summary>
            <h3>Implements a Output FeedBack Mode: OFB.</h3>
            <para>OFB as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new OFB(new RDX(), [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Cipher is used. for encryption, false to decrypt</param>
            <param name="KeyParam">The KeyParams containing key and vector</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null Key or IV is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.IV">
            <summary>
            Get: The current state of the initialization Vector
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricSignException">
            <summary>
            Wraps exceptions thrown within a Asymmetric Signing operational context.
            <para>This exception is used throughout the Asymmetric Sign domain.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricSignException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricSignException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricSignException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricSignException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricSignException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial">
            <summary>
            A <c>TernaryPolynomial</c> with a "high" number of nonzero coefficients.
            <para>Coefficients are represented as an array of length <c>N</c> containing ones, negative ones, and zeros.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial">
            <summary>
            A polynomial with <c>integer</c> coefficients.
            <para>Some methods (like <c>Add</c>) change the polynomial, others (like <c>Multiply</c>) do not,
            but return the result as a new polynomial.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Coeffs">
            <summary>
            should be marked as internal
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.#cctor">
            <summary>
            Static Constructor
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.#ctor(System.Int32)">
            <summary>
            Constructs a new polynomial with <c>N</c> coefficients initialized to 0
            </summary>
            
            <param name="N">The number of coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.#ctor(System.Int32[])">
            <summary>
            Constructs a new polynomial with a given set of coefficients
            </summary>
            
            <param name="Coeffs">The coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Constructs a <c>IntegerPolynomial</c> from a <c>BigIntPolynomial</c>. The two polynomials are independent of each other
            </summary>
            
            <param name="P">The original polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial)">
            <summary>
            Adds a <c>TernaryPolynomial</c> which must not have more coefficients than <c>this</c> polynomial.
            </summary>
            
            <param name="B">Another polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Adds another polynomial
            </summary>
            <param name="B">The polynomial to add</param> //p
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Adds another polynomial which must not have more coefficients than <c>this</c>
            polynomial, and takes the coefficient values mod <c>modulus</c>.
            </summary>
            
            <param name="B">The polynomial to add</param>
            <param name="Modulus">The modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Center0(System.Int32)">
            <summary>
            Shifts the values of all coefficients to the interval <c>[-q/2, q/2]</c>.
            </summary>
            
            <param name="Q">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.CenteredNormSq(System.Int32)">
            <summary>
            Computes the centered euclidean norm of the polynomial.
            </summary>
            
            <param name="Q">The Modulus</param>
            
            <returns>The centered norm</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Clear">
            <summary>
            Clear the coefficients
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Clone">
            <summary>
            Clone the polynomial
            </summary>
            <returns>The cloned polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Count(System.Int32)">
            <summary>
            Counts the number of coefficients equal to an integer
            </summary>
            
            <param name="Value">Value of an integer</param>
            
            <returns>The number of coefficients equal to <c>value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Divide(System.Int32)">
            <summary>
            Divides each coefficient by <c>k</c> and rounds to the nearest integer.
            <para>Does not return a new polynomial but modifies this polynomial.</para>
            </summary>
            
            <param name="Divisor">The divisor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.EnsurePositive(System.Int32)">
            <summary>
            Adds <c>modulus</c> until all coefficients are above 0.
            </summary>
            
            <param name="Modulus">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.EqualsOne">
            <summary>
            Tests if <c>p(x) = 1</c>.
            </summary>
            
            <returns>True iff all coefficients are equal to zero, except for the lowest coefficient which must equal 1</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.FromBinary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a polynomial with N coefficients between <c>0</c> and <c>q-1</c>.
            </summary>
            
            <param name="Data">ata an encoded ternary polynomial</param>
            <param name="N"> number of coefficients</param>
            <param name="Q">Q value, must be a power of 2</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.FromBinary(System.IO.Stream,System.Int32,System.Int32)">
            <summary>
            Returns a polynomial with N coefficients between <c>0</c> and <c>q-1</c>.
            </summary>
            
            <param name="InputStream">An encoded ternary polynomial</param>
            <param name="N">The number of coefficients</param>
            <param name="Q">Q value, must be a power of 2</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.FromBinary3Sves(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Decodes a byte array to a polynomial with <c>N</c> ternary coefficients.
            <para>Ignores any excess bytes.</para>
            </summary>
            
            <param name="Data">Data an encoded ternary polynomial</param>
            <param name="N">The number of coefficients</param>
            <param name="SkipFirst">Whether to leave the constant coefficient zero and start populating at the linear coefficient</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.FromBinary3Tight(System.Byte[],System.Int32)">
            <summary>
            Converts a byte array produced by ToBinary3Tight() to a polynomial
            </summary>
            
            <param name="B">A byte array</param>
            <param name="N">The number of coefficients</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.FromBinary3Tight(System.IO.MemoryStream,System.Int32)">
            <summary>
            Reads data produced by ToBinary3Tight() from an input stream and converts it to a polynomial
            </summary>
            
            <param name="InputStream">An input stream</param>
            <param name="N">The number of coefficients</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.InvertF3">
            <summary>
            Computes the inverse mod 3.
            <para>Returns <c>null</c> if the polynomial is not invertible.
            The algorithm is described in <a href="http://www.securityinnovation.com/uploads/Crypto/NTRUTech014.pdf">
            Almost Inverses and Fast NTRU Key Generation</a>.</para>
            </summary>
            
            <returns>A new polynomial, or <c>null</c> if no inverse exists</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.InvertFq(System.Int32)">
            <summary>
            Computes the inverse mod <c>q; q</c> must be a power of 2.
            <para>Returns <c>null</c> if the polynomial is not invertible.
            The algorithm is described in <a href="http://www.securityinnovation.com/uploads/Crypto/NTRUTech014.pdf">
            Almost Inverses and Fast NTRU Key Generation</a>.</para>
            </summary>
            
            <param name="Q">The modulus</param>
            
            <returns>A new polynomial, or <c>null</c> if no inverse exists</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.IsInvertiblePow2">
            <summary>
            Tests if this polynomial is invertible modulo 2.
            <para>If a polynomial is invertible modulo 2, it is invertible modulo any power of 2.</para>
            </summary>
            
            <returns>Returns <c>true</c> if an inverse mod 2<sup>k</sup> for all k exists, <c>false</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.IsReduced(System.Int32)">
            <summary>
            Tests whether all coefficients are between 0 and <c>modulus</c>
            </summary>
            
            <param name="Modulus">The Modulus</param>
            
            <returns>Returns <c>true</c> if <c>0 &lt; c &lt; modulus</c> for all coefficients</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.IsTernary">
            <summary>
            Tests id polynomial is ternary
            </summary>
            
            <returns>True if ternary</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Mod(System.Int32)">
            <summary>
            Takes each coefficient modulo <c>modulus</c>.
            </summary>
            
            <param name="Modulus">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Mod3">
            <summary>
            Takes each coefficient modulo 3 such that all coefficients are ternary.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ModCenter(System.Int32)">
            <summary>
            Reduces all coefficients to the interval [-modulus/2, modulus/2)
            </summary>
            
            <param name="Modulus">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ModPositive(System.Int32)">
            <summary>
            Ensures all coefficients are between 0 and <c>modulus-1</c>
            </summary>
            
            <param name="Modulus">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ModPositive4">
            <summary>
            Ensures all coefficients are between 0 and 3
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Mult3(System.Int32)">
            <summary>
            Multiplies each coefficient by 3 and applies a modulus. Does not return a new polynomial but modifies this polynomial
            </summary>
            
            <param name="Modulus">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Multiply(System.Int32)">
            <summary>
            Multiplies each coefficient by a <c>int</c>. Does not return a new polynomial but modifies this polynomial.
            </summary>
            
            <param name="Factor">Integer factor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Multiplies the polynomial with another, taking the indices mod N
            </summary>
            <param name="Factor">The polynomial factor</param>
            
            <returns>Multiplied polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial with another, taking the indices mod N
            </summary>
            
            <param name="Factor">The polynomial factor</param>
            
            <returns>Multiplied polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Multiplies the polynomial with another, taking the values mod modulus and the indices mod N
            </summary>
            
            <param name="Factor">The polynomial factor</param>
            <param name="Modulus">The Modulus</param>
            
            <returns>Multiplied polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Resultant">
            <summary>
            Resultant of this polynomial with <c>x^n-1</c> using a probabilistic algorithm.
            </summary>
            
            <remarks>
            <para>Unlike EESS, this implementation does not compute all resultants modulo primes
            such that their product exceeds the maximum possible resultant, but rather stops
            when <c>NUM_EQUAL_RESULTANTS</c> consecutive modular resultants are equal.
            This means the return value may be incorrect. Experiments show this happens in
            about 1 out of 100 cases when <c>N=439</c> and <c>NUM_EQUAL_RESULTANTS=2</c>,
            so the likelyhood of leaving the loop too early is <c>(1/100)^(NUM_EQUAL_RESULTANTS-1)</c>.</para>
            <para>Because of the above, callers must verify the output and try a different polynomial if necessary.</para>
            </remarks>
            
            <returns>Returns <c>(rho, res)</c> satisfying <c>res = rho*this + t*(x^n-1)</c> for some integer <c>t</c>.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Rotate1">
            <summary>
            Multiplication by <c>X</c> in <c>Z[X]/Z[X^n-1]</c>.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Subtract(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Subtracts another polynomial which must not have more coefficients than <c>this</c> polynomial.
            </summary>
            
            <param name="B">The polynomial to subtract</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Resultant(System.Int32)">
            <summary>
            Resultant of this polynomial with <c>x^n-1 mod p</c>.
            </summary>
            
            <param name="P">P value</param>
            
            <returns>Returns <c>(rho, res)</c> satisfying <c>res = rho*this + t*(x^n-1) mod p</c> for some integer <c>t</c>.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.SumCoeffs">
            <summary>
            Returns the sum of all coefficients, i.e. evaluates the polynomial at 1.
            </summary>
            
            <returns>The sum of all coefficients</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ToBinary(System.Int32)">
            <summary>
            Encodes a polynomial whose coefficients are between 0 and q, to binary. q must be a power of 2.
            </summary>
            
            <param name="Q">Q value</param>
            
            <returns>The encoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ToBinary3Sves(System.Boolean)">
            <summary>
            Encodes a polynomial with ternary coefficients to binary.
            <para><c>coeffs[2*i]</c> and <c>coeffs[2*i+1]</c> must not both equal -1 for any integer <c>i</c>,
            so this method is only safe to use with polynomials produced by <c>fromBinary3Sves()</c>.</para>
            </summary>
            
            <param name="SkipFirst">Whether to skip the constant coefficient</param>
            
            <returns>The encoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ToBinary3Tight">
            <summary>
            Converts a polynomial with ternary coefficients to binary.
            </summary>
            
            <returns>The encoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ToBinaryTrunc(System.Int32,System.Int32)">
            <summary>
            Like ToBinary(int) but only returns the first <c>numBytes</c> bytes of the encoding.
            </summary>
            
            <param name="Q">Q value</param>
            <param name="NumBytes">Byte count</param>
            
            <returns>The encoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ToBinary4">
            <summary>
            Optimized version of ToBinary(int) for <c>q=4</c>.
            <para>Encodes the low 2 bits of all coefficients in a byte array.</para>
            </summary>
            
            <returns>A byte array equal to what <c>toBinary(4)</c> would return</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ToIntegerPolynomial">
            <summary>
            Returns a polynomial that is equal to this polynomial (in the sense that mult(IntegerPolynomial, int) 
            returns equal <c>IntegerPolynomial</c>s). The new polynomial is guaranteed to be independent of the original.
            </summary>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.InvertF2">
            <summary>
            Computes the inverse mod 2. 
            <para>The algorithm is described in <a href="http://www.securityinnovation.com/uploads/Crypto/NTRUTech014.pdf">
            Almost Inverses and Fast NTRU Key Generation</a>.</para>
            </summary>
            
            <returns>Returns <c>null</c> if the polynomial is not invertible.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Mod2ToModq(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Computes the inverse mod <c>q</c> from the inverse mod 2.
            <para>The algorithm is described in <a href="http://www.securityinnovation.com/uploads/Crypto/NTRUTech014.pdf">
            Almost Inverses and Fast NTRU Key Generation</a>.</para>
            </summary>
            
            <param name="Fq">Fq value</param>
            <param name="Q">Q value</param>
            
            <returns>The inverse of this polynomial mod q</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Invert(System.Int32,System.Int32)">
            <remarks>
            Calculates the inverse of n mod modulus
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Pow(System.Int32,System.Int32,System.Int32)">
            <remarks>
            Calculates a^b mod modulus
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.MultShiftSub(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32,System.Int32,System.Int32)">
            <remarks>
             Computes this-b*c*(x^k) mod p and stores the result in this polynomial.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Degree">
            <remarks>
            Returns the degree of the polynomial
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Subtract(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Subtracts another polynomial which can have a different number of coefficients,
            and takes the coefficient values mod <c>modulus</c>.
            </summary>
            
            <param name="B">The polynomial to subtract</param>
            <param name="Modulus">The modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Subtract(System.Int32)">
            <summary>
            Subtracts a <c>int</c> from each coefficient. Does not return a new polynomial but modifies this polynomial.
            </summary>
            
            <param name="B">A number to subtract from each coefficient</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Mult2(System.Int32)">
            <summary>
            Multiplies each coefficient by 2 and applies a modulus. Does not return a new polynomial but modifies this polynomial
            </summary>
            
            <param name="Modulus">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Mod2">
            <summary>
            Optimized version of ModPositive(2) //p
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ShiftGap(System.Int32)">
            <summary>
            Shifts all coefficients so the largest gap is centered around <c>-q/2</c>.
            </summary>
            
            <param name="Q">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.EqualsZero">
            <summary>
            Tests if <c>p(x) = 0</c>.
            </summary>
            
            <returns>True if all coefficients are zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.EqualsAbsOne">
            <summary>
            Tests if <c>|p(x)| = 1</c>.
            </summary>
            
            <returns>True iff all coefficients are equal to zero, except for the lowest coefficient which must equal 1 or -1</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.GetHashCode">
            <summary>
            Get the hash code
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Equals(System.Object)">
            <summary>
            Compare this integer polynomial to another for equality
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Constructs a <c>DenseTernaryPolynomial</c> from a <c>IntegerPolynomial</c>. 
            <para>The two polynomials are independent of each other.</para>
            </summary>
            
            <param name="IntPoly">The original polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.#ctor(System.Int32[])">
            <summary>
            Constructs a new <c>DenseTernaryPolynomial</c> with a given set of coefficients.
            </summary>
            
            <param name="Coeffs">The coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.GenerateBlindingPoly(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator,System.Int32,System.Int32)">
            <summary>
            Generates a blinding polynomial using an IndexGenerator
            </summary>
            
            <param name="Ig">An Index Generator</param>
            <param name="N">The number of coefficients</param>
            <param name="Dr">The number of ones / negative ones</param>
            
            <returns>A blinding polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.GenerateRandom(System.Int32,System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Generates a random polynomial with <c>NumOnes</c> coefficients equal to 1,
            <c>NumNegOnes</c> coefficients equal to -1, and the rest equal to 0.
            </summary>
            
            <param name="N">Number of coefficients</param>
            <param name="NumOnes">Number of 1's</param>
            <param name="NumNegOnes">Number of -1's</param>
            <param name="Rng">Random number generator</param>
            
            <returns>The generated polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.GetNegOnes">
            <summary>
            Get the number of negative ones
            </summary>
            
            <returns>negative ones count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.GetOnes">
            <summary>
            Get the number of ones
            </summary>
            
            <returns>Ones count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Multiplies the polynomial with another, taking the values mod modulus and the indices mod N
            </summary>
            
            <param name="Factor">The polynomial factor</param>
            <param name="Modulus">The Modulus</param>
            
            <returns>Multiplied polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.Size">
            <summary>
            Returns the maximum number of coefficients the polynomial can have
            </summary>
            
            <returns>Coefficients size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.GenerateBlindingCoeffs(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator,System.Int32,System.Int32)">
            <summary>
            Generates an <c>int</c> array containing <c>dr</c> elements equal to <c>1</c>
            and <c>dr</c> elements equal to <c>-1</c> using an index generator.
            </summary>
            
            <param name="Ig">An Index Generator</param>
            <param name="N">The number of coefficients</param>
            <param name="Dr">The number of ones / negative ones</param>
            
            <returns>An array containing numbers between <c>-1</c> and <c>1</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.Equals(System.Object)">
            <summary>
            Compare this polynomial to another for equality
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt">
            <summary>
            An NTRU asymmetric cipher implementation
            </summary>
            
            <example>
            <description>Example of encryption/decryption of plain text:</description>
            <code>
            // use a predefined parameter set
            NtruParameters prm = NTRUParamSets.APR2011743FAST;
            NtruKeyPair keyPair;
            byte[] enc, dec;
            byte[] data = new byte[64];
            
            // generate a key pair
            using (NTRUKeyGenerator gen = new NTRUKeyGenerator(prm))
                NtruKeyPair keyPair = gen.GenerateKeyPair();
            
            // encrypt a message
            using (NtruEncrypt ntru = new NtruEncrypt(ps))
            {
                // initialize with public key for encryption
                ntru.Initialize(keyPair.PublicKey);
                // encrypt using public key
                enc = ntru.Encrypt(data);
            }
            
            // decrypt a message
            using (NtruEncrypt ntru = new NtruEncrypt(ps))
            {
                // initialize with both keys for decryption
                ntru.Initialize(keyPair);
                // decrypt using key pair
                dec = ntru.Decrypt(enc);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.0.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUKeyPair Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUParameters Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricCipher Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
            
            <remarks>
            <description><h4>Basic Operations:</h4></description>
            
            <description><h5>Encryption</h5></description>
            <list type="table">
            <item><description>Randomly select a “small” polynomial <c>r ∈ Dr</c>.</description></item>
            <item><description>Calculate the ciphertext e as <c>e ≡ r ∗ h+m (mod q)</c>.</description></item>
            </list>
            
            <description><h5>Decryption:</h5></description>
            <list type="table">
            <item><description>Calculate <c>a ≡ center(f ∗ e)</c>, where the centering operation center reduces its input into the interval <c>[A,A+q−1]</c>.</description></item>
            <item><description>Recover m by calculating <c>m ≡ fp ∗ a (mod p)</c>.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NTRU: A Ring Based Public Key Crypto System<cite>NTRU Crypto</cite>.</description></item>
            <item><description>Optimizations for NTRU<cite>NTRU Optimizations</cite>.</description></item>
            <item><description>Adaptive Key Recovery Attacks on NTRU-based Somewhat Homomorphic Encryption Schemes<cite>NTRU Adaptive</cite>.</description></item>
            <item><description>Efficient Embedded Security Standards (EESS)<cite>NTRU EESS</cite>.</description></item>
            <item><description>Practical lattice-based cryptography: NTRUEncrypt and NTRUSign<cite>NTRU Practical</cite>.</description></item>
            <item><description>NTRU Cryptosystems Technical Report<cite>NTRU Technical</cite>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent java project NTRU Encrypt by Tim Buktu: <see href="https://github.com/tbuktu/ntru/description">Release 1.2</see>, and
            the NTRUOpenSourceProject/ntru-crypto project provided by Security Innovation, Inc: <see href="https://github.com/NTRUOpenSourceProject/ntru-crypto">Release 1.2</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters)">
            <summary>
            Constructs a new instance with a set of encryption parameters
            </summary>
            
            <param name="NtruParams">Encryption parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Decrypt(System.Byte[])">
            <summary>
            Decrypts a message
            </summary>
            
            <param name="Input">The message to decrypt</param>
            
            <returns>The decrypted message</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">If not initialized, the specified hash algorithm is invalid, the encrypted data is invalid, or <c>MaxLenBytes</c> is greater than 255</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Encrypt(System.Byte[])">
            <summary>
            Encrypts a message
            </summary>
            
            <param name="Input">The message to encrypt</param>
            
            <returns>The encrypted message</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">If not initialized, the specified hash algorithm is invalid, the encrypted data is invalid, or <c>maxLenBytes</c> is greater than 255</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.GenerateSalt(System.Int32)">
            <summary>
            A convenience method that generates a random salt vector for key pair generation.
            </summary>
            
            <param name="Size">Byte length of the new salt</param>
            
            <returns>A new salt vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the cipher for Encryption; This Initialize() method is only for Encryption.
            <para>Requires a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey"/> for encryption operations.
            For Decryption use the se the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair)"/> method and pass a KeyPair with both Public and Private keys.
            </para>
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the NTRU Public key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if a key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair)">
            <summary>
            Initialize the cipher for Decryption; This Initialize() method is only for Decryption.
            <para>Requires a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey"/> for encryption, or a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey"/> for decryption contained in an <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair"/> class.
            NTRU requires both Public and Private keys to decrypt a message.
            Use the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)"/> method and pass the NTRUPublicKey for Encryption.
            </para>
            </summary>
            
            <param name="KeyPair">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair"/> containing the NTRU public or private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if a key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Decrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Decrypts an integer polynomial
            </summary>
            
            <param name="E">Encrypted polynomial</param>
            <param name="PrivT">A polynomial such that if <c>fastFp=true</c>, <c>f=1+3*priv_t</c>; otherwise, <c>f=priv_t</c></param>
            <param name="PrivFp">Fp</param>
            
            <returns>Derypted polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Digest">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the Prng
            </summary>
            
            <param name="Prng">Prng type</param>
            
            <returns>Instance of Prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.GetSeed(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Byte[])">
            <summary>
            Generates a seed for the Blinding Polynomial Generation Function
            </summary>
            
            <param name="Message">The plain-text message</param>
            <param name="PubKey">The public key</param>
            <param name="Bits">Bits of random data</param>
            
            <returns>A byte array containing a seed value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.GenerateBlindingPoly(System.Byte[])">
            <summary>
            Deterministically generates a blinding polynomial from a seed and a message representative
            </summary>
            
            <param name="Seed">The seed value</param>
            
            <returns>A blinding polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.MGF(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            An implementation of MGF-TP-1 from P1363.1 section 8.4.1.1.
            </summary>
            
            <param name="Seed">The seed value</param>
            <param name="N">N paramater</param>
            <param name="MinCallsMask">Minimum Calls Mask</param>
            <param name="HashSeed">Whether to hash the seed</param>
            
            <returns></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can encrypt
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if the cipher is not initialized</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2">
            <summary>
            <h3>An implementation of a Quadratic Congruential Generator II random number generator : QCG-II.</h3>
            <para>Implements QCGII as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.3</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new QCG2())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">QuadraidResidue2Prng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations; must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="P">Random Prime with probability &lt; 2 ** -100</param>
            <param name="G">Random Generator State</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Reset">
            <summary>
            Resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG">
            <summary>
            <h3>An implementation of a Blum-Blum-Shub random number generator.</h3>
            <para>Implements BBSG as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.8</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new BBSG())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            <item><description>Cryptographic Secure Pseudo-Random Bits Generation: <cite>Blum-Blum-Shub</cite>The Blum-Blum-Shub Generator.</description></item>
            <item><description>Handbook of Applied Cryptography Chapter 5<cite>Handbook of Applied Cryptography</cite>: Pseudorandom Bits and Sequences.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">BBSPrng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Primes, and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="X">Random Generator State (X = X ** 2 mod N)</param>
            <param name="P">P Random Prime</param>
            <param name="Q">Q Random Prime</param>
            <param name="N">Random Prime (N = P * Q)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if P or Q is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg">
            <summary>
            <h3>CTRDrbg: An implementation of a Encryption Counter based Deterministic Random Byte Generator.</h3>
            <para>A Block Cipher Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90B</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new CTRDrbg(new RDX()))
            {
                // initialize
                rnd.Initialize(Salt, [Ikm], [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with any block <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">cipher</see>.</description></item>
            <item><description>Parallelized by default on a multi processer system when an input byte array of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.ParallelMinimumSize"/> bytes or larger is used.</description></item>
            <item><description>Parallelization can be disabled using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.IsParallel"/> property.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean,System.Int32)">Constructors</see> DisposeEngine parameter determines if Cipher engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Combination of [Salt, Ikm, Nonce] must be: cipher key size +  cipher block size in length.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-90B: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">Recommendation for the Entropy Sources Used for Random Bit Generation</see>.</description></item>
            <item><description>NIST Fips 140-2: <see href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Security Requirments For Cryptographic Modules</see>.</description></item>
            <item><description>NIST SP800-22 1a: <see href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</see>.</description></item>
            <item><description>Security Bounds for the NIST Codebook-based: <see href="http://eprint.iacr.org/2006/379.pdf">Deterministic Random Bit Generator</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean,System.Int32)">
            <summary>
            Creates a CTR Bytes Generator using a block cipher
            </summary>
            
            <param name="Cipher">The block cipher</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Dispose"/> on this class is called</param>
            <param name="KeySize">The key size (in bytes) of the symmetric cipher; a <c>0</c> value will auto size the key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null block cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if an invalid or null salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Nonce value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Update(System.Byte[])">
            <summary>
            <para>Update the Seed material. Two state Seed paramater: 
            If Seed size is equal to cipher key size plus counter size, both are updated. 
            If Seed size is equal to counter size (16 bytes) counter is updated.</para>
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.IsParallel">
            <summary>
            Get/Set Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.KeySize">
            <summary>
            <para>The key size (in bytes) of the symmetric cipher</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.ProcessorCount">
            <summary>
            Processor count
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Name">
            <summary>
            Get: Algorithm Name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.ParallelMinimumSize">
            <summary>
            Get: Minimum input size to trigger parallel processing
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">
            <summary>
            Symmetric Encryption Ciphers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.ChaCha">
            <summary>
            An implementation of the ChaCha Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.Fusion">
            <summary>
            An implementation of the Twofish and Rijndael Merged Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.RDX">
            <summary>
            An extended implementation of the Rijndael Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.RHX">
            <summary>
            An implementation based on the Rijndael Block Cipher, using HKDF with a SHA512 HMAC for expanded key generation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.RSM">
            <summary>
            An implementation based on the Rijndael and Serpent Merged Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.Salsa">
            <summary>
            A Salsa20 Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.SPX">
            <summary>
            An extended implementation of the Serpent Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.SHX">
            <summary>
            The Serpent Block Cipher Extended with an HKDF Key Schedule
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.TFX">
            <summary>
            An extended implementation of the Twofish Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.THX">
            <summary>
            A Twofish Block Cipher Extended with an HKDF Key Schedule
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.TSM">
            <summary>
            An implementation based on the Twofish and Serpent Merged Block Ciphers, using an HKDF Key Schedule
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM">
            <summary>
            <h3>TSM: An implementation based on the Twofish and Serpent Merged block ciphers, extended with an HKDF powered Key Schedule.</h3>
            <para>TSM is Twofish<cite>Twofish</cite> and Serpent<cite>Serpent</cite> ciphers, merged within the rounds function.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new TSM()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 24, and 32, default is 16.</description></item>
            </list>
            
            <para>The transform combines the two ciphers within the rounds function processing loop. 
            In the rounds functions, a round of Twofish is processed; the permuted product of that transformation is then transformed again by a round of Serpent.
            This alternating of state transformations between two very strong cryptographic primitives, both creates a highly diffused output, and creates a cipher 
            that is very resistant to cryptanalysis.</para>
            
            <para>The key schedule in TSM powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            TSM is capable of processing up to 32 rounds, that is twice the number of rounds used in a standard implementation of Twofish. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">Specification</see>.</description></item>
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">Fips 198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalRounds"/> property contains available sizes. Default is 16 rounds.</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom">
            <summary>
            <h3>An implementation of a Cryptographically Secure Pseudo Random Number Generator: SecureRandom.</h3> 
            
            <para>Uses the RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class to generate non-negative random numbers.</para>
            </summary>
            
            <example>
            <c>
            int x;
            using (SecureRandom rnd = new SecureRandom())
                x = rnd.NextInt32();
            </c>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/04/28" version="1.4.0.0">Added thread safety</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.#ctor(System.Int32)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="BufferSize">Size of the internal buffer; must be more than zero</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if a zero size buffer is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if RNGCryptoServiceProvider initialization failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextChar">
            <summary>
            Get a random char
            </summary>
            
            <returns>Random char</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.AnyDouble">
            <summary>
            Get a non-ranged random double
            </summary>
            
            <returns>Random double</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextDouble">
            <summary>
            Get a random double in the range 0.0 to 1.0
            </summary>
            
            <returns>Random double</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt16">
            <summary>
            Get a random non-negative short integer
            </summary>
            
            <returns>Random Int16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt16(System.Int16)">
            <summary>
            Get a random non-negative short integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            <returns>Random Int16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt16(System.Int16,System.Int16)">
            <summary>
            Get a random non-negative short integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt16">
            <summary>
            Get a random unsigned short integer
            </summary>
            
            <returns>Random UInt16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt16(System.UInt16)">
            <summary>
            Get a random unsigned short integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt16(System.UInt16,System.UInt16)">
            <summary>
            Get a random unsigned short integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Next">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt32">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt32(System.Int32)">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt32(System.Int32,System.Int32)">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt32">
            <summary>
            Get a random unsigned 32bit integer
            </summary>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt32(System.UInt32)">
            <summary>
            Get a random unsigned integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt32(System.UInt32,System.UInt32)">
            <summary>
            Get a random unsigned integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt64">
            <summary>
            Get a random long integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt64(System.Int64)">
            <summary>
            Get a random long integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt64(System.Int64,System.Int64)">
            <summary>
            Get a random long integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt64">
            <summary>
            Get a random unsigned long integer
            </summary>
            
            <returns>Random UInt64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt64(System.UInt64)">
            <summary>
            Get a random unsigned long integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt64(System.UInt64,System.UInt64)">
            <summary>
            Get a random unsigned long integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetBytes(System.Int32)">
            <summary>
            Gets bytes of pseudo random
            </summary>
            
            <param name="Size">Size of request</param>
            
            <returns>P-Rand bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetBytes(System.Byte[])">
            <summary>
            Gets bytes of pseudo random
            </summary>
            
            <param name="Data">Array to fill with pseudo random</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetChars(System.Int32)">
            <summary>
            Gets pseudo random chars
            </summary>
            
            <param name="Size">Size of request</param>
            
            <returns>P-Rand chars</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetByteRange(System.Int64)">
            <remarks>
            Returns the number of bytes needed to build 
            an integer existing within a byte range
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetBits(System.Byte[],System.Int64)">
            <remarks>
            If you need a dice roll, use the Random class (smaller range = reduced entropy)
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Name">
            <summary>
            Get: Algorithm Name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512">
            <summary>
            <h3>SHA512: An implementation of the SHA-2 digest with a 512 bit digest return size.</h3>
            <para>The SHA-2<cite>Fips 180-4</cite> 512 digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new SHA512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 128 bytes, (1024 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA-2 <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.#ctor">
            <summary>
            Initialize the digest
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA256 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value [64 bytes]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value, Always 64 bytes</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1">
            <summary>
            <h3>An implementation of a Quadratic Congruential Generator I random number generator: QCG-I</h3>
            <para>Implements QCGI as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.2</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new QCG1())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">QuadraidResidue1Prng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="P">Random Prime with probability &lt; 2 ** -100</param>
            <param name="G">Random Generator State</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng">
            <summary>
            <h3>CTRPrng: An implementation of a Encryption Counter based Deterministic Random Number Generator.</h3>
            <para>A Block Cipher Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90B</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IRandom</c> interface:</description>
            <code>
            int num;
            using (IRandom rnd = new CTRPrng([BlockCiphers], [SeedGenerators]))
            {
                // get random int
                num = rnd.Next([Minimum], [Maximum]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/09" version="1.4.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Seed">VTDev.Libraries.CEXEngine.Crypto.Seed ISeed Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers">VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with any block <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers">cipher</see>.</description></item>
            <item><description>Can use either a random seed generator for initialization, or a user supplied Seed array.</description></item>
            <item><description>Numbers generated with the same seed will produce the same random output.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-90B: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">Recommendation for the Entropy Sources Used for Random Bit Generation</see>.</description></item>
            <item><description>NIST Fips 140-2: <see href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Security Requirments For Cryptographic Modules</see>.</description></item>
            <item><description>NIST SP800-22 1a: <see href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</see>.</description></item>
            <item><description>Security Bounds for the NIST Codebook-based: <see href="http://eprint.iacr.org/2006/379.pdf">Deterministic Random Bit Generator</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.#ctor(VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers,VTDev.Libraries.CEXEngine.Crypto.Enumeration.SeedGenerators,System.Int32,System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BlockEngine">The block cipher that powers the rng (default is RDX)</param>
            <param name="SeedEngine">The Seed engine used to create keyng material (default is CSPRsg)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            <param name="KeySize">The key size (in bytes) of the symmetric cipher; a <c>0</c> value will auto size the key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.#ctor(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers,System.Int32)">
            <summary>
            Initialize the class with a Seed; note: the same seed will produce the same random output
            </summary>
            
            <param name="Seed">The Seed bytes used to initialize the digest counter; (min. length is key size + counter 16)</param>
            <param name="BlockEngine">The block cipher that powers the rng (default is RDX)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if the seed is null or too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">
            <summary>
            Wraps exceptions thrown within a Asymmetric cipher operational context.
            <para>This exception is used throughout the Asymmetric cipher domain.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ModularResultant">
            <summary>
            A resultant modulo a <c>BigInteger</c>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.Resultant">
            <summary>
            Contains a resultant and a polynomial <c>rho</c> such that <c>res = rho*this + t*(x^n-1) for some integer t</c>.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.Resultant.Rho">
            <summary>
            A polynomial such that <c>res = rho*this + t*(x^n-1) for some integer t</c>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.Resultant.Res">
            <summary>
            Resultant of a polynomial with <c>x^n-1</c>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.Resultant.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Stores the Rho and resultant values
            </summary>
            
            <param name="Rho">A polynomial such that <c>res = rho*this + t*(x^n-1) for some integer t</c></param>
            <param name="Res">A polynomial with <c>x^n-1</c> </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.Resultant.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ModularResultant.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Instantiate the class
            </summary>
            
            <param name="Rho">Rho code</param>
            <param name="Res">Resultant</param>
            <param name="Modulus">Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ModularResultant.CombineRho(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ModularResultant,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ModularResultant)">
            <summary>
            Calculates a <c>rho</c> modulo <c>m1*m2</c> from two resultants whose 
            <c>rho</c>s are modulo <c>m1</c> and <c>m2</c>.
            <para><c>res</c> is set to <c>null</c>.</para>
            </summary>
            
            <param name="ModRes1">M1 resultant</param>
            <param name="ModRes2">M2 resultant</param>
            
            <returns><c>Rho</c> modulo <c>modRes1.modulus * modRes2.modulus</c>, and <c>null</c> for <c>res</c></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial">
            <summary>
            A polynomial with BigDecimal coefficients.
            <para>Some methods (like <c>Add</c>) change the polynomial, others (like <c>Mult</c>) do not,
            but return the result as a new polynomial.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Coeffs">
            <summary>
            Should be marked as internal
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.#ctor(System.Int32)">
            <summary>
            Constructs a new polynomial with <c>N</c> coefficients initialized to 0
            </summary>
            
            <param name="N">The number of coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigDecimal[])">
            <summary>
            Constructs a new polynomial with a given set of coefficients
            </summary>
            <param name="Coeffs">The coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Clear">
            <summary>
            Clear the Coefficients
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Halve">
            <summary>
            Divides all coefficients by 2
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial)">
            <summary>
            Adds another polynomial which can have a different number of coefficients.
            </summary>
            
            <param name="B">The polynomial to add</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Round">
            <summary>
            Rounds all coefficients to the nearest integer
            </summary>
            
            <returns>A new polynomial with <c>BigInteger</c> coefficients</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Clone">
            <summary>
            Makes a copy of the polynomial that is independent of the original
            </summary>
            
            <returns>Cloned copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial by another, taking the indices mod N.
            <para>Does not change this polynomial but returns the result as a new polynomial.
            Both polynomials must have the same number of coefficients.
            This method uses the <a href="http://en.wikipedia.org/wiki/Schönhage–Strassen_algorithm"/> 
            Schönhage–Strassen algorithm.</para>
            </summary>
            
            <param name="Factor">Multiplication factor</param>
            
            <returns>Multiplied polynomial</returns>
            
            <exception cref="!:NTRUException">Thrown if the two polynomials differ in the number of coefficients</exception>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512">
            <summary>
            <h3>Blake512: An implementation of the Blake digest with a 512 bit return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Blake<cite>Blake</cite> digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Blake512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 Proposal <see href="https://131002.net/blake">Blake</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            <item><description>SHA3 Submission in C: <see href="https://131002.net/blake/blake_ref.c">blake_ref.c</see>.</description></item>
            <item><description>The: <see href="http://hashlib.codeplex.com/">HashLib</see> Project (test vectors).</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent project by Dominik Reichl: <see href="http://www.codeproject.com/Articles/286937/BlakeSharp-A-Csharp-Implementation-of-the-BLAKE-Ha">Blake Sharp</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg">
            <summary>
            <h3>SP20Drbg: A parallelized Salsa20 deterministic random byte generator implementation.</h3>
            <para>A Salsa20 key stream, parallelized and extended to use up to 30 rounds of diffusion.</para>
            </summary>
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new SP20Drbg())
            {
                // initialize
                rnd.Initialize(Salt, [Ikm], [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/14" version="1.4.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 256 (16 and 32 bytes).</description></item>
            <item><description>Block size is 64 bytes wide.</description></item>
            <item><description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description></item>
            <item><description>Parallel block size is 64,000 bytes by default; but is configurable.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Salsa20 <see href="http://www.ecrypt.eu.org/stream/salsa20pf.html">Specification</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/design.pdf">Design</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/security.pdf">Security</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.LegalRounds"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null or invalid salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if an invalid or null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Nonce value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if an invalid or null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Update(System.Byte[])">
            <summary>
            <para>Update the Seed material. Two state Seed paramater: 
            If Seed size is equal to cipher key size plus iv size, both are updated. 
            If Seed size is equal to counter size (8 bytes) counter is updated.</para>
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.KeySize">
            <summary>
            <para>The key size (in bytes) of the symmetric cipher</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.LegalSeedSizes">
            <summary>
            Get: Available Seed Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if parallel block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ProcessorCount">
            <remarks>
            Get: Processor count
            </remarks>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Rounds">
            <summary>
            Get: Number of rounds
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes">
            <summary>
            <para>Block cipher sizes in bits. Can be cast as Block byte size integers, 
            i.e. (int sz = BlockSizes.B512) is equal to 64.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes.B128">
            <summary>
            128 bit block size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes.B256">
            <summary>
            256 bit block size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes.B512">
            <summary>
            512 bit block size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes.B1024">
            <summary>
            1024 bit block size
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM">
            <summary>
            <h3>RSM: An implementation based on the Rijndael and Serpent Merged block ciphers, extended with an HKDF powered Key Schedule.</h3>
            <para>RSM is the Rijndael<cite>Rijndael</cite> and Serpent<cite>Serpent</cite> ciphers, merged within the rounds function.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RSM()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block sizes are 16 and 32 byte wide.</description></item>
            <item><description>Valid Rounds assignments are 10, 18, 26, 34 and 42, default is 18.</description></item>
            </list>
            
            <para>The transform combines the two ciphers within the rounds function processing loop. 
            In the Transform functions rounds loop, a round of Serpent is processed; the permuted product of that transformation is then transformed again by a full round of Rijndael.
            This alternating of state transformations between two very strong cryptographic primitives, both creates a highly diffused output, and a cipher 
            that is very resistant to differential cryptanalysis.</para>
            
            <para>The key schedule in RSM powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. 
            HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            RSM is capable of processing up to 42 rounds, that is three times the number of rounds used in an implementation of AES-256. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</see>.</description></item>
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class, 
            and the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalRounds"/> property contains available sizes. Default is 18 rounds.</param>
            <param name="Block">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalBlockSizes"/> property contains available sizes. Default is 16 bytes.</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid block size or invalid rounds count are used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and set state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LinearTransform(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Apply the linear transformation to the register set
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.InverseTransform(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Apply the inverse of the linear transformation to the register set
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.BigIntUtils">
            <summary>
            This class is a utility class for manipulating <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/> arrays
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.BigIntUtils.Equals(VTDev.Libraries.CEXEngine.Numeric.BigInteger[],VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Checks if two <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/> arrays contain the same entries
            </summary>
            
            <param name="A">The first BigInteger array</param>
            <param name="B">The second BigInteger array</param>
            
            <returns>Returns A[] is equal to B[]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.BigIntUtils.Fill(VTDev.Libraries.CEXEngine.Numeric.BigInteger[],VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Fill the given <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/> array with the given value
            </summary>
            
            <param name="A">The BigInteger array</param>
            <param name="Value">The BigInteger value</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.BigIntUtils.SubArray(VTDev.Libraries.CEXEngine.Numeric.BigInteger[],System.Int32,System.Int32)">
            <summary>
            Generates a subarray of a given <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/> array
            </summary>
            
            <param name="Input">The input BigInteger array</param>
            <param name="Start">The start index</param>
            <param name="End">The end index</param>
            
            <returns>Returns a subarray of <c>input</c>, ranging from <c>Start</c> to <c>End</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.BigIntUtils.ToIntArray(VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Converts a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/> array into an integer array
            </summary>
            
            <param name="Input">The BigInteger array</param>
            
            <returns>Returns the integer array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.BigIntUtils.ToIntArrayModQ(System.Int32,VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Converts a BigInteger array into an integer array, reducing all BigIntegers mod q
            </summary>
            
            <param name="Q">The modulus</param>
            <param name="Input">The BigInteger array</param>
            
            <returns>Returns the integer array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.BigIntUtils.ToMinimalByteArray(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Return the value of <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/> as a byte array
            </summary>
            
            <param name="Value">The <c>BigInteger</c> value to be converted to a byte array</param>
            
            <returns>Returns the value <c>big</c> as byte array</returns>
            
            <remarks>
            <para>Although BigInteger has such a method, it uses an extra bit to indicate the sign of the number.
            For elliptic curve cryptography, the numbers usually are positive.
            Thus, this helper method returns a byte array of minimal length, ignoring the sign of the number.</para>
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BigMath">
            <summary>
            Class of number-theory related functions for use with integers represented as <c>int</c>'s or <c>BigInteger</c> objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Binomial(System.Int32,System.Int32)">
            <summary>
            Computes the binomial coefficient (n|t)
            </summary>
            
            <param name="X">The upper integer</param>
            <param name="T">The lower integer</param>
            
            <returns>Returns the binomialcoefficient (n|t) as BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.BitCount(System.Int32)">
            <summary>
            Get the number of ones in the binary representation of an integer <c>A</c>
            </summary>
            
            <param name="X">n integer</param>
            
            <returns>Returns the number of ones in the binary representation of an integer <c>A</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.CeilLog(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Compute the smallest integer that is greater than or equal to the logarithm to the base 2 of the given BigInteger
            </summary>
            
            <param name="X">The BigInteger</param>
            
            <returns>Returns <c>ceil[log(a)]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.CeilLog(System.Int32)">
            <summary>
            Compute the smallest integer that is greater than or equal to the logarithm to the base 2 of the given integer
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns <c>ceil[log(a)]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.CeilLog256(System.Int32)">
            <summary>
            Compute <c>ceil(log_256 n)</c>, the number of bytes needed to encode the integer <c>N</c>
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns the number of bytes needed to encode <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.CeilLog256(System.Int64)">
            <summary>
            Compute <c>ceil(log_256 n)</c>, the number of bytes needed to encode the long integer <c>N</c>
            </summary>
            
            <param name="X">The long integer</param>
            
            <returns>Returns the number of bytes needed to encode <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.DivideAndRound(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Divide two BigIntegers and return the rounded result
            </summary>
            
            <param name="A">The first BigInteger</param>
            <param name="B">The second BigInteger</param>
            
            <returns>The rounded result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.DivideAndRound(VTDev.Libraries.CEXEngine.Numeric.BigInteger[],VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Divide two BigInteger arrays and return the rounded result
            </summary>
            
            <param name="A">The first BigInteger array</param>
            <param name="B">The second BigInteger array</param>
            
            <returns>The rounded result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ExtGcd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Extended euclidian algorithm (computes Gcd and representation)
            </summary>
            
            <param name="A">The first BigInteger</param>
            <param name="B">The second BigInteger</param>
            
            <returns>Returns <c>(d,u,v)</c>, where <c>d = Gcd(A,B) = ua + vb</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ExtGCD(System.Int32,System.Int32)">
            <summary>
            Extended euclidian algorithm (computes gcd and representation)
            </summary>
            
            <param name="A">The first integer</param>
            <param name="B">The second integer</param>
            
            <returns>Returns <c>(g,u,v)</c>, where <c>g = Gcd(Abs(A),Abs(B)) = ua + vb</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.FloatLog(System.Single)">
            <summary>
            Calculation of a logarithmus of a float param
            </summary>
            
            <param name="X">The float value</param>
            
            <returns>Returns <c>Log(A)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.FloatPow(System.Single,System.Int32)">
            <summary>
            Returns the int power of a base float, only use for small ints
            </summary>
            
            <param name="X">The float value</param>
            <param name="E">The exponent</param>
            
            <returns>Returns <c>A^E</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.FloorLog(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Compute the integer part of the logarithm to the base 2 of the given integer
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns floor[log(a)]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.FloorLog(System.Int32)">
            <summary>
            Compute the integer part of the logarithm to the base 2 of the given integer
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns floor[log(a)]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Gcd(System.Int32,System.Int32)">
            <summary>
            Computes the greatest common divisor of the two specified integers
            </summary>
            
            <param name="A">The first integer</param>
            <param name="B">The  second integer</param>
            
            <returns>Returns <c>Gcd(a, b)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IntRoot(System.Int32,System.Int32)">
            <summary>
            Takes an approximation of the root from an integer base, using newton's algorithm
            </summary>
            
            <param name="X">The base to take the root from</param>
            <param name="Root">The root, for example 2 for a square root</param>
            
            <returns>Returns the integers base root</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IntToOctets(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Convert a BigInteger to bytes
            </summary>
            
            <param name="X">The BigInteger</param>
            
            <returns>Returns the BigInteger as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IsIncreasing(System.Int32[])">
            <summary>
            Tests if the integers are incrementing
            </summary>
            
            <param name="A">The array to test</param>
            
            <returns>Returns <c>true</c> if array values are incrementing</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IsPower(System.Int32,System.Int32)">
            <summary>
            Tests whether an integer <c>a</c> is power of another integer <c>P</c>
            </summary>
            
            <param name="X">The first integer</param>
            <param name="P">The second integer</param>
            
            <returns>Returns n if A = P^n or -1 otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IsPrime(System.Int32)">
            <summary>
            Miller-Rabin-Test, determines wether the given integer is probably prime or composite.
            <para>This method returns <c>true</c> if the given integer is prime with probability <c>1 - 2^-20</c>.</para>
            </summary>
            
            <param name="X">The integer to test for primality</param>
            
            <returns>Returns <c>true</c> if the given integer is prime with probability 2*-100, otherwise <c>false</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IsSmallPrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Short trial-division test to find out whether a number is not prime.
            <para>This test is usually used before a Miller-Rabin primality test.</para>
            </summary>
            
            <param name="Candidate">he number to test</param>
            
            <returns>Returns <c>true</c> if the number has no factor of the tested primes, <c>false</c> if the number is definitely composite</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Jacobi(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the value of the Jacobi symbol (A|B). 
            </summary>
            
            <param name="A">The integer value</param>
            <param name="B">The integer value</param>
            
            <returns>Returns value of the jacobi symbol (A|B)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Lcm(VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Computation of the least common multiple of a set of BigIntegers
            </summary>
            
            <param name="Numbers">The set of numbers</param>
            
            <returns>Returns the lcm(Numbers)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.LeastDiv(System.Int32)">
            <summary>
            Find and return the least non-trivial divisor of an integer <c>A</c>
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns divisor p &gt;1 or 1 if A = -1,0,1</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Log(System.Double)">
            <summary>
            Calculates the logarithm to the base 2
            </summary>
            
            <param name="X"> double value</param>
            
            <returns>Returns log_2(x)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Log(System.Int64)">
            <summary>
            Calculate the logarithm to the base 2
            </summary>
            
            <param name="X">Any long value &gt;=1</param>
            
            <returns>Returns <c>log_2(x)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.MaxPower(System.Int32)">
            <summary>
            Compute the largest <c>h</c> with <c>2^h | A</c> if <c>A!=0</c>
            </summary>
            
            <param name="X">An integer</param>
            
            <returns>Returns the largest <c>h</c> with <c>2^h | A</c> if <c>A!=0</c>, <c>0</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Mod(System.Int64,System.Int64)">
            <summary>
            Returns a long integer whose value is <c>(A mod M</c>). 
            <para>This method differs from <c>%</c> in that it always returns a <c>non-negative</c> integer.</para>
            </summary>
            
            <param name="X">The value on which the modulo operation has to be performed</param>
            <param name="M">The modulus.</param>
            
            <returns>Returns <c>A mod M</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ModInverse(System.Int32,System.Int32)">
            <summary>
            Computes the modular inverse of an integer A
            </summary>
            
            <param name="X">The integer to invert</param>
            <param name="Mod">The modulus</param>
            
            <returns>Returns <c>A<sup>-1</sup> Mod n</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ModInverse(System.Int64,System.Int64)">
            <summary>
            Computes the modular inverse of an integer A
            </summary>
            
            <param name="X">The integer to invert</param>
            <param name="Mod">The modulus</param>
            
            <returns>Returns <c>A<sup>-1</sup> Mod n</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ModPow(System.Int32,System.Int32,System.Int32)">
            <summary>
            Compute <c>A^E mod N</c>
            </summary>
            
            <param name="X">The base</param>
            <param name="E">The exponent</param>
            <param name="N">The modulus</param>
            
            <returns>Returns <c>A<sup>E</sup> mod N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.NextPrime(System.Int64)">
            <summary>
            Computes the next prime greater than N
            </summary>
            
            <param name="X">An integer number</param>
            
            <returns>Returns the next prime greater than <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.NextProbablePrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Compute the next probable prime greater than <c>N</c> with the specified certainty
            </summary>
            
            <param name="X">An integer number</param>
            <param name="Certainty">The certainty that the generated number is prime</param>
            
            <returns>Returns the next prime greater than <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.NextProbablePrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Compute the next probable prime greater than <c>N</c> with the default certainty (20)
            </summary>
            
            <param name="X">An integer number</param>
            
            <returns>The next prime greater than <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.NextSmallerPrime(System.Int32)">
            <summary>
            Returns the largest prime smaller than the given integer
            </summary>
            
            <param name="X"> upper bound</param>
            
            <returns>Returns the largest prime smaller than <c>N</c>, or <c>1</c> if <c>N &lt;= 2</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.OctetsToInteger(System.Byte[])">
            <summary>
            Create a BigInteger from a byte array
            </summary>
            
            <param name="Data">The source byte array</param>
            
            <returns>Returns the BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.OctetsToInteger(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a BigInteger from a byte array
            </summary>
            
            <param name="Data">The source byte array</param>
            <param name="Offset">The starting offset within the array</param>
            <param name="Length">The number of bytes used to create the BigInteger</param>
            
            <returns>Returns the BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Order(System.Int32,System.Int32)">
            <summary>
            Determines the order of G modulo P, P prime and 1 &lt; g &lt; p; This algorithm is only efficient for small P
            </summary>
            
            <param name="G">An integer with 1 &lt; G &lt; P</param>
            <param name="P">The prime</param>
            
            <returns>Returns the order k of g (that is k is the smallest integer with G^k = 1 mod P</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Pow(System.Int32,System.Int32)">
            <summary>
            Compute <c>A^E</c>
            </summary>
            
            <param name="X">The base</param>
            <param name="E">The exponent</param>
            
            <returns>Returns <c>A^E</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Pow(System.Int64,System.Int32)">
            <summary>
            Compute <c>A^E</c>
            </summary>
            
            <param name="X">The base</param>
            <param name="E">The exponent</param>
            
            <returns>Returns <c>A^E</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Randomize(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Create a random BigInteger
            </summary>
            
            <param name="UpperBound">The upper bound</param>
            
            <returns>A random BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ReduceInto(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Reduces an integer into a given interval
            </summary>
            
            <param name="X">The integer</param>
            <param name="Begin">Left bound of the interval</param>
            <param name="End">Right bound of the interval</param>
            
            <returns>Returns <c>N</c> reduced into <c>[Begin,End]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Ressol(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the square root of a BigInteger modulo a prime employing the Shanks-Tonelli algorithm
            </summary>
            
            <param name="X">The value out of which we extract the square root</param>
            <param name="P">The prime modulus that determines the underlying field</param>
            
            <returns>Returns a number <c>B</c> such that B^2 = A (mod P) if <c>A</c> is a quadratic residue modulo <c>P</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Randomize(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            Create a random BigInteger
            </summary>
            
            <param name="UpperBound">The upper bound</param>
            <param name="SecRnd">An instance of the SecureRandom class</param>
            
            <returns>A random BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.SquareRoot(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Extract the truncated square root of a BigInteger
            </summary>
            
            <param name="X">A value out of which we extract the square root</param>
            
            <returns>Returns the truncated square root of <c>a</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.LogBKM(System.Double)">
            <summary>
            BKM Algorithm to calculate logarithms to the base 2
            </summary>
            
            <param name="X"> double value with 1&lt;= arg&lt;= 4.768462058</param>
            
            <returns>Returns log_2(arg)</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            <h3>This class represents immutable arbitrary precision decimal numbers</h3>
            
            
            <description>Immutable, arbitrary-precision signed decimal numbers.</description> 
            <para>A BigDecimal consists of an arbitrary precision integer unscaled valueand a 32-bit integer scale.  
            If zero or positive, the scale is the number of digits to the right of the decimal point.  
            If negative, the unscaled value of the number is multiplied by ten to the power of the negation of the scale.  
            The value of the number represented by the BigDecimal is therefore (unscaledValue times; 10 pow -scale).</para>
            </summary>
            
            <example>
            <description>Creating a BigDecimal:</description>
            <code>
            BigDecimal p = BigDecimal(bigInt);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.2.0">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <para>The BigDecimal class provides operations for arithmetic, scale manipulation, rounding, comparison, hashing, and format conversion.  
            The ToString() method provides a canonical representation of a BigDecimal.</para>
            
            <para>The BigDecimal class gives its user complete control over rounding behavior.  
            If no rounding mode is specified and the exact result cannot be represented, an exception is thrown;
            otherwise, calculations can be carried out to a chosen precision and rounding mode by supplying an appropriate MathContext object to the operation.  
            In either case, eight rounding modes are provided for the control of rounding.  
            Using the integer fields in this class (such as HalfUp) to represent rounding mode is largely obsolete; 
            the enumeration values of the RoundingMode enum, (such as HalfUp) should be used instead.</para>
            
            <para>When a MathContext object is supplied with a precision setting of 0 (for example, Unnecessary), arithmetic operations are exact, 
            as are the arithmetic methods which take no MathContext object. 
            As a corollary of computing the exact result, the rounding mode setting of a MathContext object with a precision setting of 0 is not used and thus irrelevant.  
            In the case of divide, the exact quotient could have an infinitely long decimal expansion; for  example, 1 divided by 3.  
            If the quotient has a nonterminating decimal expansion and the operation is specified to return an exact result, an ArithmeticException is thrown.  
            Otherwise, the exact result of the division is returned, as done for other operations.</para>
            
            <para>When the precision setting is not 0, the rules of BigDecimal arithmetic are broadly compatible with selected 
            modes of operation of the arithmetic defined in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4).  
            Unlike those standards, BigDecimal includes many rounding modes. Any conflicts between these ANSI standards and the BigDecimal specification are resolved in favor of BigDecimal.</para>
            
            <para>Since the same numerical value can have different representations (with different scales), the rules of arithmetic
            and rounding must specify both the numerical result and the scale used in the result's representation.</para>
            
            <para>In general the rounding modes and precision setting determine how operations return results with a limited number of digits when
            the exact result has more digits (perhaps infinitely many in the case of division) than the number of digits returned.</para>
            
            <para>First, the total number of digits to return is specified by the MathContext's Precision} setting; this determines the result's <c>Precision</c>.  
            The digit count starts from the leftmost nonzero digit of the exact result.  The rounding mode determines how any discarded trailing digits affect the returned result.</para>
            
            <para>For all arithmetic operators , the operation is carried out as though an exact intermediate result were first calculated and then
            rounded to the number of digits specified by the precision setting (if necessary), using the selected rounding mode.  
            If the exact result is not returned, some digit positions of the exact result are discarded.  
            When rounding increases the magnitude of the returned result, it is possible for a new digit position to be created by a carry propagating to a leading "9" digit.
            For example, rounding the value 999.9 to three digits rounding up would be numerically equal to one thousand, represented as <c>100 times 10 pow 1</c>.  
            In such cases, the new "1" is the leading digit position of the returned result.</para>
            
            <para>Besides a logical exact result, each arithmetic operation has a preferred scale for representing a result.  
            The preferred scale for each operation is listed in the table below.</para>
            
            <description>Preferred Scales for Results of Arithmetic Operations</description>
            <list type="table">
            <item><description>Operation: Preferred Scale of Result</description></item>
            <item><description>Add: Max(Addend.Scale(), Augend.Scale())</description></item>
            <item><description>Subtract: Max(Minuend.Scale(), Subtrahend.Scale())</description></item>
            <item><description>Multiply: Multiplier.Scale() + Multiplicand.Scale()</description></item>
            <item><description>Divide: Dividend.Scale() - Divisor.Scale()</description></item>
            </list>
            
            <para>These scales are the ones used by the methods which return exact arithmetic results; 
            except that an exact divide may have to use a larger scale since the exact result may have more digits.  
            For example, <c>1/32</c> is <c>0.03125</c>.</para>
            
            <para>Before rounding, the scale of the logical exact intermediate result is the preferred scale for that operation.  
            If the exact numerical result cannot be represented in Precision digits, rounding selects the set of digits to return and the scale
            of the result is reduced from the scale of the intermediate result to the least scale which can represent the Precision digits actually returned. 
            If the exact result can be represented with at most Precision digits, the representation of the result with the scale closest to the preferred scale is returned.  
            In particular, an exactly representable quotient may be represented in fewer than Precision digits by removing trailing zeros and decreasing the scale.  
            For example, rounding to three digits using the Floor rounding mode.</para>
            
            <para>Note that for add, subtract, and multiply, the reduction in scale will equal the number of digit positions of the exact result which are discarded. 
            If the rounding causes a carry propagation to create a new high-order digit position, an additional digit of the result is discarded than when no new digit position is created.</para>
            
            <para>Other methods may have slightly different rounding semantics.
            For example, the result of the Pow method using the Pow(int, MathContext) specified algorithm can occasionally differ from the rounded mathematical result by more
            than one unit in the last place, one Ulp.</para>
            
            <para>Two types of operations are provided for manipulating the scale of a BigDecimal: scaling/rounding operations and decimal point motion operations.  
            Scaling/rounding operations SetScale and Round}) return a BigDecimal whose value is approximately (or exactly) equal
            to that of the operand, but whose scale or precision is the specified value; that is, they increase or decrease the precision
            of the stored number with minimal effect on its value.  
            Decimal point motion operations (MovePointLeft and MovePointRight) return a BigDecimal created from the operand by moving the decimal point a specified distance in the specified direction.</para>
            
            Each BigDecimal instance is represented with a unscaled arbitrary precision mantissa (the unscaled value) and a scale. 
            <para>The value of the "BigDecimal is <see cref="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.UnScaledValue"/> 10^(-<see cref="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Scale"/>).
            Since the ToString() method is overriden by this class and it changes the state of the object causing Heisenbugs
            for debuggability we add the attribute DebuggerDisplay that points to a method that doesn't change it.</para>
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Zero">
            <summary>
            The constant zero as a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.One">
            <summary>
            The constant one as a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Ten">
            <summary>
            The constant ten as a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#cctor">
            <summary>
            Initializes static members of the BigDecimal class.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Char[],System.Int32,System.Int32)">
            <summary>
            Translates a character array representation of a BigDecimal into a BigDecimal, 
            accepting the same sequence of characters as the BigDecimal(String) constructor,
            while allowing a sub-array to be specified.
            <para>Note that if the sequence of characters is already available within a character array, 
            using this constructor is faster than converting the char array to string and using the BigDecimal(String) constructor.</para>
            </summary>
            
            <param name="Data">Array that is the source of characters</param>
            <param name="Offset">Offset first character in the array to inspect.</param>
            <param name="Length">Number of characters to consider.</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null data array is passed</exception>
            <exception cref="T:System.FormatException">Thrown if an invalid char array is passed, or scale is out of range</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Char[],System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Translates a character array representation of a BigDecimal into a BigDecimal,
            accepting the same sequence of characters as the BigDecimal(String)constructor,
            while allowing a sub-array to be specified and with rounding according to the context settings.
            <para>Note that if the sequence of characters is already available within a character array,
            using this constructor is faster than converting the char array to string and using the BigDecimal(String) constructor.</para>
            </summary>
            
            <param name="Data">The source of characters used to build the BigDecimal</param>
            <param name="Offset">Offset of the first character in the array to inspect</param>
            <param name="Length">Number of characters to consider</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Char[])">
            <summary>
            Translates a character array representation of a BigDecimal into a BigDecimal,
            accepting the same sequence of characters as the BigDecimal(String)constructor,
            while allowing a sub-array to be specified and with rounding according to the context settings.
            <para>Note that if the sequence of characters is already available within a character array,
            using this constructor is faster than converting the char array to string and using the BigDecimal(String) constructor.</para>
            </summary>
            
            <param name="Data">The source of characters used to build the BigDecimal</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Char[],VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Translates a character array representation of a BigDecimal into a BigDecimal,
            accepting the same sequence of characters as the BigDecimal(String)constructor,
            while allowing a sub-array to be specified and with rounding according to the context settings.
            <para>Note that if the sequence of characters is already available within a character array,
            using this constructor is faster than converting the char array to string and using the BigDecimal(String) constructor.</para>
            </summary>
            
            <param name="Data">The source of characters used to build the BigDecimal</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String)">
            <summary>
            Translates a string representation of a BigDecimal into a BigDecimal
            </summary>
            
            <param name="Value">The source string used to build the BigDecimal</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Translates a string representation of a BigDecimal into a BigDecimal
            </summary>
            
            <param name="Value">The source string used to build the BigDecimal</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Double)">
            <summary>
            Constructs a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance from the 64bit double value. 
            <para>The constructed big decimal is equivalent to the given double.</para>
            </summary>
            
            <param name="Value">The double value to be converted to a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance</param>
            
            <remarks>
            For example, <c>new BigDecimal(0.1)</c> is equal to <c>0.1000000000000000055511151231257827021181583404541015625</c>. 
            This happens as <c>0.1</c> cannot be represented exactly in binary.
            <para>To generate a big decimal instance which is equivalent to <c>0.1</c> use the <see cref="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String)"/> constructor.</para>
            </remarks>
            
            <exception cref="T:System.FormatException">Thown if <paramref name="Value"/> is infinity or not a number.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Double,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance from the 64bit double value. 
            <para>The constructed big decimal is equivalent to the given double.</para>
            </summary>
            
            <param name="Value">The double value to be converted to a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance.</param>
            <param name="Context">The context to use</param>
            
            <remarks>
            For example, <c>new BigDecimal(0.1)</c> is equal to <c>0.1000000000000000055511151231257827021181583404541015625</c>. 
            This happens as <c>0.1</c> cannot be represented exactly in binary.
            <para>To generate a big decimal instance which is equivalent to <c>0.1</c> use the <see cref="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String)"/> constructor.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Constructs a new BigDecimal instance from the given BigInteger value.
            <para>The scale of the result is 0</para>
            </summary>
            
            <param name="Value">Value to be converted to a BigDecimal instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new BigDecimal instance from the given BigInteger value.
            <para>The scale of the result is 0</para>
            </summary>
            
            <param name="Value">Value to be converted to a BigDecimal instance</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Constructs a new BigDecimal instance from a given unscaled value and a given scale.
            <para>The value of this instance is 10^-scale</para>
            </summary>
            
            <param name="UnscaledValue">Representing the unscaled value of this BigDecimal instance</param>
            <param name="Scale">Scale of this BigDecimal instance</param>
            
            <exception cref="T:System.NullReferenceException">Throws if UnscaledValue == null</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new BigDecimal instance from a given unscaled value and a given scale.
            <para>The value of this instance is 10^(-scale). 
            The result is rounded according to the specified math context</para>
            </summary>
            
            <param name="UnscaledValue">Representing the unscaled value of this BigDecimal instance</param>
            <param name="Scale">Scale of this BigDecimal instance</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int32)">
            <summary>
            Constructs a new BigDecimal instance from the given int value.
            <para>The scale of the result is 0.</para>
            </summary>
            
            <param name="Value">The int value to be converted to a BigDecimal instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new BigDecimal instance from the given int value.
            <para>The scale of the result is 0. The result is rounded according to the specified math context.</para>
            </summary>
            
            <param name="Value">The int value to be converted to a BigDecimal instance</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int64)">
            <summary>
            Constructs a new BigDecimal instance from the given long value.
            <para>The scale of the result is 0.</para>
            </summary>
            
            <param name="Value">The long value to be converted to a BigDecimal instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int64,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new BigDecimal instance from the given long value.
            <para>The scale of the result is 0.
            The result is rounded according to the specified math context.</para>
            </summary>
            
            <param name="Value">The long value to be converted to a BigDecimal instance</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int64,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> class.
            </summary>
            
            <param name="SmallValue">The small value</param>
            <param name="Scale">The scale</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> class.
            </summary>
            
            <param name="SmallValue">The small value</param>
            <param name="Scale">The scale</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Abs">
            <summary>
            Returns a new BigDecimal whose value is the absolute value of this.
            <para>The scale of the result is the same as the scale of Abs(this).</para>
            </summary>
            
            <returns>
            <c>Abs(this)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Abs(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is the absolute value of this.
            <para>The result is rounded according to the passed context.</para>
            </summary>
            
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>Abs(this)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Add(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Adds a value to the current instance of <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="Augend">The value to be added to this instance</param>
            
            <returns>
            Returns a new BigDecimal whose value is <c>this + <paramref name="Augend"/></c>.
            </returns>
            
            <exception cref="T:System.ArgumentNullException">Thrown if the given <paramref name="Augend"/> is <c>null</c>.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Add(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Adds a value to the current instance of <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            <para>The result is rounded according to the passed context.</para>
            </summary>
            
            <param name="Augend">The value to be added to this instance</param>
            <param name="Context">The rounding mode and precision for the result of this operation</param>
            
            <returns>
            Returns a new BigDecimal whose value is <c>this + <paramref name="Augend"/></c>.
            </returns>
            
            <exception cref="T:System.ArgumentNullException">Thrown if the given <paramref name="Augend"/> or <paramref name="Context"/> is <c>null</c>.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.AddAndMult10(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32)">
            <summary>
            Add and Multiply by 10
            </summary>
            
            <param name="Value">The value to add and multiply</param>
            <param name="Augend">The value to be added</param>
            <param name="DiffScale">The differential scale</param>
            
            <returns>
            The result of the Add and Multiply operation
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.CompareTo(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Compares this BigDecimal with Value.
            <para>Returns one of the three values 1, 0, or -1.
            The method behaves as if Subtract(Value) is computed.
            If this difference is > 0 then 1 is returned, if the difference is &lt; 0 then -1 is returned, 
            and if the difference is 0 then 0 is returned.
            This means, that if two decimal instances are compared which are equal in value but differ in scale, 
            then these two instances are considered as equal.</para>
            </summary>
            <param name="Value">Value to be compared with this</param>
            
            <returns>
            ReturnS 1 if this > Value, -1 if this &lt; Value, 0 if this == Value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>The scale of the result is the difference of the scales of this and Divisor.
            If the exact result requires more digits, then the scale is adjusted accordingly.
            For example, <c>1/128 = 0.0078125</c> which has a scale of 7 and precision 5.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>
            <c>this / divisor</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Divisor == 0 or the result cannot be represented exactly.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>The result is rounded according to the passed context.
            If the passed math context specifies precision 0, then this call is equivalent to <c>Divide(Divisor)</c></para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>this / divisor</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>The scale of the result is the scale of this.
            If rounding is required to meet the specified scale, then the specified rounding mode is applied.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="RoundMode">Rounding mode to be used to round the result</param>
            
            <returns>
            <c>this / divisor</c> rounded according to the given rounding mode
            </returns>
            
            <exception cref="T:System.ArgumentException">Thrown if an invalid rounding mode is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32,System.Int32)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>As scale of the result the parameter Scale is used.
            If rounding is required to meet the specified scale, then the specified rounding mode is applied.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Scale">The scale of the result returned</param>
            <param name="RoundMode">Rounding mode to be used to round the result</param>
            
            <returns>
            <c>this / divisor</c> rounded according to the given rounding mode
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>The scale of the result is the scale of this.
            If rounding is required to meet the specified scale, then the specified rounding mode is applied.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="RoundingMode">Rounding mode to be used to round the result</param>
            
            <returns>
            <c>this / divisor</c> rounded according to the given rounding
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>As scale of the result the parameter Scale is used.
            If rounding is required to meet the specified scale, then the specified rounding mode is applied.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Scale">The scale of the result returned</param>
            <param name="RoundingMode">Rounding mode to be used to round the result</param>
            
            <returns>
            <c>this / divisor</c> rounded according to the given rounding mode
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Divisor == 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideAndRemainder(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a BigDecimal array which contains the integral part of <c>this / divisor</c> at index 0 and the remainder <c>this % divisor</c> at index 1. 
            <para>The quotient is rounded down towards zero to the next integer.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>
            DivideToIntegralValue(Divisor), Remainder(divisor)]
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideAndRemainder(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a BigDecimal array which contains the integral part of <c>this / divisor</c> at index 0 and the remainder at index 1.
            <para>The quotient is rounded down towards zero to the next integer.
            The rounding mode passed with the parameter Context is not considered.
            But if the precision of Context > 0 and the integral part requires more digits, then an ArithmeticException is thrown.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Context">Math context which determines the maximal precision of the result</param>
            
            <returns>
            [DivideToIntegralValue(Divisor), Remainder(Divisor)]
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideToIntegralValue(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is the integral part of <c>this / divisor</c>.
            <para>The quotient is rounded down towards zero to the next integer.
            For example, <c>0.5/0.2 = 2</c>.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>
            Integral part of <c>this / divisor</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Divisor == 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideToIntegralValue(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is the integral part of <c>this / divisor</c>.
            <para>The quotient is rounded down towards zero to the next integer.
            The rounding mode passed with the parameter Context is not considered.
            But if the precision of <c>Context &gt; 0</c> and the integral part requires more digits, 
            then an ArithmeticException is thrown.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Context">Math context which determines the maximal precision of the result</param>
            
            <returns>
            Integral part of <c>this / divisor</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if quotient won't fit in 'Context.Precision()' digits </exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Max(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns the maximum of this BigDecimal and Value
            </summary>
            
            <param name="Value">Value to be used to compute the maximum with</param>
            
            <returns>
            <c>Max(this, Value)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Min(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns the minimum of this BigDecimal and Value
            </summary>
            
            <param name="Value">Value to be used to compute the minimum with</param>
            
            <returns>
            <c>Min(this, val)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.MovePointLeft(System.Int32)">
            <summary>
            Returns a new BigDecimal instance where the decimal point has been moved N places to the left.
            <para>If <c>N &lt; 0</c> then the decimal point is moved -N places to the right.
            The result is obtained by changing its scale.
            If the scale of the result becomes negative, then its precision is increased such that the scale is zero.
            Note, that MovePointLeft(0) returns a result which is mathematically equivalent, but which has scale >= 0.</para>
            </summary>
            
            <param name="N">Number of places the decimal point has to be moved</param>
            
            <returns>
            <c>this * 10^(-N)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.MovePointRight(System.Int32)">
            <summary>
            Returns a new BigDecimal instance where the decimal point has been moved N places to the right. 
            <para>If N &lt; 0 then the decimal point is moved -N places to the left.
            The result is obtained by changing its scale.
            If the scale of the result becomes negative, then its precision is increased such that the scale is zero.
            Note, that MovePointRight(0) returns a result which is mathematically equivalent, but which has scale >= 0.</para>
            </summary>
            
            <param name="N">Number of placed the decimal point has to be moved</param>
            
            <returns>
            <c>this * 10^n</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this * Multiplicand</c>.
            <para>The scale of the result is the sum of the scales of the two arguments</para>
            </summary>
            
            <param name="Multiplicand">Value to be multiplied with this</param>
            
            <returns>
            <c>this * Multiplicand</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>this * multiplicand</c>.
            <para>The result is rounded according to the passed context.</para>
            </summary>
            
            <param name="Multiplicand">Value to be multiplied with this</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>this * multiplicand</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Negate">
            <summary>
            Returns a new BigDecimal whose value is the <c>-this</c>.
            </summary>
            
            <returns>
            <c>-this</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Negate(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is the <c>-this</c>.
            </summary>
            
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            The result is <c>-this</c> rounded according to the passed context
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Plus">
            <summary>
            Returns a new BigDecimal whose value is <c>+this</c>.
            </summary>
            
            <returns>
            <c>+this</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Plus(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>+this</c>.
            </summary>
            
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>+this</c> rounded according to the passed context 
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Pow(System.Int32)">
            <summary>
            Returns a new BigDecimal whose value is <c>this ^ N</c>.
            <para>The scale of the result is N times the scales of this.
            <c>x.pow(0)</c> returns 1, even if x == 0.</para>
            </summary>
            
            <param name="N">Exponent to which this is raised</param>
            
            <returns>
            <c>this ^ N</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if <c>N &lt; 0</c> or <c>N &gt; 999999999</c></exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Pow(System.Int32,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>this ^ N</c>.
            <para>The result is rounded according to the passed context.</para>
            </summary>
            
            <param name="N">Exponent to which this is raised</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>this ^ N</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if <c>N &lt; 0</c> or <c>N &gt; 999999999</c></exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Remainder(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this % divisor</c>.
            <para>The remainder is defined as <c>this - DivideToIntegralValue(Divisor) * Divisor</c>.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>
            <c>this % divisor</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Remainder(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>this % divisor</c>.
            <para>The remainder is defined as <c>this - DivideToIntegralValue(Divisor) * Divisor</c>.
            The specified rounding mode Context is used for the division only.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Context">Rounding mode and precision to be used</param>
            
            <returns>
            <c>this % divisor</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Round(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is this, rounded according to the passed context.
            <para>If Context.Precision = 0, then no rounding is performed.
            If Context.Precision and Context.RoundingMode == UNNECESSARY, then an ArithmeticException 
            is thrown if the result cannot be represented exactly within the given precision.</para>
            </summary>
            
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            This rounded according to the passed context
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ScaleByPowerOfTen(System.Int32)">
            <summary>
            Returns a new BigDecimal whose value is <c>this 10^ N</c>.
            <para>The scale of the result is Scale() - N.
            The precision of the result is the precision of this.
            This method has the same effect as MovePointRight, except that the precision is not changed.</para>
            </summary>
            
            <param name="N">Number of places the decimal point has to be moved</param>
            
            <returns>
            <c>this 10^ N</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SetScale(System.Int32)">
            <summary>
            Returns a new BigDecimal instance with the specified scale.
            <para>If the new scale is greater than the old scale, then additional zeros are added to the unscaled value.
            If the new scale is smaller than the old scale, then trailing zeros are removed.
            If the trailing digits are not zeros then an ArithmeticException is thrown.
            If no exception is thrown, then the following equation holds: <c>x.SetScale(s).CompareTo(x) == 0</c>.</para>
            </summary>
            
            <param name="NewScale">Scale of the result returned</param>
            
            <returns>
            A new BigDecimal instance with the specified scale.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SetScale(System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Returns a new BigDecimal instance with the specified scale.
            <para>If the new scale is greater than the old scale, then additional zeros are added to the unscaled value.
            If the new scale is smaller than the old scale, then trailing digits are removed.
            In this case no rounding is necessary.
            If these trailing digits are not zero, then the remaining unscaled value has to be rounded.
            For this rounding operation the specified rounding mode is used.</para>
            </summary>
            
            <param name="NewScale">Scale of the result returned</param>
            <param name="RoundingMode">Rounding mode to be used to round the result</param>
            
            <returns>
            A new BigDecimal instance with the specified scale
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SetScale(System.Int32,System.Int32)">
            <summary>
            Returns a new BigDecimal instance with the specified scale.
            <para>If the new scale is greater than the old scale, then additional zeros are added to the unscaled value.
            In this case no rounding is necessary.
            If the new scale is smaller than the old scale, then trailing digits are removed.
            If these trailing digits are not zero, then the remaining unscaled value has to be rounded.
            For this rounding operation the specified rounding mode is used.</para>
            </summary>
            
            <param name="NewScale">Scale of the result returned</param>
            <param name="RoundMode">Rounding mode to be used to round the result</param>
            
            <returns>
            A new BigDecimal instance with the specified scale
            </returns>
            
            <exception cref="T:System.ArgumentException">Thrown if RoundMode is not a valid rounding mode</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Signum">
            <summary>
            Returns the sign of this BigDecimal
            </summary>
            
            <returns>
            Returns <c>-1</c> if <c>this &lt; 0</c>, <c>0</c> if <c>this == 0</c>, <c>1</c> if <c>this &gt; 0</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.StripTrailingZeros">
            <summary>
            Returns a new BigDecimal instance with the same value as this but with a 
            unscaled value where the trailing zeros have been removed.
            <para>If the unscaled value of this has n trailing zeros, 
            then the scale and the precision of the result has been reduced by n.
            </para>
            </summary>
            
            <returns>
            A new BigDecimal instance equivalent to this where the trailing zeros of the unscaled value have been removed
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Subtract(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this - subtrahend</c>.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="Subtrahend">Value to be subtracted from this</param>
            
            <returns>
            <c>this - subtrahend</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Subtract(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal}whose value is <c>this - subtrahend</c>.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="Subtrahend">Value to be subtracted from this</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>this - subtrahend</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToBigInteger">
            <summary>
            Returns this BigDecimal as a big integer instance.
            <para>A fractional part is discarded.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a big integer instance
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToBigIntegerExact">
            <summary>
            Returns this BigDecimal as a big integer instance if it has no fractional part.
            <para>If this BigDecimal has a fractional part, i.e. if rounding would be necessary, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            this BigDecimal as a big integer value
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if rounding is necessary</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToByteExact">
            <summary>
            Returns this BigDecimal as a byte value if it has no fractional part and 
            if its value fits to the byte range ([-128..127]).
            <para>If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a byte value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToDouble">
            <summary>
            Returns this BigDecimal as a double value.
            <para>If this is too big to be represented as an float, then Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a double value
            </returns>
            
            <remarks>
            <para>Note, that if the unscaled value has more than 53 significant digits, 
            then this decimal cannot be represented exactly in a double variable.
            In this case the result is rounded.
            For example, if the instance <c>x1 = new BigDecimal("0.1")</c> cannot be 
            represented exactly as a double, and thus <c>x1.Equals(new BigDecimal(x1.ToDouble())</c> 
            returns false for this case.
            Similarly, if the instance <c>new BigDecimal(9007199254740993L)</c>c> is converted to a double, 
            the result is 9.007199254740992E15.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToEngineeringString">
            <summary>
            Returns a string representation of this BigDecimal.
            <para>This representation always prints all significant digits of this value.
            If the scale is negative or if Scale - Precision >= 6 then engineering notation is used.
            Engineering notation is similar to the scientific notation except that the exponent is made to be a multiple of 3 such that the integer part is >= 1 and &lt; 1000.</para>
            </summary>
            
            <returns>
            Returns a string representation of this in engineering notation if necessary
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt16Exact">
            <summary>
            Returns this BigDecimal as a short value if it has no fractional part 
            and if its value fits to the short range ([-2^{15}..2^{15}-1]).
            <para>If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a short value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt32">
            <summary>
            Returns this BigDecimal as an int value.
            <para>If the integral part of this is too big to be represented as an int, then this % 2^32 is returned.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as an int value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt32Exact">
            <summary>
            Returns this BigDecimal as an int value. Any fractional part is discarded.
            <para>Returns this BigDecimal as a int value if it has no fractional part and if 
            its value fits to the int range ([-2^{31}..2^{31}-1]).
            If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            This BigDecimal as a int value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt64">
            <summary>
            Returns this BigDecimal as an long value. Any fractional part is discarded.
            <para>If the integral part of this is too big to be represented as an long, then this % 2^64 is returned.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a long value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt64Exact">
            <summary>
            Returns this BigDecimal as a long value if it has no fractional part and if its value fits to the int range ([-2^{63}..2^{63}-1]).
            <para>If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            this BigDecimal as a long value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToPlainString">
            <summary>
            Returns a string representation of this BigDecimal.
            <para>No scientifi notation is used. This methods adds zeros where necessary.
            If this string representation is used to create a new instance, 
            this instance is generally not identical to this as the precision changes.
            <c>x.Equals(new BigDecimal(x.ToPlainString())</c> usually returns false.
            <c>x.CompareTo(new BigDecimal(x.ToPlainString())} returns 0</c></para>
            </summary>
            
            <returns>
            A string representation of this without exponent part.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToSingle">
            <summary>
            Returns this BigDecimal as a float value.
            <para>If this is too big to be represented as an float, 
            then Float.POSITIVE_INFINITY or Float.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a float value
            </returns>
            
            <remarks>
            <para>Note, that if the unscaled value has more than 24 significant digits, 
            then this decimal cannot be represented exactly in a float variable.
            In this case the result is rounded.
            For example, if the instance <c>x1 = new BigDecimal("0.1")</c> cannot be represented exactly as a float, 
            and thus <c>x1.Equals(new BigDecimal(x1.FloatValue())</c> returns false for this case.
            Similarly, if the instance <c>new BigDecimal(16777217)</c> is converted to a float, the result is 1.6777216E7.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Ulp">
            <summary>
            Returns the unit in the last place (ULP) of this BigDecimal instance.
            <para>An ULP is the distance to the nearest big decimal with the same precision.</para>para>
            </summary>
            
            <returns>
            Returns unit in the last place (ULP) of this BigDecimal instance
            </returns>
            
            <remarks>
            <para>The amount of a rounding error in the evaluation of a floating-point operation is 
            often expressed in ULPs. An error of 1 ULP is often seen as a tolerable error.
            For class BigDecimal, the ULP of a number is simply 10^(-scale).
            For example, {@code new BigDecimal(0.1).ulp()} returns {@code 1E-55}.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ValueOf(System.Double)">
            <summary>
            Returns a new BigDecimal instance whose value is equal to value.
            <para>The new decimal is constructed as if the BigDecimal(String) constructor is called
            with an argument which is equal to Double.toString(val). 
            For example, ValueOf("0.1")} is converted to (unscaled=1, scale=1), although the double 0.1 cannot be
            represented exactly as a double value. In contrast to that, a new BigDecimal(0.1) instance has the value 
            0.1000000000000000055511151231257827021181583404541015625 with an unscaled value 
            1000000000000000055511151231257827021181583404541015625}and the scale 55.</para>
            </summary>
            
            <param name="Value">Double value to be converted to a {@code BigDecimal</param>
            
            <returns>
            BigDecimal instance with the value 
            </returns>
            
            <exception cref="T:System.FormatException">Thrown if Value is infinite or not a number</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ValueOf(System.Int64)">
            <summary>
            Returns a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance whose value is equal to <paramref name="UnscaledVal"/>. 
            <para>The scale of the result is <c>0</c>, and its unscaled value is <paramref name="UnscaledVal"/>.</para>
            </summary>
            
            <param name="UnscaledVal">The value to be converted to a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/></param>
            <returns>
            Returns a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance with the value <paramref name="UnscaledVal"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ValueOf(System.Int64,System.Int32)">
            <summary>
            Returns a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance whose value is equal to 
            <paramref name="UnscaledVal"/> 10^(-<paramref name="Scale"/>). 
            <para>The scale of the result is <see cref="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Scale"/>, and its unscaled value is <see cref="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.UnScaledValue"/>.</para>
            </summary>
            
            <param name="UnscaledVal">The unscaled value to be used to construct the new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/></param>
            <param name="Scale">The scale to be used to construct the new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.</param>
            
            <returns>
            Returns a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance with the value <c>UnscaledVal * 10^(-scale)</c>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.AproxPrecision">
            <summary>
            If the precision already was calculated it returns that value, otherwise it calculates a very good approximation efficiently .
            </summary>
            
            <returns>
            Returns an approximation of Precision() value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.BitLength(System.Int64)">
            <summary>
            The bit length
            </summary>
            
            <param name="SmallValue"> The small value</param>
            
            <returns>
            The <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.BitLength(System.Int32)">
            <summary>
            The bit length
            </summary>
            
            <param name="SmallValue">The small value</param>
            
            <returns>
            The <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideBigIntegers(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Divide big integers
            </summary>
            <param name="ScaledDividend">The scaled dividend</param>
            <param name="ScaledDivisor">The scaled divisor</param>
            <param name="Scale">The scale</param>
            <param name="RoundingMode">The rounding mode</param>
            
            <returns>
            The <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> remainder
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DividePrimitiveLongs(System.Int64,System.Int64,System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Divide primitive longs
            </summary>
            
            <param name="ScaledDividend">The scaled dividend</param>
            <param name="ScaledDivisor">The scaled divisor</param>
            <param name="Scale">The scale</param>
            <param name="RoundingMode">The rounding mode</param>
            
            <returns>
            The <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DoubleToLongBits(System.Double)">
            <summary>
            Convert a double to long
            </summary>
            
            <param name="Value">The value to convert</param>
            
            <returns>
            The long integer value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.GetUnscaledValue">
            <summary>
            The get unscaled value
            </summary>
            <returns>
            The <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.GetZeroScaledBy(System.Int64)">
            <summary>
            It returns the value 0 with the most approximated scale of type int
            </summary>
            
            <param name="LongScale">The scale to which the value 0 will be scaled</param>
            
            <returns>
            The value 0 scaled by the closer scale of type int
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.InplaceRound(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            It does all rounding work of the public method Round(MathContext), performing an inplace rounding without creating a new object.
            </summary>
            
            <param name="Context">MathContext for perform the rounding</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.IsNaN(System.Double)">
            <summary>
            Test if the value is Not a Number
            </summary>
            
            <param name="Value">The value to test</param>
            
            <returns>True if NaN, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.IsNegativeZero(System.Double)">
            <summary>
            Test if the value is negative zero
            </summary>
            
            <param name="Value">The value to test</param>
            
            <returns>True if negative zero, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.IsZero">
            <summary>
            Is BigDecimal zero
            </summary>
            
            <returns>
            True if BigDecimal is zero, otherwise fals
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.LongCompareTo(System.Int64,System.Int64)">
            <summary>
            Compare two longs
            </summary>
            
            <param name="A">The first value</param>
            <param name="B">The second value</param>
            
            <returns>
            Returns 1 for A more than B, -1 for A less B, and 0 for equal
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.MovePoint(System.Int64)">
            <summary>
            Returns a new BigDecimal instance where the decimal point has been moved to the right based on the scale.
            </summary>
            
            <param name="NewScale">Scale of the result returned</param>
            
            <returns>
            BigDecimal
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.RoundingBehavior(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Return an increment that can be -1, 0, or 1, depending of RoundingMode
            </summary>
            
            <param name="ParityBit">Can be 0 or 1, it's only used in the case HALF_EVEN</param>
            <param name="Fraction">The type of rounding Mantisa to be analyzed</param>
            <param name="RoundingMode">The rounding mode</param>
            
            <returns>
            Returns the carry propagated after rounding
            </returns>
            
            <exception cref="T:System.ArithmeticException"></exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SetUnscaledValue(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            The set unscaled value
            </summary>
            <param name="unscaledValue">
            The unscaled value
            </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SmallRound(VTDev.Libraries.CEXEngine.Numeric.MathContext,System.Int32)">
            <summary>
            This method implements an efficient rounding for numbers which unscaled value fits in the type long.
            </summary>
            
            <param name="Context">The context to use</param>
            <param name="DiscardedPrecision">The number of decimal digits that are discarded</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToIntScale(System.Int64)">
            <summary>
            It tests if a scale of type long fits in 32 bits.
            It returns the same scale being casted to int type when is possible, otherwise throws an exception.
            </summary>
            
            <param name="LongScale">A 64 bit scale</param>
            <returns>
            A 32 bit scale when is possible
            </returns>
            
            <exception cref="T:System.ArithmeticException">Throws ArithmeticException when Scale doesn't fit in int type</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToStringInternal">
            <summary>
            The to string internal.
            </summary>
            <returns>
            The <see cref="T:System.String"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ValueExact(System.Int32)">
            <summary>
            Counts the number of bits of value and checks if it's out of the range of the primitive type.
            </summary>
            
            <param name="BitLengthOfType">umber of bits of the type whose value will be calculated</param>
            
            <returns>
            The exact value of the integer part of BigDecimal when is possible
            </returns>
            
            <exception cref="T:System.ArithmeticException">Throws if rounding is necessary or the number don't fit in the primitive type</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Equals(System.Object)">
            <summary>
            Returns true if Obj is a BigDecimal instance and if this instance is equal to this big decimal.
            <para>Two big decimals are equal if their unscaled value and their scale is equal.
            For example, <c>1.0 (10*10^(-1))</c> is not equal to <c>1.00 (100*10^(-2))</c>.
            Similarly, zero instances are not equal if their scale differs.</para>
            </summary>
            
            <param name="Obj">Object to be compared with this</param>
            
            <returns>
            Returns true if Obj is a BigDecimal and this == Obj
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.GetHashCode">
            <summary>
            Returns a hash code for this BigDecimal
            </summary>
            
            <returns>
            Hash code for this
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToString">
            <summary>
            Returns a canonical string representation of this BigDecimal.
            <para>If necessary, scientific notation is used.
            This representation always prints all significant digits of this value.
            If the scale is negative or if Scale - precision >= 6 then scientific notation is used.</para>
            </summary>
            
            <returns>
            Returns a string representation of this in scientific notation if necessary
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> class
            </summary>
            
            <param name="Info">The info</param>
            <param name="Context">The context</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            The get object data
            </summary>
            <param name="Info">The info</param>
            <param name="Context">The context</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Addition(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Add two <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> values.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns a new BigDecimal whose value is <c>A + B</c>.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Subtraction(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>A - B</c>.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns><c>A - B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Division(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>A / B</c>.
            <para>The scale of the result is the difference of the scales of this and Divisor.
            If the exact result requires more digits, then the scale is adjusted accordingly.
            For example, <c>1/128 = 0.0078125</c> which has a scale of 7 and precision 5.</para>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The divisor B</param>
            
            <returns><c>A / B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Modulus(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>A % B</c>.
            <para>The remainder is defined as <c>A - DivideToIntegralValue(B) * B</c>.</para>
            </summary>
            
            <param name="A">The value</param>
            <param name="B">The divisor</param>
            
            <returns><c>A % B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Multiply(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this * Multiplicand</c>.
            <para>The scale of the result is the sum of the scales of the two arguments</para>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The multiplicand</param>
            
            <returns><c>A * B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_UnaryPlus(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>+A</c>.
            </summary>
            
            <param name="A">The value A</param>
            
            <returns><c>+A</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_UnaryNegation(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is the <c>-A</c>.
            </summary>
            
            <param name="A">The value A</param>
            
            <returns><c>-A</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Equality(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if "A" is a BigDecimal instance and if this instance is equal to "B".
            <para>Two big decimals are equal if their unscaled value and their scale is equal.
            For example, 1.0 (10*10^(-1)) is not equal to 1.00 (100*10^(-2)).
            Similarly, zero instances are not equal if their scale differs.</para>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if "B" is a BigDecimal and A == B</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Inequality(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is not equal to BigDecimal "B".
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A != B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_GreaterThan(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is more than BigDecimal value "B"
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A > B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_LessThan(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is less than BigDecimal value "B"
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A &lt; B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_GreaterThanOrEqual(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is more than or equal to BigDecimal value "B"
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A >= B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_LessThanOrEqual(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is less than or equal to BigDecimal value "B"
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A &lt;= B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Int16">
            <summary>
            Returns this BigDecimal as a short value if it has no fractional part 
            and if its value fits to the short range ([-2^{15}..2^{15}-1]).
            <para>If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a short value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Int32">
            <summary>
            Returns this BigDecimal as an int value.
            <para>If the integral part of this is too big to be represented as an int, then this % 2^32 is returned.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as an int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Int64">
            <summary>
            Returns this BigDecimal as an long value. Any fractional part is discarded.
            <para>If the integral part of this is too big to be represented as an long, then this % 2^64 is returned.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a long value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Single">
            <summary>
            Returns this BigDecimal as a float value.
            <para>If this is too big to be represented as an float, 
            then Float.POSITIVE_INFINITY or Float.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a float value</returns>
            
            <remarks>
            <para>Note, that if the unscaled value has more than 24 significant digits, 
            then this decimal cannot be represented exactly in a float variable.
            In this case the result is rounded.
            For example, if the instance <c>x1 = new BigDecimal("0.1")</c> cannot be represented exactly as a float, 
            and thus <c>x1.Equals(new BigDecimal(x1.FloatValue())</c> returns false for this case.
            Similarly, if the instance <c>new BigDecimal(16777217)</c> is converted to a float, the result is 1.6777216E7.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Double">
            <summary>
            Returns this BigDecimal as a double value.
            <para>If this is too big to be represented as an float, then Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a double value</returns>
            
            <remarks>
            <para>Note, that if the unscaled value has more than 53 significant digits, 
            then this decimal cannot be represented exactly in a double variable.
            In this case the result is rounded.
            For example, if the instance <c>x1 = new BigDecimal("0.1")</c> cannot be 
            represented exactly as a double, and thus <c>x1.Equals(new BigDecimal(x1.ToDouble())</c> 
            returns false for this case.
            Similarly, if the instance <c>new BigDecimal(9007199254740993L)</c>c> is converted to a double, 
            the result is 9.007199254740992E15.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~VTDev.Libraries.CEXEngine.Numeric.BigInteger">
            <summary>
            Returns this BigDecimal as a big integer instance.
            <para>A fractional part is discarded.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a BigInteger instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.String">
            <summary>
            Returns a canonical string representation of this BigDecimal.
            <para>If necessary, scientific notation is used.
            This representation always prints all significant digits of this value.
            If the scale is negative or if Scale - precision >= 6 then scientific notation is used.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns a string representation of this in scientific notation if necessary</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(System.Int64)~VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            Constructs a new BigDecimal instance from the given long value.
            <para>The scale of the result is 0.</para>
            </summary>
            
            <param name="Value">The long value to be converted to a BigDecimal instance</param>
            
            <returns>A new BigDecimal instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(System.Double)~VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            Constructs a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance from the 64bit double value. 
            <para>The constructed big decimal is equivalent to the given double.</para>
            </summary>
            
            <param name="Value">The double value to be converted to a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance</param>
            
            <returns>A new BigDecimal instance</returns>
            
            <remarks>
            For example, <c>new BigDecimal(0.1)</c> is equal to <c>0.1000000000000000055511151231257827021181583404541015625</c>. 
            This happens as <c>0.1</c> cannot be represented exactly in binary.
            <para>To generate a big decimal instance which is equivalent to <c>0.1</c> use the <see cref="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String)"/> constructor.</para>
            </remarks>
            
            <exception cref="T:System.FormatException">Thown if <paramref name="Value"/> is infinity or not a number.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(System.Int32)~VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            Constructs a new BigDecimal instance from the given int value.
            <para>The scale of the result is 0.</para>
            </summary>
            
            <param name="Value">The int value to be converted to a BigDecimal instance</param>
            
            <returns>A new BigDecimal instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            Constructs a new BigDecimal instance from the given BigInteger value.
            <para>The scale of the result is 0</para>
            </summary>
            
            <param name="Value">Value to be converted to a BigDecimal instance</param>
            
            <returns>A new BigDecimal instance</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Precision">
            <summary>
            Returns the precision of this BigDecimal.
            <para>The precision is the number of decimal digits used to represent this decimal.
            It is equivalent to the number of digits of the unscaled value.
            The precision of 0 is 1 (independent of the scale).</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Scale">
            <summary>
            Returns the scale of this BigDecimal.
            <para>The scale is the number of digits behind the decimal point.
            The value of this BigDecimal is the unsignedValue * 10^(-scale). 
            If the scale is negative, then this BigDecimal represents a big integer.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.UnScaledValue">
            <summary>
            Returns the unscaled value (mantissa) of this BigDecimal instance as a BigInteger.
            <para>The unscaled value can be computed as this <c>10^(scale)</c>.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">
            <summary>
            Wraps exceptions thrown within a Symmetric cipher operational context.
            <para>This exception is used throughout the Block and Stream cipher domain, including Mode and Padding classes.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">
            <summary>
            Wraps exceptions thrown within a Cryptographic Generator operational context.
            <para>This exception is used throughout the Generator classes.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC">
            <summary>
            <h3>SHA512 Hash based Message Authentication Code Wrapper using SHA-2 512.</h3>
            <para>A SHA512 HMAC as outlined in the NIST document: Fips 198-1<cite>Fips 198-1</cite></para>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new SHA512HMAC(), [DisposeEngine])
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Key size should be equal to digest output size<cite>RFC 2104</cite>; 64 bytes, (512 bits).</description></item>
            <item><description>Block size is 128 bytes, (1024 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.#ctor(System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.ComputeMac(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2104: <see href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</see>.</description></item>
            <item><description>NIST Fips 198-1: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">The Keyed-Hash Message Authentication Code (HMAC)</see>.</description></item>
            <item><description>NIST Fips 180-4: <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Secure Hash Standard (SHS)</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.#ctor(System.Boolean)">
            <summary>
            Initialize the class
            <para>When using this constructor, you must call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> before processing.</para>
            </summary>
            
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Initialize the class and working variables.
            <para>When this constructor is used, <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> is called automatically.</para>
            </summary>
            
            <param name="Key">HMAC Key; passed to HMAC Initialize() through constructor</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException">Thrown if a null Key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA256 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="OutOffset">The offset in the data</param>
            
            <returns>The number of bytes processed</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the HMAC
            </summary>
            
            <param name="KeyParam">KeyParams containing HMAC Key. 
            <para>Uses the Key field of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams"/> class.
            Key should be equal in size to the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DigestSize"/></para>
            </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey">
            <summary>
            A NTRU Private Key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32,System.Int32,System.Boolean,System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.TernaryPolynomialType)">
            <summary>
            Constructs a new private key from a polynomial
            </summary>
            
            <param name="T">The polynomial which determines the key: if <c>FastFp=true</c>, <c>f=1+3T</c>; otherwise, <c>f=T</c></param>
            <param name="FP">Fp the inverse of <c>f</c></param>
            <param name="N">The number of polynomial coefficients</param>
            <param name="Q">The big q modulus</param>
            <param name="Sparse">Sparse whether the polynomial <c>T</c> is sparsely or densely populated</param>
            <param name="FastFp">FastFp whether <c>FP=1</c></param>
            <param name="PolyType">PolyType type of the polynomial <c>T</c></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.#ctor(System.IO.MemoryStream)">
            <summary>
            Reads a Private Key from a Stream
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if the key could not be loaded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.#ctor(System.Byte[])">
            <summary>
            Reads a Private Key from a byte array
            </summary>
            
            <param name="KeyArray">The encoded key array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.From(System.Byte[])">
            <summary>
            Read a Private key from a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the encoded key</param>
            
            <returns>An initialized NTRUPrivateKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.From(System.IO.MemoryStream)">
            <summary>
            Read a Private key from a stream
            </summary>
            
            <param name="KeyStream">The stream containing the encoded key</param>
            
            <returns>An initialized NTRUPrivateKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.ToBytes">
            <summary>
            Converts the Private key to an encoded byte array
            </summary>
            
            <returns>The encoded NTRUPrivateKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.ToStream">
            <summary>
            Converts the NTRUPrivateKey to an encoded MemoryStream
            </summary>
            
            <returns>The Private Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.WriteTo(System.Byte[])">
            <summary>
            Writes encoded the NTRUPrivateKey to an output byte array
            </summary>
            
            <param name="Output">The Private Key encoded as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the encoded NTRUPrivateKey to an output byte array
            </summary>
            
            <param name="Output">The Private Key encoded to a byte array</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the encoded NTRUPrivateKey to an output stream
            </summary>
            
            <param name="Output">The Output Stream receiving the encoded Private Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if the key could not be written</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.Clone">
            <summary>
            Create a shallow copy of this NTRUPrivateKey instance
            </summary>
            
            <returns>NTRUPrivateKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.DeepCopy">
            <summary>
            Create a deep copy of this NTRUPrivateKey instance
            </summary>
            
            <returns>The NTRUPrivateKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.Name">
            <summary>
            Get: Private key name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.N">
            <summary>
            Get: The number of polynomial coefficients
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.Q">
            <summary>
            Get: The big Q modulus
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.PolyType">
            <summary>
            Get: PolyType type of the polynomial <c>T</c>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.T">
            <summary>
            Get/Set: The polynomial which determines the key: if <c>FastFp=true</c>, <c>F=1+3T</c>; otherwise, <c>F=T</c>
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.FP">
            <summary>
            Get: Fp the inverse of <c>F</c>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512">
            <summary>
            <h3>Skein512: An implementation of the Skein digest with a 512 bit digest return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Skein<cite>Skein</cite> digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Skein512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/03/10" version="1.3.0.0">Added Initialize call to Ctor</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.DoFinal(System.Byte[],System.Int32)"/> method does NOT reset the internal state; call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset"/> to reinitialize.</description></item>
            </list> 
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>The Skein Hash Function Family: <see href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</see>.</description></item>
            <item><description>Skein <see href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</see> Support for the Skein Hash Family.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Adapted from the excellent project by Alberto Fajardo: <see href="http://code.google.com/p/skeinfish/">Skeinfish Release 0.50</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Initializes the Skein hash instance
            </summary>
            
            <param name="InitializationType">Digest initialization type <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType"/></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value.
            <para>Note: <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset"/> is called post hash calculation.</para> 
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            <para>Do final processing and get the hash value. 
            Note: Digest is not reset after calling DoFinal. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset"/> must be called before a new hash can be generated.</para>
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Initialize(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Used to re-initialize the digest state.
            <para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
            This does not start a new UBI block type, and must be done manually.</para>
            </summary>
            
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SkeinConfig">
            <remarks>
            Default configuration
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.GenerateConfiguration">
            <remarks>
            Default generation function
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.GenerateConfiguration(System.UInt64[])">
            <summary>
            Generate a configuration using a state key
            </summary>
            
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetSchema(System.Byte[])">
            <summary>
            Set the Schema. Schema must be 4 bytes.
            </summary>
            
            <param name="Schema">Schema Configuration string</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid schema is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetVersion(System.Int32)">
            <summary>
            Set the version string. Version must be between 0 and 3, inclusive.
            </summary>
            
            <param name="Version">Version string</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid version is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetTreeLeafSize(System.Byte)">
            <summary>
            Set the tree leaf size
            </summary>
            
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetTreeFanOutSize(System.Byte)">
            <summary>
            Set the tree fan out size
            </summary>
            
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetMaxTreeHeight(System.Byte)">
            <summary>
            Set the tree height. Tree height must be zero or greater than 1.
            </summary>
            
            <param name="Height">Tree height</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid tree height is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ConfigValue">
            <summary>
            The post-chain configuration value
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ConfigString">
            <summary>
            The configuration string
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.InitializationType">
            <summary>
            The initialization type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.StateSize">
            <summary>
            State size in bits
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.UbiParameters">
            <summary>
            Ubi Tweak parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">
            <summary>
            Pseudo Random Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.BBSG">
            <summary>
            A Blum-Blum-Shub random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.CCG">
            <summary>
            A Cubic Congruential Generator II (CCG) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.CSPRng">
            <summary>
             A Secure PRNG using RNGCryptoServiceProvider
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.CTRPrng">
            <summary>
            A Symmetric Cipher Counter mode random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.DGCPrng">
            <summary>
            A Digest Counter mode random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.MODEXPG">
            <summary>
            A Modular Exponentiation Generator (MODEXPG) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.PBPrng">
            <summary>
            An implementation of a passphrase based PKCS#5 random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.QCG1">
            <summary>
            A Quadratic Congruential Generator I (QCG-I) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.QCG2">
            <summary>
            A Quadratic Congruential Generator II (QCG-II) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.SP20Prng">
            <summary>
            An implementation of a Salsa20 Counter based Prng
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024">
            <summary>
            <h3>Keccak1024: An implementation of the SHA-3 Keccak digest.</h3>
            <h4>Note: Experimental! may need future adjustments</h4>
            <para>SHA-3 competition winner<cite>SHA-3 Standardization</cite>: The Keccak<cite>Keccak</cite> digest</para>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Keccak1024())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/01/23" version="1.3.5.0">Rewritten for improvements to security and speed</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Hash sizes are 128 and 96 bytes (1024, 768 bits).</description></item>
            <item><description>Block sizes are 40, and 54 bytes (288, 320 bits).</description></item>
            <item><description>Use the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.BlockSize"/> property to determine block sizes at runtime.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 <see href="http://keccak.noekeon.org/Keccak-submission-3.pdf">Keccak Submission</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent HashLib project implementation <see href="http://hashlib.codeplex.com/">Keccak.cs</see> class, 
            and the <see href="https://github.com/gvanas/KeccakCodePackage">Keccak Code Package</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.#ctor(System.Int32)">
            <summary>
            Initialize the digest
            </summary>
            
            <param name="DigestSize">Digest return size in bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA3 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.ParallelUtils">
            <summary>
            This class is a utility class for parallel processing
            <para>http://blogs.msdn.com/b/pfxteam/archive/2009/08/12/9867246.aspx</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.Loop(System.Threading.Tasks.ParallelOptions,System.Func{System.Boolean},System.Action{System.Threading.Tasks.ParallelLoopState})">
            <summary>
            An infinite parallel loop function
            </summary>
            
            <param name="Options">The parallel options</param>
            <param name="Condition">The while conditional</param>
            <param name="Body">The functions body</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.While(System.Threading.Tasks.ParallelOptions,System.Func{System.Boolean},System.Action{System.Threading.Tasks.ParallelLoopState})">
            <summary>
            A parallel While function
            </summary>
            
            <param name="Options">The parallel options</param>
            <param name="Condition">The while conditional</param>
            <param name="Body">The functions body</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.While(System.Func{System.Boolean},System.Action)">
            <summary>
            A parallel While function
            </summary>
            
            <param name="Condition">The while conditional</param>
            <param name="Body">The functions body</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.ForceLinear">
            <summary>
            Get/Set: Force uni-processing (IsParallel returns false)
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.IsParallel">
            <summary>
            Get: Returns true for multi processor system
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.IntUtils">
            <summary>
            An integer utilities class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.BitCount(System.Int32)">
            <summary>
            Returns the number of one-bits in the two's complement binary 
            representation of the specified int value. 
            <para>This function is sometimes referred to as the population count.</para>
            </summary>
            
            <param name="X">The value whose bits are to be counted</param>
            
            <returns>The number of one-bits in the two's complement binary representation of the specified int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.BitCount(System.Int64)">
            <summary>
            Returns the number of bits in a number
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of bits in a number</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.Clone(System.Int32[])">
            <summary>
            Create a copy of an array
            </summary>
            <param name="A">The array to copy</param>
            
            <returns>Returns the array copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.DoubleToLong(System.Double)">
            <summary>
            Convert a double to a long value
            </summary>
            
            <param name="X">Double to convert</param>
            
            <returns>Long value representation</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.FloatToInt(System.Single)">
            <summary>
            Copy a floats bits to an integer
            </summary>
            
            <param name="X">Float to convert</param>
            
            <returns>The integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.HighestOneBit(System.Int32)">
            <summary>
            Returns the highest order 1 bit in a number
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the highest order 1 bit in a number</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.HighestOneBit(System.Int64)">
            <summary>
            Returns the highest order 1 bit in a number
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the highest order 1 bit in a number</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.IntToBytes(System.Int32)">
            <summary>
            Copy an integer to a byte array
            </summary>
            
            <param name="X">Integer to copy</param>
            
            <returns>The integer bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.IntsToBytes(System.Int32[])">
            <summary>
            Copy an array of integers to a byte array
            </summary>
            
            <param name="X">Array of integers</param>
            
            <returns>The integers bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.IntToFloat(System.Int32)">
            <summary>
            Copy an integer bits to a float
            </summary>
            
            <param name="X">Integer to copy</param>
            
            <returns>The float</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.NumberOfLeadingZeros(System.Int32)">
            <summary>
            Returns the leading number of zero bits
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of leading zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.NumberOfLeadingZeros(System.Int64)">
            <summary>
            Returns the leading number of zero bits
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of leading zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.NumberOfTrailingZeros(System.Int32)">
            <summary>
            Returns the trailing number of zero bits
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of trailing zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.NumberOfTrailingZeros(System.Int64)">
            <summary>
            Returns the trailing number of zero bits
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of trailing zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ParseInt(System.String)">
            <summary>
            Parses the string argument as a signed decimal integer. 
            </summary>
            
            <param name="S">A String containing the int representation to be parsed</param>
            
            <returns>The integer value represented by the argument in decimal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ParseInt(System.String,System.Int32)">
            <summary>
            Parses the string argument as a signed integer in the radix specified by the second argument. 
            </summary>
            
            <param name="S">The String containing the integer representation to be parsed</param>
            <param name="Radix">The radix to be used while parsing</param>
            
            <returns>The integer represented by the string argument in the specified radix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ReadShort(System.IO.Stream)">
            <summary>
            Read a short value (16 bits) from a stream
            </summary>
            
            <param name="InputStream">Stream containing the short value</param>
            
            <returns>The Int16 value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ReverseBytes(System.Byte[])">
            <summary>
            Reverse a byte array order and copy to an integer
            </summary>
            
            <param name="Data">The byte array to reverse</param>
            
            <returns>The reversed integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ReverseBytes(System.Int32)">
            <summary>
            Reverse the byte order of an integer
            </summary>
            
            <param name="Value">The integer value to reverse</param>
            
            <returns>The reversed integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ReverseInt(System.Int32)">
            <summary>
            Returns the value obtained by reversing the order of the bits in the 
            two's complement binary representation of the specified int value
            </summary>
            
            <param name="X">The value to be reversed</param>
            
            <returns>The value obtained by reversing order of the bits in the specified int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.Signum(System.Int64)">
            <summary>
            Returns the signum function of the specified long value. 
            <para>The return value is -1 if the specified value is negative;
            0 if the specified value is zero; and 1 if the specified value is positive.</para>
            </summary>
            
            <param name="X">The value whose signum is to be computed</param>
            
            <returns>The signum function of the specified long value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ToString(System.Int32)">
            <summary>
            Convert an integer to a string
            </summary>
            
            <param name="X">The integer to convert</param>
            <returns>Returns the integer as a string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ToString(System.Int64)">
            <summary>
            Convert a long integer to a string
            </summary>
            
            <param name="X">The long integer to convert</param>
            <returns>Returns the long integer as a string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Operates an unsigned right shift on the given integer by the number of bits specified
            </summary>
            
            <param name="X">The number to shift</param>
            <param name="NumBits">The number of bits to shift the given number</param>
            
            <returns>
            Returns an <see cref="T:System.Int32">int</see> representing the shifted number.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.URShift(System.Int64,System.Int32)">
            <summary>
            Operates an unsigned right shift on the given integer by the number of bits specified
            </summary>
            
            <param name="X">The number to shift</param>
            <param name="NumBits">The number of bits to shift the given number</param>
            
            <returns>
            Returns an <see cref="T:System.Int64">long integer</see> representing the shifted number.
            </returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Logical">
            <summary>
            This class implements some logical operations over BigInteger.
            
            <description>The operations provided are:</description>
            <list type="bullet">
            <item><description>Not</description></item>
            <item><description>And</description></item>
            <item><description>AndNot</description>/></item>
            <item><description>Or</description>/></item>
            <item><description>Xor</description>/></item>
            </list>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.Not(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is ~Value.
            <para>The result of this operation is <c>-this-1</c>.</para>
            </summary>
            
            <param name="Value">Value to be Not'ed</param>
            
            <returns>Returns <c>~Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.And(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the bit per bit operator between this number and the given one.
            </summary>
            
            <param name="Value">The value to be And'ed with X</param>
            <param name="X">The second value</param>
            
            <returns>
            Returns a new BigInteger whose value is <c>Value &amp; X</c>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.AndNot(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this &amp; ~Value</c>.
            <para>Evaluating <c>x.AndNot(Value)</c> returns the same result as <c>x.And(Value.Not())</c>.</para>
            </summary>
            
            <param name="Value">Value to be Not'ed and then And'ed</param>
            <param name="X">The second value</param>
            
            <returns><c>Value &amp; ~X</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.Or(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this | Value</c>.
            </summary>
            
            <param name="Value">Value to be Or'ed</param>
            <param name="X">The second value</param>
            
            <returns>Returns <c>this | Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.Xor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this ^ Value</c>
            </summary>
            
            <param name="Value">Value to be Xor'ed </param>
            <param name="X">The second value</param>
            
            <returns>Returns <c>this ^ Value</c></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Division">
            <summary>
            Static library that provides all operations related with division and modular arithmetic to <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/>.
            <para>Some methods are provided in both mutable and immutable way.</para>
            
            <description>There are several variants provided listed below:</description>
            <list type="bullet">
            <item><description>BigInteger Division and Remainder operations</description></item>
            <item><description>Modular exponentiation between BigInteger</description></item>
            <item><description>Modular inverse of a BigInteger numbers</description>/&gt;</item>
            <item><description>BigInteger division and remainder by int</description></item>
            </list>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.Divide(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32)">
            <summary>
            Divides the array 'a' by the array 'b' and gets the quotient and the remainder.
            <para>Implements the Knuth's division algorithm. See D. Knuth, The Art of Computer Programming, 
            vol. 2. Steps D1-D8 correspond the steps in the algorithm description.</para>
            </summary>
            
            <param name="Quotient">The quotient</param>
            <param name="QuotientLen">The quotient's length</param>
            <param name="X">The dividend</param>
            <param name="XLen">The dividend's length</param>
            <param name="Y">The divisor</param>
            <param name="YLength">The divisor's length</param>
            
            <returns>eturn the remainder</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.DivideAndRemainderByInteger(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32,System.Int32)">
            <summary>
            Computes the quotient and the remainder after a division by an int number
            </summary>
            
            <param name="Value">The BigInteger dividend</param>
            <param name="Divisor">The divisor</param>
            <param name="DivisorSign">The divisors sign</param>
            
            <returns>Returns an array of the form <c>[quotient, remainder]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.DivideArrayByInt(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Divides an array by an integer value. Implements the Knuth's division algorithm.
            <para>See D. Knuth, The Art of Computer Programming, vol. 2.</para>
            </summary>
            
            <param name="Destination">The quotient</param>
            <param name="Source">The dividend</param>
            <param name="SourceLength">The length of the dividend</param>
            <param name="Divisor">The divisor</param>
            
            <returns>Returns the remainder</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.EvenModPow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs modular exponentiation using the Montgomery Reduction.
            <para>It requires that all parameters be positive and the modulus be even.
            Based on theThe square and multiply algorithm and the Montgomery Reduction 
            C. K. Koc - Montgomery Reduction with Even Modulus.
            The square and multiply algorithm and the Montgomery Reduction.
            ar.org.fitc.ref "C. K. Koc - Montgomery Reduction with Even Modulus"
            </para>
            </summary>
            
            <param name="X">The BigInteger</param>
            <param name="Y">The Exponent</param>
            <param name="Modulus">The Modulus</param>
            
            <returns><c>x1 + q * y</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.GcdBinary(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Return the greatest common divisor of X and Y
            </summary>
            
            <param name="X">Operand 1, must be greater than zero</param>
            <param name="Y">Operand 2, must be greater than zero</param>
            
            <returns>Returns <c>GCD(X, Y)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.GcdBinary(System.Int64,System.Int64)">
            <summary>
            Performs the same as GcdBinary(BigInteger, BigInteger)}, but with numbers of 63 bits, 
            represented in positives values of long type.
            </summary>
            
            <param name="X">A positive number</param>
            <param name="Y">A positive number></param>
            
            <returns>Returns <c>Gcd(X, Y)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.InplaceModPow2(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Performs <c>X = X Mod (2<sup>N</sup>)</c>
            </summary>
            <param name="X">A positive number, it will store the result</param>
            <param name="N">A positive exponent of 2</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.ModInverseMontgomery(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Calculates x.modInverse(p) Based on: Savas, E; Koc, C "The Montgomery Modular Inverse - Revised"
            </summary>
            
            <param name="X">BigInteger X</param>
            <param name="P">BigInteger P</param>
            
            <returns>Returns <c>1/X Mod M</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.MultiplyAndSubtract(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Multiplies an array by int and subtracts it from a subarray of another array
            </summary>
            
            <param name="X">The array to subtract from</param>
            <param name="Start">The start element of the subarray of X</param>
            <param name="Y">The array to be multiplied and subtracted</param>
            <param name="YLength">The length of Y</param>
            <param name="Multiplier">The multiplier of Y</param>
            
            <returns>Returns the carry element of subtraction</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.OddModPow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs modular exponentiation using the Montgomery Reduction.
            <para>It requires that all parameters be positive and the modulus be odd. </para>
            </summary>
            
            <param name="X">The BigInteger</param>
            <param name="Y">The exponent</param>
            <param name="Modulus">The modulus</param>
            
            <returns><c>(modulus[0]^(-1)) (mod 2^32)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.Remainder(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Divides a BigInteger by a signed int and returns the remainder
            </summary>
            
            <param name="X">The BigInteger to be divided. Must be non-negative</param>
            <param name="Divisor">A signed integer</param>
            
            <returns>Returns Divide % Divisor</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.RemainderArrayByInt(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Divides an array by an integer value. Implements the Knuth's division
            algorithm. See D. Knuth, The Art of Computer Programming, vol. 2.
            </summary>
            
            <param name="Source">The dividend</param>
            <param name="SourceLength">The length of the dividend</param>
            <param name="Divisor">The divisor</param>
            
            <returns>Returns the remainder</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">
            <summary>
            <h3>An implementation of a Hash based Message Authentication Code: HMAC<cite>Fips 198-1</cite>.</h3>
            <para>A HMAC as outlined in the NIST document: Fips 198-1<cite>Fips 198-1</cite></para>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new HMAC(new SHA256Digest(), [DisposeEngine]))
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Key size should be equal to digest output size<cite>RFC 2104</cite>.</description></item>
            <item><description>Block size is the Digests engines block size.</description></item>
            <item><description>Digest size is the Digest engines digest return size.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.ComputeMac(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2104: <see href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</see>.</description></item>
            <item><description>Fips 198-1: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">The Keyed-Hash Message Authentication Code (HMAC)</see>.</description></item>
            <item><description>Fips 180-4: <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Secure Hash Standard (SHS)</see>.</description></item>
            <item><description>NMAC and HMAC Security: <see href="http://cseweb.ucsd.edu/~mihir/papers/hmac-new.pdf">NMAC and HMAC Security Proofs</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Digest">Message Digest instance</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException">Thrown if a null digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Byte[],System.Boolean)">
            <summary>
            Initialize the class and working variables.
            <para>When this constructor is used, <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> is called automatically.</para>
            </summary>
            
            <param name="Digest">Message Digest instance</param>
            <param name="Key">HMAC Key; passed to HMAC Initialize() through constructor</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException">Thrown if a null digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the digest
            </summary>
            
            <param name="Input">Hash input data</param>
            <param name="InOffset">Starting position with the Input array</param>
            <param name="Length">Length of data to process</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>HMAC hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Completes processing and returns the HMAC code
            </summary>
            
            <param name="Output">Output array that receives the hash code</param>
            <param name="OutOffset">Offset within Output array</param>
            
            <returns>The number of bytes processed</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the HMAC
            </summary>
            
            <param name="KeyParam">HMAC Key. 
            <para>Uses the Key field of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams"/> class, <c>Key</c> parameter.
            Key should be equal in size to the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DigestSize"/></para>
            </param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException">Thrown if the Key is null or less than digest size</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Reset">
            <summary>
            Reset and initialize the underlying digest
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Update(System.Byte)">
            <summary>
            Update the digest with 1 byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2">
            <summary>
            <h3>PBKDF2: An implementation of an Hash based Key Derivation Function.</h3>
            <para>PBKDF2 as outlined in ISO 18033-2 <cite>ISO 18033</cite>.</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new PBKDF2(new SHA512()))
            {
                // initialize
                rnd.Initialize(Salt, Ikm, [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/28/15" version="1.3.1.1">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC HMAC</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto">VTDev.Libraries.CEXEngine.Crypto Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with a <see cref="!:Digests">Digest</see> or a Mac.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Salt size should be multiple of Digest block size.</description></item>
            <item><description>Ikm size should be Digest hash return size.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="bullet">
            <item><description>ISO-18033-2: <see href="http://www.shoup.net/iso/std6.pdf">Specification</see>.</description></item>
            <item><description>RFC 2898: <see href="http://tools.ietf.org/html/rfc2898">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.#ctor">
            <summary>
            Creates a PBKDF2 Bytes Generator based on the given HMAC function
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Creates a PBKDF2 Bytes Generator based on the given hash function
            </summary>
            
            <param name="Digest">The digest used</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Generate(System.Byte[])">
            <summary>
            Generate a block of cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256">
            <summary>
            <h3>SHA256: An implementation of the SHA-2 digest with a 256 bit digest return size</h3>.
            <para>The SHA-2<cite>Fips 180-4</cite> 256 digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new SHA256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA-2 <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.#ctor">
            <summary>
            Initialize the digest
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA256 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value [32 bytes]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value, Always 32 bytes</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BEToUInt32(System.Byte[],System.Int32)">
            <remarks>
            Big Endian to UInt32
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.UInt32ToBE(System.UInt32,System.Byte[],System.Int32)">
            <remarks>
            UInt32 to Big Endian
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.K1C">
            <remarks>
            the first 32 bits of the fractional parts of the cube roots of the first sixty-four prime numbers)
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen">
            <summary>
            An implementation of the <a href="http://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm">Schönhage-Strassen algorithm</a>
            for multiplying large numbers.
            </summary>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Arnold Schönhage und Volker Strassen: Schnelle Multiplikation großer Zahlen<cite>Schnelle Multiplikation großer Zahlen</cite>.</description></item>
            <item><description>Eine verstandliche Beschreibung des Schonhage-Strassen-Algorithmus<cite>Eine verstandliche Beschreibung des Schonhage-Strassen-Algorithmus</cite>.</description></item>
            </list>
            
            Numbers are internally represented as <c>int</c> arrays; the <c>int</c>s are interpreted as unsigned numbers.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.AddModFn(System.Int32[],System.Int32[])">
            <summary>
            Adds two positive numbers (meaning they are interpreted as unsigned) modulo 2^2^N+1,
            where N is <c>A.Length*32/2</c>; in other words, n is half the number of bits in <c>A</c>.
            <para>Both input values are given as <c>int</c> arrays; they must be the same length.
            The result is returned in the first argument.</para>
            </summary>
            
            <param name="A">A number in base 2^32 starting with the lowest digit; the length must be a power of 2</param>
            <param name="B">A number in base 2^32 starting with the lowest digit; the length must be a power of 2</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.AddShifted(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Adds two numbers, <c>A</c> and <c>B</c>, after shifting <c>B</c> by <c>numElements</c> elements.
            </summary>
            
            <param name="A">A number in base 2^32 starting with the lowest digit</param>
            <param name="B">A number in base 2^32 starting with the lowest digit</param>
            <param name="NumElements">The shift amount in bits</param>
            
            <remarks>
            Both numbers are given as <c>int</c> arrays and must be positive numbers (meaning they are interpreted as unsigned).
            The result is returned in the first argument. If any elements of B are shifted outside the valid range for <c>A</c>, they are dropped.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.AppendBits(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Reads BitLenB bits from <c>B</c>, starting at array index 
            <c>StartB</c>, and copies them into <c>A</c>, starting at bit
            <c>BitLenA</c>. The result is returned in <c>A</c>.
            </summary>
            
            <param name="A">Array A</param>
            <param name="BitLenA">Array A bit length</param>
            <param name="B">Array B</param>
            <param name="StartB">B starting position</param>
            <param name="BitLenB">Array B bit length</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.CyclicShiftRight(System.Int32[],System.Int32)">
            <summary>
            Cyclicly shifts a number to the right modulo 2^2^n+1 and returns the result in a new array.
            <para>"Right" means towards the lower array indices and the lower bits; this is equivalent to
            a multiplication by <c>2^(-numBits) modulo 2^2^n+1</c>. The number n is <c>a.Length*32/2</c>; 
            in other words, n is half the number of bits in <c>A</c>.
            Both input values are given as <c>int</c> arrays; they must be the same length.
            </para>
            </summary>
            
            <param name="A">A number in base 2^32 starting with the lowest digit; the length must be a power of 2</param>
            <param name="NumBits">The shift amount in bits</param>
            
            <returns>The shifted number</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.CyclicShiftLeftBits(System.Int32[],System.Int32)">
            <summary>
            Shifts a number to the left modulo 2^2^n+1 and returns the result in a new array.
            </summary>
            
            <param name="A">A number in base 2^32 starting with the lowest digit; the length must be a power of 2</param>
            <param name="NumBits">The shift amount in bits</param>
            
            <returns>The shifted number</returns>
            
            <remarks>
            <para>"Left" means towards the lower array indices and the lower bits; this is equivalent to
            a multiplication by 2^numBits modulo 2^2^n+1.
            The number n is <c>a.Length*32/2</c>; in other words, n is half the number of bits in <c>A</c>.
            Both input values are given as <c>int</c> arrays; they must be the same length. The result is returned in the first argument.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.CyclicShiftLeftElements(System.Int32[],System.Int32)">
            <summary>
            Cyclicly shifts an array towards the higher indices by <c>numElements</c> elements and returns the result in a new array.
            </summary>
            
            <param name="A">Input array</param>
            <param name="NumElements">The shift amount in bits</param>
            
            <returns>The shifted number</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.Dft(System.Int32[][],System.Int32,System.Int32)">
            <summary>
            Performs a Fermat Number Transform on an array whose elements are <c>int</c> arrays.<br/>
            </summary>
            <param name="A">Array to process</param>
            <param name="M">M Value</param>
            <param name="N">N Value</param>
            
            <remarks>
            <para><c>A</c> is assumed to be the lower half of the full array and the upper half is assumed to be all zeros.
            The number of subarrays in <c>A</c> must be 2^n if m is even and 2^(n+1) if m is odd.<br/>
            Each subarray must be ceil(2^(n-1)) bits in length.<br/>
            * n must be equal to m/2-1.</para>
            <para><a href="http://en.wikipedia.org/wiki/Discrete_Fourier_transform_%28general%29#Number-theoretic_transform">Number-theoretic transform</a></para>
            
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.Idft(System.Int32[][],System.Int32,System.Int32)">
            <summary>
            Performs a modified Inverse Fermat Number Transform on an array whose elements are <c>int</c> arrays.
            </summary>
            
            <param name="A">Array to process: Must be ceil(2^(n-1)) bits in length</param>
            <param name="M">M Value</param>
            <param name="N">N Value</param>
            
            <remarks>
            The modification is that the last step (the one where the upper half is subtracted from the lower half) is omitted.
            <c>A</c> is assumed to be the upper half of the full array and the upper half is assumed to be all zeros.
            The number of subarrays in <c>A</c> must be 2^n if m is even and 2^(n+1) if m is odd.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Multiplies two BigIntegers using the Schönhage-Strassen algorithm.
            </summary>
            
            <param name="A">Factor A</param>
            <param name="B">Factor B</param>
            
            <returns>BigInteger equal to <c>A.Multiply(B)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.Multiply(System.Int32[],System.Int32[])">
            <summary>
            Multiplies two positive numbers represented as int arrays, i.e. in base <c>2^32</c>.
            <para>Positive means an int is always interpreted as an unsigned number, regardless of the sign bit.<br/>
            The arrays must be ordered least significant to most significant,
            so the least significant digit must be at index 0.
            Schönhage-Strassen is used unless the numbers are in a range where
            <a href="http://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba</a> is more efficient.</para>
            </summary>
            
            <param name="A">Factor A</param>
            <param name="B">Factor B</param>
            
            <returns>Array equal to <c>A * B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.MultKaratsuba(System.Int32[],System.Int32[])">
            <summary>
            Multiplies two positive numbers represented as <c>int</c> arrays using the Karatsuba algorithm
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Array equal to <c>A * B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.MultSimple(System.Int32[],System.Int32[])">
            <summary>
            Multiplies two positive numbers (meaning they are interpreted as unsigned) represented as
            <c>int</c> arrays using the simple O(n²) algorithm.
            </summary>
            
            <param name="A">Array A: a number in base 2^32 starting with the lowest digit</param>
            <param name="B">Array B:  a number in base 2^32 starting with the lowest digit</param>
            
            <returns>Array equal to <c>A * B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.MultModFn(System.Int32[],System.Int32[])">
            <summary>
            Multiplies two positive numbers (meaning they are interpreted as unsigned) modulo Fn where Fn=2^2^n+1, and returns the result in a new array.
            </summary>
            
            <param name="A">A number in base 2^32 starting with the lowest digit; the length must be a power of 2</param>
            <param name="B">A number in base 2^32 starting with the lowest digit; the length must be a power of 2</param>
            
            <returns>Result of calculation</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.ModFn(System.Int32[])">
            <summary>
            Reduces all subarrays modulo 2^2^n+1 where n=<c>a[i].Length*32/2</c> for all i;
            in other words, n is half the number of bits in the subarray.
            </summary>
            
            <param name="A">Int array whose length is a power of 2</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.ModFn(System.Int32[][])">
            <summary>
            Reduces all subarrays modulo 2^2^n+1 where n=<c>a[i].Length*32/2</c> for all i;
            in other words, n is half the number of bits in the subarray.
            </summary>
            
            <param name="A">Int arrays whose length is a power of 2</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.SubModPow2(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Subtracts two positive numbers (meaning they are interpreted as unsigned) modulo 2^numBits.
            <para>Both input values are given as <c>int</c> arrays.
            The result is returned in the first argument.</para>
            </summary>
            
            <param name="A">A number in base 2^32 starting with the lowest digit</param>
            <param name="B">A number in base 2^32 starting with the lowest digit</param>
            <param name="NumBits">The number of bits to shift</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.ToBigInteger(System.Int32[])">
            <summary>
            Converts an <c>int</c> array to a <c>BigInteger</c>
            </summary>
            
            <param name="A">The integer array</param>
            
            <returns><c>BigInteger</c> representation of the array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.ToIntArray(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Converts a <c>BigInteger</c> to an <c>int</c> array.
            </summary>
            
            <param name="A">BigInteger A</param>
            
            <returns>An <c>int</c> array that is compatible with the <c>mult()</c> methods</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.AddExpand(System.Int32[],System.Int32[])">
             <summary>
             Adds two positive numbers (meaning they are interpreted as unsigned) that are given as
             int arrays and returns the result in a new array. The result may be one longer
             than the input due to a carry.
             </summary>
             
             <param name="A">A number in base 2^32 starting with the lowest digit</param>
             <param name="B">A number in base 2^32 starting with the lowest digit</param>
            
             <returns>The sum</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.AddModPow2(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Adds two positive numbers (meaning they are interpreted as unsigned) modulo 2^numBits.
            Both input values are given as int arrays. The result is returned in the first argument.
            </summary>
            <param name="A">A number in base 2^32 starting with the lowest digit</param>
            <param name="B">A number in base 2^32 starting with the lowest digit</param>
            <param name="NumBits">The modulo bit size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.Multiply(System.Int32[],System.Int32,System.Int32[],System.Int32)">
            <remarks>
            <para>Schönhage-Strassen is used unless the numbers are in a range where
            <a href="http://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba</a> is more efficient.</para>
            The Schönhage-Strassen algorithm works as follows:
            Given numbers a and b, split both numbers into pieces of length 2^(n-1) bits.
            Take the low n+2 bits of each piece of a, zero-pad them to 3n+5 bits, and concatenate them to a new number u.
            Do the same for b to obtain v.
            Calculate all pieces of z' by multiplying u and v (using Schönhage-Strassen or another algorithm). The product will contain all pieces of a*b mod n+2.
            Pad the pieces of a and b from step 1 to 2^(n+1) bits.
            Perform a <a href="http://en.wikipedia.org/wiki/Discrete_Fourier_transform_%28general%29#Number-theoretic_transform">
            Discrete Fourier Transform</a> (DFT) on the padded pieces.
            Calculate all pieces of z" by multiplying the i-th piece of a by the i-th piece of b.
            Perform an Inverse Discrete Fourier Transform (IDFT) on z". z" will contain all pieces of a*b mod Fn where Fn=2^2^n+1.
            Calculate all pieces of z such that each piece is congruent to z' modulo n+2 and congruent to z" modulo Fn. This is done using the
            <a href="http://en.wikipedia.org/wiki/Chinese_remainder_theorem">Chinese remainder theorem</a>.
            Calculate c by adding z_i * 2^(i*2^(n-1)) for all i, where z_i is the i-th piece of z.
            Return c reduced modulo 2^2^m+1.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.ShouldUseSchonhageStrassen(System.Int32)">
            <remarks>
            Estimates whether SS or Karatsuba will be more efficient when multiplying two numbers of a given length in bits.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.SplitBits(System.Int32[],System.Int32)">
            <remarks>
            Divides an int array into pieces BitLength bits long.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.SplitInts(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <remarks>
            Splits an int array into pieces of pieceSize ints each, and
            pads each piece to TargetPieceSize ints.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.SubExpand(System.Int32[],System.Int32[])">
            <remarks>
            Subtracts two positive numbers (meaning they are interpreted as unsigned) that are given as
            int arrays and returns the result in a new array.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.SubModFn(System.Int32[],System.Int32[],System.Int32)">
            <remarks>
            Subtracts two positive numbers (meaning they are interpreted as unsigned) modulo 2^2^n+1,
            where n is a.Length*32/2; in other words, n is half the number of bits in A.
            Both input values are given as int arrays; they must be the same length.
            The result is returned in the first argument.
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers">
            <summary>
            Block Ciphers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.RDX">
            <summary>
            An extended implementation of the Rijndael Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.RHX">
            <summary>
            An implementation based on the Rijndael Block Cipher, using HKDF with a SHA512 HMAC for expanded key generation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.RSM">
            <summary>
            An implementation based on the Rijndael and Serpent Merged Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.SPX">
            <summary>
            An extended implementation of the Serpent Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.SHX">
            <summary>
            The Serpent Block Cipher Extended with an HKDF Key Schedule
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.TFX">
            <summary>
            An extended implementation of the Twofish Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.THX">
            <summary>
            A Twofish Block Cipher Extended with an HKDF Key Schedule
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.TSM">
            <summary>
            An implementation based on the Twofish and Serpent Merged Block Ciphers, using an HKDF Key Schedule
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX">
            <summary>
            <h3>SPX: An extended implementation of the Serpent encryption cipher.</h3>
            <para>SPX is an implementation of the Serpent<cite>Serpent</cite> block cipher, extended to use a 512 bit key.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new SPX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/14" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 192, 256 and 512 bits (16, 24, 32 and 64 bytes).</description></item>
            <item><description>Block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 32, 40, 48, 56, and 64, default is 32.</description></item>
            </list>
            
            <para>The Key Schedule has been written so that it can both accept a larger key size of 512 bits, 
            and produce the required number of working keys with a variable number of diffusion rounds.</para>
            
            <para>The diffusion rounds, (the portion of the cipher that does the actual mixing of plaintext into ciphertext),
            is exactly the same with every key length, only it can now process an increased number of rounds, from 32; 
            the standard, up to 64 rounds. 
            This increase in the ciphers diffusion cycles makes linear and differential analysis more difficult, 
            and the larger key size ensures that it can not be brute forced.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalRounds"/> property contains available sizes.  Default is 32 rounds.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LinearTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.InverseTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the inverse of the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalKeySizes">
            <summary>
            Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.LittleEndian">
            <summary>
            This is a utility class containing data type conversions using little-endian byte order
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.IntToOctets(System.Int32)">
            <summary>
            Convert an integer to an octet string of length 4
            </summary>
            
            <param name="Input">The integer to convert</param>
            
            <returns>The converted integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.IntToOctets(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Convert an integer into a byte array beginning at the specified offset
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array to hold the result</param>
            <param name="Offset">The integer offset into the byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.IntToOctets(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert an integer to a byte array beginning at the specified offset.
            <para>No length checking is performed (i.e., if the integer cannot be encoded with <c>length</c> octets, it is truncated).</para>
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array to hold the result</param>
            <param name="Offset">The integer offset into the byte array</param>
            <param name="Length">The length of the encoding</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.LongToOctets(System.Int64)">
            <summary>
            Convert an integer to a byte array of length 8
            </summary>
            
            <param name="Input">The integer to convert</param>
            
            <returns>The converted integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.LongToOctets(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Convert an integer to a byte array of length 8
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The offset in output array</param>
            <param name="Offset">The byte array holding the output</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.OctetsToInt(System.Byte[])">
            <summary>
            Convert an octet string of length 4 to an integer
            </summary>
            
            <param name="Input">The byte array holding the octet string</param>
            
            <returns>Returns an integer representing the octet string <c>Input</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.OctetsToInt(System.Byte[],System.Int32)">
            <summary>
            Convert an byte array of length 4 beginning at <c>offset</c> into an integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="Offset">The offset into the byte array</param>
            
            <returns>The resulting integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.OctetsToInt(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert a byte array of the given length beginning at <c>offset</c> into an integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="Offset">The offset into the byte array</param>
            <param name="Length">The length of the encoding</param>
            
            <returns>The resulting integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.OctetsToLong(System.Byte[],System.Int32)">
            <summary>
            Convert a byte array of length 8 beginning at <c>inOff</c> into a long integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="Offset">The offset into the byte array</param>
            
            <returns>The resulting long integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.ToByteArray(System.Int32[],System.Int32)">
            <summary>
            Convert an int array to a byte array of the specified length.
            <para>No length checking is performed (i.e., if the last integer cannot be encoded with <c>length % 4</c> octets, it is truncated).</para>
            </summary>
            
            <param name="Input">The int array</param>
            <param name="Length">The length of the converted array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.ToIntArray(System.Byte[])">
            <summary>
            Convert a byte array to an int array
            </summary>
            
            <param name="Input">The byte array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng">
            <summary>
            <h3>An implementation of a Cryptographically Secure PRNG using the RNGCryptoServiceProvider class.</h3>
            <para>Implements a random number generator using the RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new CSPRng())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4>:</description>
            <list type="number">
            <item><description>RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class documentation.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.#ctor">
            <summary>
            Initialize the class
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if RNGCryptoServiceProvider initialization failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.NextLong">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey">
            <summary>
            An NTRU Public Key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32,System.Int32)">
            <summary>
            Constructs a new public key from a polynomial
            </summary>
            
            <param name="H">The polynomial <c>H</c> which determines the key</param>
            <param name="N">The number of coefficients in the polynomial <c>H</c></param>
            <param name="Q">The "big" NtruEncrypt modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.#ctor(System.IO.Stream)">
            <summary>
            Read a Public Key from a Stream
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if the key could not be loaded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.#ctor(System.Byte[])">
            <summary>
            Read a Public Key from a byte array
            </summary>
            
            <param name="KeyArray">The encoded key array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.From(System.Byte[])">
            <summary>
            Read a Public key from a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the encoded key</param>
            
            <returns>An initialized NTRUPublicKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.From(System.IO.MemoryStream)">
            <summary>
            Read a Public key from a stream
            </summary>
            
            <param name="KeyStream">The stream containing the encoded key</param>
            
            <returns>An initialized NTRUPublicKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.ToBytes">
            <summary>
            Converts the Public key to an encoded byte array
            </summary>
            
            <returns>The encoded NTRUPublicKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.ToStream">
            <summary>
            Converts the Public key to an encoded MemoryStream
            </summary>
            
            <returns>The Public Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.WriteTo(System.Byte[])">
            <summary>
            Writes the encoded NTRUPublicKey to an output byte array
            </summary>
            
            <param name="Output">The Public Key encoded as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the encoded NTRUPublicKey to an output byte array
            </summary>
            
            <param name="Output">The Public Key encoded to a byte array</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the encoded NTRUPublicKey to an output stream
            </summary>
            
            <param name="Output">The Output Stream receiving the encoded Public Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if the key could not be written</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.Clone">
            <summary>
            Create a shallow copy of this NTRUPublicKey instance
            </summary>
            
            <returns>NTRUPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.DeepCopy">
            <summary>
            Create a deep copy of this NTRUPublicKey instance
            </summary>
            
            <returns>The NTRUPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.Name">
            <summary>
            Get: Private key name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.N">
            <summary>
            The number of coefficients in the polynomial <c>H</c>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.Q">
            <summary>
            The big Q modulus
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.H">
            <summary>
            The polynomial <c>H</c> which determines the key
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256">
            <summary>
            <h3>Blake256: An implementation of the Blake digest with a 256 bit return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Blake<cite>Blake</cite> digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Blake256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 32 bytes, (256 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 Proposal <see href="https://131002.net/blake">Blake</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            <item><description>SHA3 Submission in C: <see href="https://131002.net/blake/blake_ref.c">blake_ref.c</see>.</description></item>
            <item><description>The: <see href="http://hashlib.codeplex.com/">HashLib</see> Project (test vectors).</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent project by Dominik Reichl: <see href="http://www.codeproject.com/Articles/286937/BlakeSharp-A-Csharp-Implementation-of-the-BLAKE-Ha">Blake Sharp</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG">
            <summary>
            <h3>An implementation of the Modular Exponentiation Generator random number generator: MODEXPG</h3>
            <para>Implements MODEXPG as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.6</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new MODEXPG())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">ModulusExponentPrng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="P">Random Prime</param>
            <param name="G">Random Generator State</param>
            <param name="Y">Random Generator Seed</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters">
            <summary>
            The Asymmetric parameters interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.ToBytes">
            <summary>
            Returns the current parameter set as an ordered byte array
            </summary>
            
            <returns>Parameters as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.ToStream">
            <summary>
            Returns the current parameter set as a MemoryStream
            </summary>
            
            <returns>Parameters as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.WriteTo(System.Byte[])">
            <summary>
            Writes the parameter set to an output byte array
            </summary>
            
            <param name="Output">Parameters as a byte array; can be initialized as zero bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the parameter set to an output byte array
            </summary>
            
            <param name="Output">Parameters as a byte array; array must be initialized and of sufficient length</param>
            <param name="Offset">The starting position within the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.WriteTo(System.IO.Stream)">
            <summary>
            Writes the parameter set to an output stream
            </summary>
            
            <param name="Output">Output stream</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.Name">
            <summary>
            Get: The parameters name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial">
            <summary>
            A polynomial of the form <c>f1*f2+f3</c>, where 
            <c>f1,f2,f3</c> are very sparsely populated ternary polynomials.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial)">
            <summary>
            Constructs a new polynomial from three sparsely populated ternary polynomials
            </summary>
            
            <param name="F1">F1 polynomial</param>
            <param name="F2">F2 polynomial</param>
            <param name="F3">F3 polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.Clear">
            <summary>
            Clear the state data
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.GenerateRandom(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Generates a <c>ProductFormPolynomial</c> from three random ternary polynomials.
            </summary>
            
            <param name="N">Number of coefficients</param>
            <param name="Df1">Number of ones in the first polynomial; also the number of negative ones</param>
            <param name="Df2">Number of ones in the second polynomial; also the number of negative ones</param>
            <param name="Df3Ones">Number of ones in the third polynomial</param>
            <param name="Df3NegOnes">Number of negative ones in the third polynomial</param>
            <param name="Rng">Random number generator</param>
            
            <returns>A random <c>ProductFormPolynomial</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.FromBinary(System.Byte[],System.Int32)">
            <summary>
            Decodes a byte array encoded with ToBinary() to a polynomial.
            </summary>
            
            <param name="Data">An encoded <c>ProductFormPolynomial</c></param>
            <param name="N">Number of coefficients in the polynomial</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.FromBinary(System.IO.MemoryStream,System.Int32)">
            <summary>
            Decodes a polynomial encoded with ToBinary()
            </summary>
            
            <param name="InputStrem">An input stream containing an encoded polynomial</param>
            <param name="N">Number of coefficients in the polynomial</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.ToBinary">
            <summary>
            Encodes the polynomial to a byte array
            </summary>
            
            <returns>The encoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the coefficient values mod <c>modulus</c> and the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            <param name="Modulus">The modulus to apply</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.ToIntegerPolynomial">
            <summary>
            Returns a polynomial that is equal to this polynomial (in the sense that mult(IntegerPolynomial, int) 
            returns equal <c>IntegerPolynomial</c>s). The new polynomial is guaranteed to be independent of the original.
            </summary>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.GetHashCode">
            <summary>
            Get the hash code
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.Equals(System.Object)">
            <summary>
            Compare this polynomial to another for equality
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">
            <summary>
            <h3>HKDF: An implementation of an Hash based Key Derivation Function.</h3>
            <para>HKDF as outlined in RFC 5869<cite>RFC 5869</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new HKDF(new SHA512()))
            {
                // initialize
                rnd.Initialize(Salt, Ikm, [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC HMAC</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with a <see cref="!:Digests">Digest</see> or a <see cref="!:Macs">Mac</see>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Salt size should be multiple of Digest block size.</description></item>
            <item><description>Ikm size should be Digest hash return size.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 5869: <see href="http://tools.ietf.org/html/rfc5869">Specification</see>.</description></item>
            <item><description>HKDF Scheme: <see href="http://tools.ietf.org/html/rfc5869">Whitepaper</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Creates a HKDF Bytes Generator based on the given hash function
            </summary>
            
            <param name="Digest">The digest used</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Mac.IMac)">
            <summary>
            Creates a HKDF Bytes Generator based on the given HMAC function
            </summary>
            
            <param name="Hmac">The HMAC digest used</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Hmac is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Salt is used</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Initialize(System.Byte[],System.Byte[])" -->
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Nonce value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if the output buffer is too small, or the size requested exceeds maximum: 255 * HashLen bytes</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType">
            <summary>
            Specifies the Skein initialization type.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.Normal">
            <summary>
            Identical to the standard Skein initialization.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.ZeroedState">
            <summary>
            Creates the initial state with zeros instead of the configuration block, then initializes the hash.
            This does not start a new UBI block type, and must be done manually.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.ChainedState">
            <summary>
            Leaves the initial state set to its previous value, which is then chained with subsequent block transforms.
            This does not start a new UBI block type, and must be done manually.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.ChainedConfig">
            <summary>
            Creates the initial state by chaining the previous state value with the config block, then initializes the hash.
            This starts a new UBI block type with the standard Payload type.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType">
            <summary>
            The Unique Block Iteration (UBI) options
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Key">
            <summary>
            A key that turns Skein into a MAC or KDF function.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Config">
            <summary>
            The configuration block.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Personalization">
            <summary>
            A string that applications can use to create different functions for different uses.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.PublicKey">
            <summary>
            Used to hash the public key when hashing a message for signing.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.KeyIdentifier">
            <summary>
            Used for key derivation.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Nonce">
            <summary>
            Nonce value for use in stream cipher mode and randomized hashing.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Message">
            <summary>
            The normal message input of the hash function.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Out">
            <summary>
            The output transform.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak">
            <summary>
            <para>The Unique Block Iteration (UBI) implementations, <see href="https://www.schneier.com/skein1.3.pdf">section 2.3</see>.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.StartNewBlockType(VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType)">
            <summary>
            Starts a new UBI block type by setting BitsProcessed to zero, setting the first flag, and setting the block type.
            </summary>
            <param name="type">The UBI block type of the new block</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.IsFirstBlock">
            <summary>
            Gets or sets the first block flag.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.IsFinalBlock">
            <summary>
            Gets or sets the final block flag.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.TreeLevel">
            <summary>
            Gets or sets the current tree level.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.BitsProcessed">
            <summary>
            Gets or sets the number of bits processed so far, inclusive.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.BlockType">
            <summary>
            Gets or sets the current UBI block type.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.Tweak">
            <summary>
            The current Threefish tweak value.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256">
            <summary>
            <h3>Skein256: An implementation of the Skein digest with a 256 bit digest return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Skein<cite>Skein</cite> digest</para>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Skein256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/03/10" version="1.3.0.0">Added Initialize call to Ctor</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 32 bytes, (256 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.DoFinal(System.Byte[],System.Int32)"/> method does NOT reset the internal state; call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset"/> to reinitialize.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>The Skein Hash Function Family: <see href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</see>.</description></item>
            <item><description>Skein <see href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</see> Support for the Skein Hash Family.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Adapted from the excellent project by Alberto Fajardo: <see href="http://code.google.com/p/skeinfish/">Skeinfish Release 0.50</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Initializes the Skein hash instance.
            </summary>
            
            <param name="InitializationType">Digest initialization type <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType"/></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value.
            <para>Note: <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset"/> is called post hash calculation.</para> 
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            <para>Do final processing and get the hash value. 
            Note: Digest is not reset after calling DoFinal. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset"/> must be called before a new hash can be generated.</para>
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Initialize(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Used to re-initialize the digest state.
            <para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
            This does not start a new UBI block type, and must be done manually.</para>
            </summary>
            
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SkeinConfig">
            <remarks>
            Default configuration
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.GenerateConfiguration">
            <remarks>
            Default generation function
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.GenerateConfiguration(System.UInt64[])">
            <summary>
            Generate a configuration using a state key
            </summary>
            
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetSchema(System.Byte[])">
            <summary>
            Set the Schema. Schema must be 4 bytes.
            </summary>
            
            <param name="Schema">Schema Configuration string</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid schema is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetVersion(System.Int32)">
            <summary>
            Set the version string. Version must be between 0 and 3, inclusive.
            </summary>
            
            <param name="Version">Version string</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid version is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetTreeLeafSize(System.Byte)">
            <summary>
            Set the tree leaf size
            </summary>
            
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetTreeFanOutSize(System.Byte)">
            <summary>
            Set the tree fan out size
            </summary>
            
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetMaxTreeHeight(System.Byte)">
            <summary>
            Set the tree height. Tree height must be zero or greater than 1.
            </summary>
            
            <param name="Height">Tree height</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if an invalid tree height is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ConfigValue">
            <summary>
            The post-chain configuration value
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ConfigString">
            <summary>
            The pre-chain configuration string
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.InitializationType">
            <summary>
            The initialization type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.StateSize">
            <summary>
            State size in bits
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.UbiParameters">
            <summary>
            Ubi Tweak parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.IntEuclidean">
            <summary>
            Extended Euclidean Algorithm in integers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.IntEuclidean.X">
            <summary>
            Coefficient X
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.IntEuclidean.Y">
            <summary>
            Coefficient Y
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.IntEuclidean.GCD">
            <summary>
            Greatest Common Divisor
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.IntEuclidean.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.IntEuclidean.Calculate(System.Int32,System.Int32)">
            <summary>
            Runs the EEA on two BigIntegers
            </summary>
            <param name="A">Quotient A</param>
            <param name="B">Quotient B</param>
            <returns>Return a BigIntEuclidean object that contains the result in the variables X, Y, and GCD</returns>
            
            <remarks>
            Implemented from pseudocode on <a href="http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm"/>Wikipedia
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg">
            <summary>
            <h3>PBKDF2: An implementation of an Hash based Key Derivation Function.</h3>
            <para>PBKDF2 as outlined in ISO 18033-2 <cite>ISO 18033</cite>.</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new PBKDF2(new SHA512()))
            {
                // initialize
                rnd.Initialize(Salt, Ikm, [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/28/15" version="1.3.1.1">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac HMAC</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with a <see cref="!:Digests">Digest</see> or a <see cref="!:Macs">Mac</see>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Salt size should be multiple of Digest block size.</description></item>
            <item><description>Ikm size should be Digest hash return size.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="table">
            <item><description>ISO-18033-2: <see href="http://www.shoup.net/iso/std6.pdf">Specification</see>.</description></item>
            <item><description>RFC 2898: <see href="http://tools.ietf.org/html/rfc2898">Specification</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.#ctor">
            <summary>
            Creates a PBKDF2 Bytes Generator based on the given HMAC function using the default SHA512 engine
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Creates a PBKDF2 Bytes Generator based on the given hash function
            </summary>
            
            <param name="Digest">The digest used</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt or 'password' value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt or 'password' value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt or 'password' value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoGeneratorException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts">
            <summary>
            Rounds Count. Can be cast as round count integers, 
            i.e. (int ct = RoundCounts.R12) is equal to 12.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R8">
            <summary>
            8 Rounds: ChaCha
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R10">
            <summary>
            10 Rounds: ChaCha, RHX, RSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R12">
            <summary>
            12 Rounds: ChaCha, RHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R14">
            <summary>
            14 Rounds: ChaCha, RHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R16">
            <summary>
            16 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R18">
            <summary>
            18 Rounds: ChaCha, Fusion, RSM, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R20">
            <summary>
            20 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R22">
            <summary>
            22 Rounds: ChaCha, Fusion, RHX, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R24">
            <summary>
            24 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R26">
            <summary>
            26 Rounds: ChaCha, Fusion, RSM, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R28">
            <summary>
            28 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R30">
            <summary>
            30 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R32">
            <summary>
            32 Rounds: Fusion, SHX, SPX, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R34">
            <summary>
            34 Rounds, RSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R38">
            <summary>
            38 Rounds, RHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R40">
            <summary>
            40 Rounds: SHX, SPX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R42">
            <summary>
            42 Rounds: RSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R48">
            <summary>
            48 Rounds: SHX, SPX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R56">
            <summary>
            56 Rounds: SHX, SPX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R64">
            <summary>
            64 Rounds: SHX, SPX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R80">
            <summary>
            80 Rounds: SHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R96">
            <summary>
            96 Rounds: SHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R128">
            <summary>
            128 Rounds: SHX
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB">
            <summary>
            <h3>Implements an Electronic Cookbook Mode: ECB (Not Recommended).</h3>
            <para>ECB as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new ECB(new RDX(), [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="DisposeEngine">Dispose of cipher engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">KeyParam containing key and vector</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null Key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Decrypt a single block of bytes.
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Decrypt a block of bytes with offset parameters.
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Encrypt a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Encrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.IV">
            <summary>
            Get: The current state of the initialization Vector
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC">
            <summary>
            <h3>Implements a Cipher Block Chaining Mode: CBC.</h3>
            <para>CBC as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CBC(new RDX(), [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Parallel processing is enabled on decryption by passing a block size of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelBlockSize"/> to the transform.</description></item>
            <item><description><see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelBlockSize"/> must be divisible by <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelMinimumSize"/>.</description></item>
            <item><description>Parallel block calculation ex. <c>int blocklen = (data.Length / cipher.ParallelMinimumSize) * 10</c></description></item>
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="DisposeEngine">Dispose of cipher engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Cipher is used. for encryption, false to decrypt</param>
            <param name="KeyParam">KeyParam containing key and vector</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null Key or IV is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Decrypt a single block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Decrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Encrypt a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Encrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. Parallel capable in Decryption mode. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters. Parallel capable in Decryption mode. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.IV">
            <summary>
            Get: The current state of the initialization Vector
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, or  block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ProcessorCount">
            <remarks>
            Processor count
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets" -->
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.FromId(System.Byte[])">
            <summary>
            Retrieve a parameter set by its identity code
            </summary>
            
            <param name="OId">The 4 byte parameter set identity code</param>
            
            <returns>A parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if an invalid or unknown OId is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.FromName(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames)">
            <summary>
            Retrieve a parameter set by its enumeration name
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>A populated parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if an invalid or unknown OId is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.GetID(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames)">
            <summary>
            Retrieve the OId for a parameter set
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>The parameters 4 byte OId</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if an invalid name is used</exception>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.CX1931SH512">
            <para>OId is 4 bytes Family:Set:SubSet:Unique</para>
            <summary>
            Experimental, use with caution.
            <para>MaxText:, N:1931 Q:2048, Df:380, PublicKey Size: 2660, PrivateKey Size: 388</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.CX1861SH512">
            <summary>
            Experimental, use with caution.
            <para>MaxText:, N:1861 Q:2048, Df:290, PublicKey Size: 2563, PrivateKey Size: 374</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.EES1087EP2">
            <summary>
            A conservative parameter set that gives 256 bits of security and is optimized for key size.
            <para>MaxText:, N:1087 Q:2048, Df:120, PublicKey Size: 1499, PrivateKey Size: 221</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.EES1087EP2FAST">
            <summary>
            A product-form version of <c>EES1087EP2</c>
            <para>MaxText:, N:1087 Q:2048, Df:120, PublicKey Size: 1499, PrivateKey Size: 93</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.EES1171EP1">
            <summary>
            A conservative parameter set that gives 256 bits of security and is a tradeoff between key size and encryption/decryption speed.
            <para>MaxText:, N:1171 Q:2048, Df:106, PublicKey Size: 1615, PrivateKey Size: 237</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.EES1171EP1FAST">
            <summary>
            A product-form version of <c>EES1171EP1</c>
            <para>MaxText:, N:1171 Q:2048, Df:106, PublicKey Size: 1615, PrivateKey Size: 237</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.EES1499EP1">
            <summary>
            A conservative parameter set that gives 256 bits of security and is optimized for encryption/decryption speed.
            <para>MaxText:, N:1499 Q:2048, Df:79, PublicKey Size: 2066, PrivateKey Size: 302</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.EES1499EP1FAST">
            <summary>
            A product-form version of <c>EES1499EP1</c>
            <para>MaxText:, N:1499 Q:2048, Df:79, PublicKey Size: 2066, PrivateKey Size: 302</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.APR2011439">
            <summary>
            A parameter set that gives 128 bits of security and uses simple ternary polynomials.
            <para>MaxText:, N:439 Q:2048, Df:146, PublicKey Size: 608, PrivateKey Size: 79</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.APR2011439FAST">
            <summary>
            Like <c>APR2011_439</c>, this parameter set gives 128 bits of security but uses product-form polynomials and <c>f=1+pF</c>.
            <para>MaxText:, N:439 Q:2048, Df:146, PublicKey Size: 608, PrivateKey Size: 92</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.APR2011743">
            <summary>
            A parameter set that gives 256 bits of security and uses simple ternary polynomials.
            <para>MaxText:, N:743 Q:2048, Df:248, PublicKey Size: 1026, PrivateKey Size: 123</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.APR2011743FAST">
            <summary>
            Like <c>APR2011_743</c>, this parameter set gives 256 bits of security but uses product-form polynomials and <c>f=1+pF</c>. 
            <para>MaxText:, N:743 Q:2048, Df:248, PublicKey Size: 1026, PrivateKey Size: 123</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames">
            <summary>
            EES set id's for common parameter values
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.CX1931">
            <summary>
            Experimental, use with caution.
            <para>n:1931, q:2048, df:380, SHA512</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.CX1861">
            <summary>
            Experimental, use with caution.
            <para>n:1861, q:2048, df:290, SHA512</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.E1087EP2">
            <summary>
            A conservative (in terms of security) parameter set that gives 256 bits of security and is optimized for key size.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.E1171EP1">
            <summary>
            A conservative (in terms of security) parameter set that gives 256 bits of security and is a tradeoff between key size and encryption/decryption speed.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.E1499EP1">
            <summary>
            A conservative (in terms of security) parameter set that gives 256 bits of security and is optimized for encryption/decryption speed.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.A2011439">
            <summary>
            A parameter set that gives 256 bits of security and uses simple ternary polynomials.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.A2011743">
            <summary>
            Like <c>APR2011_743</c>, this parameter set gives 256 bits of security but uses product-form polynomials and <c>f=1+pF</c>. 
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.FE1087EP2">
            <summary>
            A product-form version of <c>EES1087EP2</c>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.FE1171EP1">
            <summary>
            A product-form version of <c>EES1171EP1</c>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.FE1499EP1">
            <summary>
            A product-form version of <c>EES1499EP1</c>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.FA2011743">
            <summary>
            Like <c>APR2011_743</c>, this parameter set gives 256 bits of security but uses product-form polynomials and <c>f=1+pF</c>. 
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.FA2011439">
            <summary>
            Like <c>APR2011_439</c>, this parameter set gives 128 bits of security but uses product-form polynomials and <c>f=1+pF</c>.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils">
            <summary>
            Folder methods wrapper class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryCreate(System.String)">
            <summary>
            Create a folder
            </summary>
            
            <param name="DirectoryPath">Full path to folder</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryChecked(System.String)">
            <summary>
            Test for directory and create
            </summary>
            
            <param name="DirectoryPath">Full path to folder</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryExists(System.String)">
            <summary>
            Test for directory
            </summary>
            
            <param name="DirectoryPath">Full path to folder</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryGetFileCount(System.String)">
            <summary>
            Get the number of files in a directory
            </summary>
            
            <param name="DirectoryPath">Full directory path</param>
            
            <returns>Count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryGetFiles(System.String)">
            <summary>
            Return all the files in a directory
            </summary>
            
            <param name="DirectoryPath">Directory path</param>
            
            <returns>File names [string]]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryGetCommon(System.Environment.SpecialFolder)">
            <summary>
            Get common directories
            </summary>
            
            <param name="FolderPath">Folder enum</param>
            
            <returns>Directory [string]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryGetPath(System.String)">
            <summary>
            Get file directory from path
            </summary>
            
            <param name="FilePath">File path</param>
            
            <returns>Directory [string]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryGetSize(System.String)">
            <summary>
            Return all the files in a directory
            </summary>
            
            <param name="DirectoryPath">Directory path</param>
            
            <returns>File names [string]]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryHasPermission(System.String,System.Security.AccessControl.FileSystemRights)">
            <summary>
            Test a directory for create file access permissions
            </summary>
            
            <param name="DirectoryPath">Full path to file or directory </param>
            <param name="AccessRight">File System right tested</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryIsWritable(System.String)">
            <summary>
            Directory can write/create
            </summary>
            
            <param name="DirectoryPath">Directory path</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryCanCreate(System.String)">
            <summary>
            Test a directory for create file access permissions
            </summary>
            
            <param name="DirectoryPath">Full directory path</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryCanWrite(System.String)">
            <summary>
            Test a directory for write file access permissions
            </summary>
            
            <param name="DirectoryPath">Full directory path</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryAddAccessRule(System.String,System.String,System.Security.AccessControl.FileSystemRights,System.Security.AccessControl.AccessControlType)">
            <summary>
            Add an access rule to a folder
            </summary>
            
            <param name="Path">Folder path</param>
            <param name="User">UNC path to user profile ex. Environment.UserDomainName + "\\" + Environment.UserName</param>
            <param name="Rights">Desired file system rights</param>
            <param name="Access">Desired level of access</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryAddSecurity(System.String,System.String,System.Security.AccessControl.FileSystemRights,System.Security.AccessControl.AccessControlType)">
            <summary>
            Add a file system right to a directory
            </summary>
            
            <param name="Path">Full path to directory</param>
            <param name="Account">UNC path to user profile</param>
            <param name="Rights">Desired file system rights</param>
            <param name="ControlType">Access control type</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryGetAccessRules(System.String,System.String)">
            <summary>
            Get access rules for a folder
            </summary>
            
            <param name="Path">Folder path</param>
            <param name="Account">UNC path to user profile</param>
            
            <returns>Rule collection [AuthorizationRuleCollection]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.DirectoryUtils.DirectoryRemoveSecurity(System.String,System.String,System.Security.AccessControl.FileSystemRights,System.Security.AccessControl.AccessControlType)">
            <summary>
            Remove a file system right to a directory
            </summary>
            
            <param name="FileName">Full path to directory</param>
            <param name="Account">UNC path to user profile</param>
            <param name="Rights">Desired file system rights</param>
            <param name="ControlType">Access control type</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.CharUtils">
            <summary>
            This class is a utility class for manipulating char arrays
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Utility.CharUtils.MIN_RADIX">
            <summary>
            Min radix
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Utility.CharUtils.MAX_RADIX">
            <summary>
            Max radix
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.CharAt(System.String,System.Int32)">
            <summary>
            Get the char value at a specified index within a string
            </summary>
            
            <param name="Value">String to parse</param>
            <param name="Index">Index of value</param>
            
            <returns>Char value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.Clone(System.Char[])">
            <summary>
            Return a clone of the given char array. No null checks are performed.
            </summary>
            
            <param name="A">The array to clone</param>
            
            <returns>The clone of the given array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.Equals(System.Char[],System.Char[])">
            <summary>
            Compare two char arrays. No null checks are performed.
            </summary>
            
            <param name="A">The char byte array</param>
            <param name="B">The second char array</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ForDigit(System.Int32,System.Int32)">
            <summary>
            Get the char representation of an iteger
            </summary>
            
            <param name="Digit">The digit to convert</param>
            <param name="Radix">The radix</param>
            
            <returns>New char value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToByteArray(System.Char[])">
            <summary>
            Convert the given char array into a byte array.
            </summary>
            
            <param name="A">The char array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToByteArrayForPBE(System.Char[])">
            <summary>
            Convert the given char array into a byte array for use with PBE encryption
            </summary>
            
            <param name="A">The char array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToDigit(System.Char)">
            <summary>
            Convert a char to an integer
            </summary>
            
            <param name="Value">Char to convert</param>
            
            <returns>Integer representation</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToDigit(System.Char,System.Int32)">
            <summary>
            Convert a char to an integer
            </summary>
            
            <param name="Value">Char to convert</param>
            <param name="Radix">The radix</param>
            
            <returns>New integer value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToDigit(System.String)">
            <summary>
            Convert a string to an integer
            </summary>
            
            <param name="Value">String to convert</param>
            
            <returns>Integer representation</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoProcessingException">
            <summary>
            Wraps exceptions thrown within a Processing operational context.
            <para>This exception is used throughout the CompressionCipher, PacketCipher, StreamCipher, StreamDigest, StreamMac, and VolumeCipher classes.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoProcessingException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoProcessingException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoProcessingException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoProcessingException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Exceptions.CryptoProcessingException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign">
            <summary>
            The Asymmetric cipher interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the Key for Sign (Private) or Verify (Public)
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the Public (verify) or Private (sign) key</param>
            
            <exception cref="!:CryptoAsymmetricSignException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.Reset">
            <summary>
            Reset the underlying engine
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.Sign(System.IO.Stream)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="InputStream">The stream contining the data</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception cref="!:CryptoAsymmetricSignException">Thrown if an invalid key is used, or signer has not been initialized</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.Sign(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="Input">The byte array contining the data</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception cref="!:CryptoAsymmetricSignException">Thrown if input array is too short, signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.Verify(System.IO.Stream,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="InputStream">The stream containing the data to test</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception cref="!:CryptoAsymmetricSignException">Thrown if signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.Verify(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="Input">The stream containing the data to test</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception cref="!:CryptoAsymmetricSignException">Thrown if input array is too short, signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.IsSigner">
            <summary>
            Get: This class is initialized for Signing with the Private key
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Tools.HexConverter">
            <summary>
            A Hexadecimal conversion helper class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.HexConverter.ToString(System.Byte[])">
            <summary>
            Convert an array into a hex string
            </summary>
            
            <param name="Data">Data to convert</param>
            
            <returns>Data as a string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.HexConverter.Encode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encode an array of bytes in hexadecimal format
            </summary>
            
            <param name="Data">The bytes to encode</param>
            <param name="Offset">The starting offset within the Data array</param>
            <param name="Length">The number of bytes to encode</param>
            
            <returns>Encode bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.HexConverter.Decode(System.String)">
            <summary>
            Decode a Hex encoded string and return the output
            </summary>
            
            <param name="Data">Hex string</param>
            
            <returns>Decoded bytes</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException">
            <summary>
            Wraps exceptions thrown within a Cryptographic Hash operational context.
            <para>This exception is used throughout the Digest classes.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Exceptions.CryptoHashException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder">
            <summary>
            Converts a coefficient array to a compact byte array and vice versa.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.DecodeMod3Sves(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Decodes a <c>byte</c> array encoded with EncodeMod3Sves(int[], boolean) back to an <c>int</c> array with <c>N</c> coefficients between <c>-1</c> and <c>1</c>.
            <para>Ignores any excess bytes.
            See P1363.1 section 9.2.2.</para>
            </summary>
            
            <param name="Data">Data an encoded ternary polynomial</param>
            <param name="N">The number of coefficients</param>
            <param name="SkipFirst">Whether to leave the constant coefficient zero and start populating at the linear coefficient</param>
            
            <returns>The decoded coefficients</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.DecodeMod3Tight(System.Byte[],System.Int32)">
            <summary>
            Converts a byte array produced by EncodeMod3Tight(int[]) back to an <c>int</c> array
            </summary>
            
            <param name="Data">The byte array</param>
            <param name="N">The number of coefficients</param>
            
            <returns>The decoded array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.DecodeMod3Tight(System.IO.MemoryStream,System.Int32)">
            <summary>
            Converts data produced by EncodeMod3Tight(int[]) back to an <c>int</c> array
            </summary>
            
            <param name="InputStream">The input stream containing the data to decode</param>
            <param name="N">The number of coefficients</param>
            
            <returns>The decoded array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.DecodeModQ(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decodes a <c>byte</c> array encoded with EncodeModQ(int[], int)} back to an <c>int</c> array.
            <para><c>N</c> is the number of coefficients. <c>Q</c> must be a power of <c>2</c>.
            Ignores any excess bytes.</para>
            </summary>
            
            <param name="Data">Data an encoded ternary polynomial</param>
            <param name="N">The number of coefficients</param>
            <param name="Q">The modulus</param>
            
            <returns>Returns an array containing <c>N</c> coefficients between <c>0</c> and <c>q-1</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.DecodeModQ(System.IO.Stream,System.Int32,System.Int32)">
            <summary>
            Decodes data encoded with encodeModQ(int[], int) back to an <c>int</c> array.
            <para><c>N</c> is the number of coefficients. <c>q</c> must be a power of <c>2</c>.
            Ignores any excess bytes.</para>
            </summary>
            
            <param name="InputStream">An encoded ternary polynomial</param>
            <param name="N">The number of coefficients</param>
            <param name="Q">The modulus</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.EncodeMod3Sves(System.Int32[],System.Boolean)">
            <summary>
            Encodes an <c>int</c> array whose elements are between <c>-1</c> and <c>1</c>, to a byte array.
            <para><c>coeffs[2*i]</c> and <c>coeffs[2*i+1]</c> must not both equal -1 for any integer <c>i</c>,
            so this method is only safe to use with arrays produced by {@link #decodeMod3Sves(byte[], int, boolean)}.
            See P1363.1 section 9.2.3.</para>
            </summary>
            
            <param name="Data">The input array</param>
            <param name="SkipFirst">Whether to skip the constant coefficient</param>
            
            <returns>The encoded array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.EncodeMod3Tight(System.Int32[])">
            <summary>
            Encodes an <c>int</c> array whose elements are between <c>-1</c> and <c>1</c>, to a byte array
            </summary>
            
            <param name="Data">The input array</param>
            
            <returns>he encoded array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.EncodeModQ(System.Int32[],System.Int32)">
            <summary>
            Encodes an int array whose elements are between 0 and <c>Q</c>, to a byte array leaving no gaps between bits.
            <para><c>Q</c> must be a power of 2.</para>
            </summary>
            
            <param name="A">The input array</param>
            <param name="Q">The modulus</param>
            
            <returns>The encoded array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.EncodeModQTrunc(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Like EncodeModQ(int[], int) but only returns the first <c>NumBytes</c> bytes of the encoding
            </summary>
            
            <param name="Data">The input array</param>
            <param name="Q">The modulus</param>
            <param name="NumBytes">The encoded array</param>
            
            <returns>Returns T</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.ReadFullLength(System.IO.Stream,System.Int32)">
            <summary>
            Reads a given number of bytes from an <c>InputStream</c>.
            <para>If there are not enough bytes in the stream, an <c>IOException</c> is thrown.</para>
            </summary>
            
            <param name="InputStream">The input stream containing the data to read</param>
            <param name="Length">The length of the input stream </param>
            
            <returns>An array of length <c>Length</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.ToByteArray(System.Int32)">
            <summary>
            Convert an integer value to a two byte array
            </summary>
            
            <param name="Value">The integer to convert</param>
            
            <returns>The byte array value</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair">
            <summary>
            An Ntru Key-Pair container
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Constructs a new key pair
            </summary>
            
            <param name="PublicKey">The Public key</param>
            <param name="PrivateKey">The Private Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Constructs a new key pair
            </summary>
            
            <param name="Key">The public or private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if an invalid name is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.#ctor(System.IO.MemoryStream)">
            <summary>
            Reads a key pair from an input stream.
            <para>Note: both keys must be present in the stream; ordered Public, Private.</para>
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key pair</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.#ctor(System.Byte[])">
            <summary>
            Reads a key pair  from a byte array.
            <para>Note: both keys must be present in the stream; ordered Public, Private.</para>
            </summary>
            
            <param name="ParamArray">Byte array containing a parameter set</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.IsValid">
            <summary>
            Tests if the key pair is valid.
            <para>See IEEE 1363.1 section 9.2.4.1.</para>
            </summary>
            
            <returns>if the key pair is valid, <c>true</c> otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.ToBytes">
            <summary>
            Converts the key pair to a byte array
            </summary>
            
            <returns>The encoded key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.ToStream">
            <summary>
            Returns the current key pair set as a MemoryStream
            </summary>
            
            <returns>NtruKeyPair as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.WriteTo(System.Byte[])">
            <summary>
            Writes the key pair to an output byte array
            </summary>
            
            <param name="Output">NtruKeyPair as a byte array; can be initialized as zero bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the key pair to an output byte array
            </summary>
            
            <param name="Output">NtruKeyPair as a byte array; can be initialized as zero bytes</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.WriteTo(System.IO.Stream)">
            <summary>
            Writes the key pair to an output stream
            </summary>
            
            <param name="Output">Output Stream</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if an IO exception is raised</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.Clone">
            <summary>
            Create a copy of this key pair instance
            </summary>
            
            <returns>The IAsymmetricKeyPair copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.Name">
            <summary>
            Get: KeyPair name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.PrivateKey">
            <summary>
            Returns the private key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.PublicKey">
            <summary>
            Returns the public key
            </summary>
            
            <returns>The public key</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.StreamCiphers">
            <summary>
            Stream Ciphers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.StreamCiphers.ChaCha">
            <summary>
            An implementation of the ChaCha Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.StreamCiphers.Fusion">
            <summary>
            An implementation of the Twofish and Rijndael Merged Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.StreamCiphers.Salsa">
            <summary>
            A Salsa20 Stream Cipher
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.ArrayUtils">
            <summary>
            Extended array methods
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddAt(System.Byte[]@,System.Byte,System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Value">The new value</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddAt(System.Int32[]@,System.Int32,System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Value">The new value</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddAt(System.Int64[]@,System.Int64,System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Value">The new value</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddRange(System.Byte[]@,System.Byte[],System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Data">The new value members</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddRange(System.Int32[]@,System.Int32[],System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Data">The new value members</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddRange(System.Int64[]@,System.Int64[],System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Data">The new value members</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.Byte[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.Int32[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.UInt32[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.Int64[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.UInt64[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.CreateJagged``1(System.Int32[])">
            <summary>
            Create and initialize a jagged array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Lengths">The arrays lengths</param>
            
            <returns>Initialized jagged array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.InitializeJagged(System.Type,System.Int32,System.Int32[])">
            <summary>
            Initialize a jagged array
            </summary>
            
            <param name="Type">Type of array</param>
            <param name="Index">The first row index of the array outer array</param>
            <param name="Lengths">The arrays lengths</param>
            
            <returns>The initialized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveAt(System.Byte[]@,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            <typeparam name="T">The type of array</typeparam>
            <param name="Source">The source array</param>
            <param name="Index">The index of the element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveAt(System.Int32[]@,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            <typeparam name="T">The type of array</typeparam>
            <param name="Source">The source array</param>
            <param name="Index">The index of the element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveAt(System.Int64[]@,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            <typeparam name="T">The type of array</typeparam>
            <param name="Source">The source array</param>
            <param name="Index">The index of the element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveRange(System.Byte[]@,System.Int32,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            <param name="Source">The source array</param>
            <param name="From">First element to remove</param>
            <param name="To">Last element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveRange(System.Int32[]@,System.Int32,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            <param name="Source">The source array</param>
            <param name="From">First element to remove</param>
            <param name="To">Last element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveRange(System.Int64[]@,System.Int64,System.Int64)">
            <summary>
            Remove an element from the array
            </summary>
            <param name="Source">The source array</param>
            <param name="From">First element to remove</param>
            <param name="To">Last element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.Byte[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.Int32[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.UInt32[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.Int64[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.UInt64[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.SByte[])">
            <summary>
            Copy an sbyte array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Sbyte array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int32[])">
            <summary>
            Copy an int array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Int array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.UInt32[])">
            <summary>
            Copy an uint array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Uint array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int64[])">
            <summary>
            Copy an long array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Long array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.String)">
            <summary>
            Copy a string to an ASCII byte array
            </summary>
            
            <param name="Value">String to copy</param>
            
            <returns>The byte array representation</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BitLevel">
            <summary>
            Static library that provides all the bit level operations for BigInteger. 
            
            <description>The operations are:</description>
            <list type="number">
            <item><description>Left Shifting</description></item>
            <item><description>Right Shifting</description></item>
            <item><description>Bit Clearing</description></item>
            <item><description>Bit Setting</description></item>
            <item><description>Bit Counting</description></item>
            <item><description>Bit Testing</description></item>
            <item><description>Getting of the lowest bit set</description></item>
            </list>
            
            <para>All operations are provided in immutable way, and some in both mutable and immutable.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.BitCount(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns the number of bits in the binary representation of this which differ from the sign bit. 
            <para>Use BitLength(0) if you want to know the length of the binary value in bits.
            If this is positive the result is equivalent to the number of bits set in the binary representation of this.
            If this is negative the result is equivalent to the number of bits set in the binary representation of -this - 1.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.BitLength(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns the length of the value's two's complement representation without 
            leading zeros for positive numbers / without leading ones for negative values.
            <para>The two's complement representation of this will be at least BitLength() + 1 bits long.
            The value will fit into an int if <c>bitLength() &lt; 32</c> or into a long if <c>bitLength() &lt; 64</c>.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.FlipBit(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger which has the same binary representation 
            as this but with the bit at position N flipped. 
            <para>The result is equivalent to this ^ 2^N.</para>
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Position where the bit in this has to be flipped</param>
            
            <returns>Returns <c>this ^ 2^N</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if a negative bit address is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.InplaceShiftLeft(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Performs val &lt;= count, val should have enough place (and one digit more)
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Shift distance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.InplaceShiftRight(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Performs Value >>= count where Value is a positive number.
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Shift distance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.NonZeroDroppedBits(System.Int32,System.Int32[])">
            <summary>
            Check if there are 1s in the lowest bits of this BigInteger
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftLeft(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is this &lt;&lt; N.
            <para>The result is equivalent to <c>this * 2^n</c> if n >= 0.
            The shift distance may be negative which means that this is shifted right.
            The result then corresponds to <c>Floor(this / 2^(-n))</c>.</para>
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Shift distance</param>
            
            <returns>Returns <c>this &lt;&lt; N</c> if n >= 0, <c>this >> (-N)</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftLeft(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Abstractly shifts left an array of integers in little endian (i.e. shift it right).
            Total shift distance in bits is intCount * 32 + count
            </summary>
            
            <param name="Result">The result</param>
            <param name="Value">The source BigIntger</param>
            <param name="IntCount">The number integers</param>
            <param name="N">The number of bits to shift</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftLeftOneBit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Shifts the source digits left one bit, creating a value whose magnitude is doubled.
            </summary>
            
            <param name="Value">The source BigIntger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftLeftOneBit(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Shifts the source digits left one bit, creating a value whose magnitude is doubled.
            </summary>
            
            <param name="Result">The result</param>
            <param name="Value">The source BigIntger</param>
            <param name="ValueLen">The value length</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftRight(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this >> N</c>
            <para>For negative arguments, the result is also negative. 
            The shift distance may be negative which means that this is shifted left.
            </para>
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Shift distance</param>
            
            <returns>this >> N, if N >= 0; this &lt;&lt; (-n) otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftRight(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this >> N</c>
            <para>For negative arguments, the result is also negative. 
            The shift distance may be negative which means that this is shifted left.
            </para>
            </summary>
            
            <param name="Result">The result</param>
            <param name="ResultLen">The result length</param>
            <param name="Value">The source BigIntger</param>
            <param name="IntCount">The number integers</param>
            <param name="N">Shift distance</param>
            
            <returns>this >> N, if N >= 0; this &lt;&lt; (-n) otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.TestBit(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Tests whether the bit at position N in this is set.
            <para>The result is equivalent to <c>this &amp; (2^n) != 0</c>.</para>
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Position where the bit in this has to be inspected.</param>
            
            <returns>Returns this &amp; (2^n) != 0</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException">
            <summary>
            Wraps exceptions thrown within a MAC operational context.
            <para>This exception is used throughout the Mac domain.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Exceptions.CryptoMacException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg">
            <summary>
            Generates seed material for a CSPrng using various processed system counters passed through an XorShift+ generator.
            <para>An original construct (experimental) meant to provide an alternative to the RNGCryptoServiceProvider as a source of pseudo random seeding material.
            This class is suitable for generating seeds for a Prng or Drbg implementation.</para>
            </summary>
            
            
            <example>
            <description>Example of getting a seed value:</description>
            <code>
            byte[] seed;
            using (XSPRsg rnd = new XSPRsg())
                seed = rnd.GetSeed(48);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/09" version="1.4.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Prng">VTDev.Libraries.CEXEngine.Crypto Prng Classes</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <para>The seed generator uses system counters and state information, that are pre-processed via modular arithmetic, 
            converted to a byte array, and then processed with an XorShift+ random generator.
            The maximum allocation size is 1024 bytes.</para>
            
            <description>XSPGenerator uses the following state values as initial entropy sources:</description>
            <list type="bullet">
            <item><description>Network: Combined interface values for the BytesSent, UnicastPacketsSent, NonUnicastPacketsSent, BytesReceived, UnicastPacketsReceived and NonUnicastPacketsReceived values.</description></item>
            <item><description>Current Process: Handle, StartTime ticks, PeakWorkingSet64, NonpagedSystemMemorySize64, PagedSystemMemorySize64, HandleCount, and Id.</description></item>
            <item><description>Combined running processes and threads: WorkingSet64, VirtualMemorySize64, StartAddress, Id, and CurrentPriority.</description></item>
            <item><description>Environment: Ticks since startup, the Time in Ticks.</description></item>
            <item><description>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.Initialize">
            <summary>
            Re-initializes the generator with new state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.GetSeed(System.Int32)">
            <summary>
            Get a pseudo random seed byte array
            </summary>
            
            <param name="Size">The size of the seed returned; up to a maximum of 1024 bytes</param>
            
            <returns>A pseudo random seed</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if the requested size exceeds maximum allowable allocation (1024 bytes)</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng">
            <summary>
            <h3>An implementation of a passphrase based PKCS#5 random number generator.</h3>
            <para>Implements PKCS#5 as defined in RFC 2898</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new PBPRng(new SHA512(), PassPhrase, Salt))
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/28/15" version="1.3.2.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac HMAC</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2898: <see href="http://tools.ietf.org/html/rfc2898">Specification</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Byte[],System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Creates a new PassphrasePrng from a passphrase and salt,
            and seeds it with the output of PKCS5
            </summary>
            
            <param name="Digest">Digest engine</param>
            <param name="Passphrase">The passphrase</param>
            <param name="Salt">The salt value</param>
            <param name="Iterations">The number of transformation iterations performed by the digest with PKCS5 (default is 10,000)</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Dispose"/> on this class is called (default is true)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoRandomException">Thrown if a null Digest, Passphrase or Salt are used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.CreateBranch(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest)">
            <summary>
            Creates a new Passphrase rng whose output differs but is a
            function of this rng's internal state.
            </summary>
            
            <param name="Digest">The digest instance</param>
            
            <returns>Returns a PassphrasePrng instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.TernaryPolynomialType">
            <summary>
            TernaryPolynomialType enumeration
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.TernaryPolynomialType.SIMPLE">
            <summary>
            Use Ternary type key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.TernaryPolynomialType.PRODUCT">
            <summary>
            Use Product form type key
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters">
            <summary>
            Creates, reads and writes parameter settings for NtruEncrypt.
            <para>Predefined parameter sets are available and new ones can be created as well.
            These predefined settings are accessable through the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets"/> class</para>
            </summary>
            
            <example>
            <description>Create a parameter set and write to stream:</description>
            <code>
            MemoryStream ks = new MemoryStream();
            using (NtruParameters np = new NtruParameters(new byte[] { 2, 1, 1, 63 }, 1087, 2048, 120, 120, 0, 256, 13, 25, 14, true, true, false, Digests.SHA512))
               np.WriteTo(ks);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.0.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUEncrypt Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
            
            <remarks>
            <description><h4>NTRU Parameter Description:</h4></description>
            <list type="table">
            <item><description><c>OId</c> - Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The NTRU family must be <c>2</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</description></item>
            <item><description><c>N</c> - Degree Parameter. A positive integer. The associated NTRU lattice has dimension 2N.</description></item>
            <item><description><c>q</c> - Large Modulus. A positive integer. The associated NTRU lattice is a convolution modular lattice of modulus q.</description></item>
            <item><description><c>p</c> - Small Modulus. An integer or a polynomial.</description></item>
            <item><description><c>Df, Dg</c> - Private Key Spaces. Sets of small polynomials from which the private keys are selected.</description></item>
            <item><description><c>Dm</c> - Plaintext Space. Set of polynomials that represent encryptable messages.</description></item>
            <item><description><c>Dr</c> - Blinding Value Space. Set of polynomials from which the temporary blinding value used during encryption is selected.</description></item>
            <item><description><c>Center</c> - Centering Method. A means of performing mod q reduction on decryption.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NTRU: A Ring Based Public Key Crypto System<cite>NTRU Crypto</cite>.</description></item>
            <item><description>Optimizations for NTRU<cite>NTRU Optimizations</cite>.</description></item>
            <item><description>Adaptive Key Recovery Attacks on NTRU-based Somewhat Homomorphic Encryption Schemes<cite>NTRU Adaptive</cite>.</description></item>
            <item><description>Efficient Embedded Security Standards (EESS)<cite>NTRU EESS</cite>.</description></item>
            <item><description>Practical lattice-based cryptography: NTRUEncrypt and NTRUSign<cite>NTRU Practical</cite>.</description></item>
            <item><description>NTRU Cryptosystems Technical Report<cite>NTRU Technical</cite>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent java project NTRU Encrypt by Tim Buktu: <see href="https://github.com/tbuktu/ntru/description">Release 1.2</see>, and
            the NTRUOpenSourceProject/ntru-crypto project provided by Security Innovation, Inc <see href="https://github.com/NTRUOpenSourceProject/ntru-crypto">NTRU Encrypt</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Constructs a parameter set that uses ternary private keys (i.e. <c>PolyType=SIMPLE</c>)
            </summary>
            
            <param name="OId">OId - Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The NTRU family must be <c>2</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</param>
            <param name="N">The ring dimension; the number of polynomial coefficients</param>
            <param name="Q">The big Q Modulus</param>
            <param name="Df">Number of ones in the private polynomial <c>f</c></param>
            <param name="Dm0">Minimum acceptable number of -1's, 0's, and 1's in the polynomial <c>m</c> in the last encryption step</param>
            <param name="MaxM1">Maximum absolute value of mTrin.sumCoeffs() or zero to disable this check. Values greater than zero cause the constant coefficient of the message to always be zero.</param>
            <param name="Db">Number of random bits to prepend to the message; should be a multiple of 8</param>
            <param name="CBits">The number of bits in candidate for deriving an index in IGF-2</param>
            <param name="MinIGFHashCalls">Minimum number of hash calls for the IGF to make</param>
            <param name="MinMGFHashCalls">Minimum number of calls to generate the masking polynomial</param>
            <param name="HashSeed">Whether to hash the seed in the MGF first (true), or use the seed directly (false)</param>
            <param name="Sparse">Whether to treat ternary polynomials as sparsely populated; SparseTernaryPolynomial vs DenseTernaryPolynomial</param>
            <param name="FastFp">Whether <c>f=1+p*F</c> for a ternary <c>F</c> (true) or <c>f</c> is ternary (false)</param>
            <param name="Digest">The Message Digest engine to use; default is SHA512</param>
            <param name="Random">The pseudo random generator engine to use; default is CTRPrng</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if the Oid format is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Constructs a parameter set that uses product-form private keys (i.e. <c>PolyType=PRODUCT</c>).
            </summary>
            
            <param name="OId">OId - Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The NTRU family must be <c>2</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</param>
            <param name="N">N number of polynomial coefficients</param>
            <param name="Q">The big Q Modulus</param>
            <param name="Df1">Number of ones in the private polynomial <c>f1</c></param>
            <param name="Df2">Number of ones in the private polynomial <c>f2</c></param>
            <param name="Df3">Number of ones in the private polynomial <c>f3</c></param>
            <param name="Dm0">Minimum acceptable number of -1's, 0's, and 1's in the polynomial <c>m'</c> in the last encryption step</param>
            <param name="MaxM1">Maximum absolute value of mTrin.sumCoeffs() or zero to disable this check. Values greater than zero cause the constant coefficient of the message to always be zero.</param>
            <param name="Db">Number of random bits to prepend to the message; should be a multiple of 8</param>
            <param name="CBits">The number of bits in candidate for deriving an index in IGF-2</param>
            <param name="MinIGFHashCalls">Minimum number of hash calls for the IGF to make</param>
            <param name="MinMGFHashCalls">Minimum number of calls to generate the masking polynomial</param>
            <param name="HashSeed">Whether to hash the seed in the MGF first (true) or use the seed directly (false)</param>
            <param name="Sparse">Whether to treat ternary polynomials as sparsely populated SparseTernaryPolynomial vs DenseTernaryPolynomial</param>
            <param name="FastFp">Whether <c>F=1+p*F</c> for a ternary <c>F</c> (true) or <c>F</c> is ternary (false)</param>
            <param name="Digest">The Message Digest engine to use; default is SHA512</param>
            <param name="Random">The pseudo random generator engine to use; default is CTRPrng</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if the Oid format is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.#ctor(System.IO.Stream)">
            <summary>
            Builds a parameter set from an encoded input stream
            </summary>
            
            <param name="ParamStream">Stream containing a parameter set</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if the Stream is unreadable</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.#ctor(System.Byte[])">
            <summary>
            Builds a parameter set from an encoded byte array
            </summary>
            
            <param name="ParamArray">Byte array containing a parameter set</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.From(System.Byte[])">
            <summary>
            Read an encoded Parameter set from a byte array
            </summary>
            
            <param name="ParamArray">The byte array containing the parameters</param>
            
            <returns>An initialized NTRUParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.From(System.IO.Stream)">
            <summary>
            Read an encoded Parameters set from a Stream
            </summary>
            
            <param name="ParamStream">The Stream containing the encoded Parameter set</param>
            
            <returns>An initialized NTRUParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.GetMaxMessageLength">
            <summary>
            Returns the maximum length a plaintext message can be with this parameter set
            </summary>
            
            <returns>The maximum length in bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.GetOutputLength">
            <summary>
            Returns the length of a message after encryption with this parameter set
            <para>The length does not depend on the input size.</para>
            </summary>
            
            <returns>The length in bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.ToBytes">
            <summary>
            Converts the current Parameter set to an encoded byte array
            </summary>
            
            <returns>NtruParameters as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.ToStream">
            <summary>
            Converts the current Parameter set to an encoded Stream
            </summary>
            
            <returns>NtruParameters as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.WriteTo(System.Byte[])">
            <summary>
            Writes the NTRUParameters to a byte array
            </summary>
            
            <param name="Output">Output array receiving the encoded Parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the NTRUParameters to a byte array
            </summary>
            
            <param name="Output">Output array receiving the encoded Parameters</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoAsymmetricException">Thrown if The output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.WriteTo(System.IO.Stream)">
            <summary>
            Writes the NTRUParameters to a Stream
            </summary>
            
            <param name="Output">The Output stream receiving the encoded Parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Clone">
            <summary>
            Create a shallow copy of this NTRUParameters instance
            </summary>
            
            <returns>The NTRUParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DeepCopy">
            <summary>
            Create a deep copy of this NTRUParameters instance
            </summary>
            
            <returns>The NTRUParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Name">
            <summary>
            Get: Parameters name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.N">
            <summary>
            Get: The ring dimension; the number of polynomial coefficients
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Q">
            <summary>
            Get: The big q Modulus
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.CBits">
            <summary>
            Get: The number of bits in candidate for deriving an index in IGF-2
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Db">
            <summary>
            Get: Number of random bits to prepend to the message; should be a multiple of 8
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DF">
            <summary>
            Get: Number of ones in the private polynomial <c>f</c>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DF1">
            <summary>
            Get/Set: Number of ones in the private polynomial <c>f1</c>; Product form of Df
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DF2">
            <summary>
            Get/Set: Number of ones in the private polynomial <c>f2</c>; Product form of Df
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DF3">
            <summary>
            Get/Set: Number of ones in the private polynomial <c>f3</c>; Product form of Df
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Dm0">
            <summary>
            Get: Minimum acceptable number of -1's, 0's, and 1's in the polynomial <c>m</c> in the last encryption step
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DR">
            <summary>
            Get: Blinding Value Space
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DR1">
            <summary>
            Get/Set: Blinding Value Space <c>dr1</c>; Product form of Dr
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DR2">
            <summary>
            Get/Set: Blinding Value Space <c>dr2</c>; Product form of Dr
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DR3">
            <summary>
            Get/Set: Blinding Value Space <c>dr3</c>; Product form of Dr
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.FastFp">
            <summary>
            Get/Set: Whether <c>F=1+p*F</c> for a ternary <c>F</c> (true) or <c>F</c> is ternary (false)
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.HashSeed">
            <summary>
            Get: Whether to hash the seed in the MGF first (true), or use the seed directly (false)
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Length">
            <summary>
            Get: Used in message length calculation
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.MaxM1">
            <summary>
            Get: Maximum absolute value of mTrin.sumCoeffs() or zero to disable this check. 
            <para>Values greater than zero cause the constant coefficient of the message to always be zero.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.MaxMsgLenBytes">
            <summary>
            Get: The maximum length a plaintext message can be with this parameter set
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Digest">
            <summary>
            Get/Set: The Message Digest engine to use; default is SHA512
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.MinIGFHashCalls">
            <summary>
            Get: Minimum number of hash calls for the IGF to make
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.MinMGFHashCalls">
            <summary>
            Get: Minimum number of calls to generate the masking polynomial
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.OId">
            <summary>
            Get: Three bytes that uniquely identify the parameter set
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.PolyType">
            <summary>
            Get/Set: The polynomial type
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.RandomEngine">
            <summary>
            Get/Set: The pseudo random generator engine to use; default is CSPRng
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Sparse">
            <summary>
            Whether to treat ternary polynomials as sparsely populated; SparseTernaryPolynomial vs DenseTernaryPolynomialinternal
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519">
             <summary>
             Generic 64-bit integer implementation of Curve25519 ECDH.
             <para>Written by Matthijs van Duin, 200608242056
             Based on work by Daniel J Bernstein; 
             A state of the art Diffie-Hellman function<cite>A state-of-the-art Diffie-Hellman function</cite>
             Ported from C to Java by Dmitry Skiba [sahn0], 23/02/08.
             Ported to C# by John Underhill, 14/03/15.
             Original: <see href="http://cds.xs4all.nl:8081/ecdh/"/></para>
             </summary>
             
             <remarks>
             <example>
             <description>DIGITAL SIGNATURES : Deterministic EC-KCDSA</description>
             <code>
                s is the private key for signing
                P is the corresponding internal key
                Z is the context data (signer internal key or certificate, etc)
             </code>
             
             <description>signing:</description>
             <code>
                m = hash(Z, message)
                x = hash(m, s)
                keygen25519(Y, NULL, x);
                r = hash(Y);
                h = m XOR r
                sign25519(v, h, x, s);
            
                output (v,r) as the signature
             </code>
             
             <description>verification:</description>
             <code>
                m = hash(Z, message);
                h = m XOR r
                verify25519(Y, v, h, P)
            
                confirm  r == hash(Y)
             </code>
             </example>
             
             <para>It would seem to me that it would be simpler to have the signer directly do 
             h = hash(m, Y) and send that to the recipient instead of r, who can verify 
             the signature by checking h == hash(m, Y).  If there are any problems with 
             such a scheme, please let me know.</para>
             <para>Also, EC-KCDSA (like most DS algorithms) picks x random, which is a waste of 
             perfectly good entropy, but does allow Y to be calculated in advance of (or 
             parallel to) hashing the message.</para>
             </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Clamp(System.Byte[])">
            <summary>
            Private key clamping
            </summary>
            
            <param name="K">Private key for key agreement</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Keygen(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Key-pair generation
            </summary>
            
            <param name="P">Public key</param>
            <param name="S">Private key for signing</param>
            <param name="K">Private key for key agreement</param>
            
            <remarks>if S is not NULL, this function has data-dependent timing</remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Curve(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Key agreement
            </summary>
            
            <param name="Z">Shared secret (needs hashing before use)</param>
            <param name="K">Private key for key agreement</param>
            <param name="P">Peer's internal key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Signature generation primitive, calculates (x-h)s mod q
            </summary>
            
            <param name="V">Signature value</param>
            <param name="H">Signature hash (of message, signature pub key, and context data)</param>
            <param name="X">Signature private key</param>
            <param name="S">Private key for signing</param>
            
            <returns>True on success, false on failure (use different x or h)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Signature verification primitive, calculates Y = vP + hG
            </summary>
            
            <param name="Y">Signature internal key</param>
            <param name="V">Signature value</param>
            <param name="H">Signature hash</param>
            <param name="P">Public key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.MulaSmall(System.Byte[],System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <remarks>
            p[m..n+m-1] = q[m..n+m-1] + z * x, n is the size of x 
            n+m is the size of p and q
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Mula32(System.Byte[],System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <remarks>
            p += x * y * z  where z is a small integer.
            x is size 32, y is size t, p is size 32+t
            y is allowed to overlap with p+32 if you don't care about the upper half
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.DivMod(System.Byte[],System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <remarks>
            divide r (size n) by d (size t), returning quotient q and remainder r
            quotient is size n-t+1, remainder is size t
            requires t > 0 &amp; d[t-1] != 0
            requires that r[-1] and d[-1] are valid memory locations
            q may overlap with r+t
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Egcd32(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <remarks>
            Returns x if a contains the gcd, y if b.
            Also, the returned buffer contains the inverse of a mod b, as 32-byte signed.
            x and y must have 64 bytes space for temporary use.
            requires that a[-1] and b[-1] are valid memory locations
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Unpack(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,System.Byte[])">
            <remarks>
            Convert to internal format from little-endian byte format
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.IsOverflow(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Check if reduced-form input >= 2^255-19
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Pack(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,System.Byte[])">
            <remarks>
            Convert from internal format to little-endian byte format. 
            The number must be in a reduced form which is output by the following ops:
            unpack, mul, sqr
            set --  if input in range 0 .. P25
            If you're unsure if the number is reduced, first multiply it by 1.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Copy(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Copy a number
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Set(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,System.Int32)">
            <remarks>
            Set a number to value, which must be in range -185861411 .. 185861411
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.AddXY(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Add/subtract two numbers.  The inputs must be in reduced form, and the 
            output isn't, so to do another addition or subtraction on the output, 
            first multiply it by one to reduce it. 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.MulSmall(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,System.Int64)">
            <remarks>
            Multiply a number by a small integer in range -185861411 .. 185861411.
            The output is in reduced form, the input x need not be.  x and xy may point
            to the same buffer. 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Mul(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Multiply two numbers.  The output is in reduced form, the inputs need not be.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Sqr(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Square a number. Optimization of  mul25519(x2, x, x)
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Recip(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,System.Int32)">
            <remarks>
            Calculates a reciprocal. The output is in reduced form, the inputs need not be. 
            Simply calculates  y = x^(p-2)  so it's not too fast. 
            When sqrtassist is true, it instead calculates y = x^((p-5)/8)
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.IsNegative(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Checks if x is "negative", requires reduced input 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Sqrt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            A square root
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.MontPrep(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            t1 = ax + az
            t2 = ax - az 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.MontAdd(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            A = P + Q   where:
            X(A) = ax/az
            X(P) = (t1+t2)/(t1-t2)
            X(Q) = (t3+t4)/(t3-t4)
            X(P-Q) = dx
            clobbers t1 and t2, preserves t3 and t4 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.MontDbl(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            B = 2 * Q   where:
            X(B) = bx/bz
            X(Q) = (t3+t4)/(t3-t4)
            clobbers t1 and t2, preserves t3 and t4
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.XtoY2(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Y^2 = X^3 + 486662 X^2 + X
            t is a temporary
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Core(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <remarks>
            P = kG   and  s = sign(P)/k
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10">
            <remarks>
            Using this class instead of long[10] to avoid bounds checks.
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR">
            <summary>
            <h3>Implements a Parallel Segmented Counter Mode: CTR.</h3>
            <para>CTR as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RDX(), [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Parallel processing is enabled by passing a block size of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelBlockSize"/> to the transform.</description></item>
            <item><description><see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelBlockSize"/> must be divisible by <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize"/>.</description></item>
            <item><description>Parallel block calculation ex. <c>int blocklen = (data.Length / cipher.ParallelMinimumSize) * 10</c></description></item>
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Cipher is used. for encryption, false to decrypt</param>
            <param name="KeyParam">The KeyParams containing key and vector</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a null Key or IV is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. Parallel capable function if Output array length is at least equal to <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize"/>. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters.  Parallel capable function if Output array length is at least equal to <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize"/>. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.IV">
            <summary>
            Get: The current state of the initialization Vector
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.CryptoSymmetricException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, or  block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ProcessorCount">
            <remarks>
            Get: Processor count
            </remarks>
        </member>
    </members>
</doc>
